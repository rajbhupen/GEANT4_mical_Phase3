%!PS-Adobe-3.0
%%Title: InoTrackFitAlg.cc
%%Creator: ps-print v7.3.5
%%For: Raj
%%CreationDate: 17:59:31 Aug 26 2021
%%Orientation: Portrait
%%DocumentNeededResources: font Times-Roman Times-Italic
%%+ font Courier
%%+ font Courier-Bold
%%+ font Courier-Oblique
%%+ font Courier-BoldOblique
%%+ font Helvetica
%%+ font Helvetica-Bold
%%DocumentSuppliedResources: procset PSPrintUserDefinedPrologue-raj 0 0
%%DocumentMedia: A4 595 842 0 () ()
%%PageOrder: Ascend
%%Pages: (atend)
%%Requirements:
%%EndComments
%%BeginDefaults
%%PageMedia: A4
%%EndDefaults

%%BeginProlog

/languagelevel where{pop}{/languagelevel 1 def}ifelse
/ErrorMessage  1 def

% === BEGIN ps-print prologue 0
% version: 6.0

% Copyright (C) 2000-2017 Free Software Foundation, Inc.

% This file is part of GNU Emacs.

% GNU Emacs is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.

% GNU Emacs is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.

% You should have received a copy of the GNU General Public License
% along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.

% As a special exception, the copyright holders of this module give
% you permission to include the module in a Postscript file generated
% by Emacs or other free software together with the result of
% converting text to be printed, regardless of the license terms of
% that text, and to use under terms of your choice the page images
% resulting from formatting said combination.  If you modify this
% module, you may extend this exception to your version of the module
% but you are not obligated to do so.  If you do not wish to do so,
% delete this exception statement from your version.


%%BeginProcSet: ErrorHandler
% Downloaded Error Break-page handler
% Adapted from:
%     PostScript Language Program Design,
%     Adobe Systems Incorporated.
%     Appendix A, pages 217-219

/ps$brkpage where{pop}
{
 /ps$brkpage 64 dict def
 ps$brkpage begin
  /tx 0 def/ty 0 def/toy 0 def/tox 0 def
  /prnt{
   dup type/stringtype ne{=string cvs}if
   dup length 6 mul
   /tx exch def/ty 10 def
   currentpoint/toy exch def/tox exch def
   1 setgray newpath
   tox toy 2 sub moveto
   0 ty rlineto tx 0 rlineto
   0 ty neg rlineto
   closepath fill
   tox toy moveto 0 setgray show
  }bind def
  /nl{currentpoint exch pop lmargin exch moveto 0 -10 rmoveto}def
  /=={/cp 0 def typeprint nl}def
  /typeprint{dup type dup currentdict exch known{exec}{unknowntype}ifelse}readonly def
  /lmargin 72 def
  /rmargin 72 def
  /tprint{
   dup length cp add rmargin gt{nl/cp 0 def}if
   dup length cp add/cp exch def
   prnt
  }readonly def
  /cvsprint{=string cvs tprint( )tprint}readonly def
  /unknowntype{exch pop cvlit(??)tprint cvsprint}readonly def
  /integertype{cvsprint}readonly def
  /realtype{cvsprint}readonly def
  /booleantype{cvsprint}readonly def
  /operatortype{(//)tprint cvsprint}readonly def
  /marktype{pop(-mark-)tprint}readonly def
  /dicttype{pop(-dictionary-)tprint}readonly def
  /nulltype{pop(-null-)tprint}readonly def
  /filetype{pop(-filestream-)tprint}readonly def
  /savetype{pop(-savelevel-)tprint}readonly def
  /fonttype{pop(-fontid-)tprint}readonly def
  /nametype{dup xcheck not{(/)tprint}if cvsprint}readonly def
  /stringtype{
   dup rcheck
   {(\()tprint tprint(\))tprint}
   {pop(-string-)tprint}ifelse}readonly def
  /arraytype{
   dup rcheck
   {dup xcheck
    {({)tprint{typeprint}forall(})tprint}
    {([)tprint{typeprint}forall(])tprint}ifelse}
   {pop(-array-)tprint}ifelse}readonly def
  /packedarraytype{
   dup rcheck
   {dup xcheck
    {({)tprint{typeprint}forall(})tprint}
    {([)tprint{typeprint}forall(])tprint}ifelse}
   {pop(-packedarray-)tprint}ifelse}readonly def
  /courier/Courier findfont 10 scalefont def
  /OLDhandleerror errordict/handleerror get def
 end %ps$brkpage

 /handleerror{
  systemdict begin $error begin ps$brkpage begin
  newerror
  {/newerror false store vmstatus pop pop 0 ne{grestoreall}if
   initgraphics
   ErrorMessage 1 and 0 ne{ % print on paper
    courier setfont lmargin 720 moveto
    (# ERROR: )prnt errorname prnt nl
    (# OFFENDING COMMAND: )prnt/command load prnt
    $error/ostack known
    {nl nl(# STACK:)prnt nl nl $error/ostack get aload length{==}repeat}if
    $error/errorinfo known
    {nl nl(# ERRORINFO:)prnt nl nl $error/errorinfo get aload length{==}repeat}if
    systemdict/showpage get exec}if
   ErrorMessage 2 and 0 ne{ % send back to printing system
    (\%\%[ Error: )print errorname =print
    (; OffendingCommand: )print/command load =print
    $error/errorinfo known
    {(; ErrorInfo:)print $error/errorinfo get aload length{( )=print =print}repeat}if
    ( ]\%\%)= flush
    (\%\%[ Rest of job is ignored ]\%\%)= flush}if
   /newerror true store}if
  end end end
  stop
 } % handleerror
 dup 0 systemdict put % replace name by actual dict object
 dup 4 ps$brkpage put % replace name by dict object
 bind readonly

 errordict 3 1 roll put % put proc in errordict as /handleerror
}ifelse
%%EndProcSet


% operators for language level 2 only

(<<)cvn where			% << operator
{pop/BMark(<<)cvn load def}
{/BMark{mark}bind def}ifelse
(>>)cvn where			% >> operator
{pop/EMark(>>)cvn load def}
{/EMark{counttomark 2 idiv dup dict begin{def}repeat pop currentdict end}bind def}ifelse
/setpagedevice where		% setpagedevice
{pop}
{/setpagedevice{pop}bind def}ifelse
/packedarray where		% packedarray
{pop}
{/packedarray{array astore readonly}bind def}ifelse


% device dependent operators

/DefOp{
 dup where{pop pop pop}
 {exch dup where{pop}{pop/pop}ifelse load def}ifelse}def

/duplexmode/setduplexmode DefOp
/tumble/settumble DefOp

% === END ps-print prologue 0

%%BeginResource: procset PSPrintUserDefinedPrologue-raj 0 0


%%EndResource

/LandscapeMode       false def
/UpsideDown          false def
/NumberOfColumns     1 def
/LandscapePageHeight 841.8897637795276 def
/PrintPageWidth      481.8897637795275 def
/PrintWidth   481.8897637795275 def
/PrintHeight  693.5927370078741 def
/LeftMargin   56.69291338582677 def
/RightMargin  56.69291338582677 def
/InterColumn  56.69291338582677 def
/BottomMargin 42.51968503937008 def
/TopMargin    42.51968503937008 def
/HeaderOffset 28.346456692913385 def
/HeaderPad    2.4276 def
/FooterOffset 28.346456692913385 def
/FooterPad    0 def
/FooterLines  2 def
/ShowNofN           true def
/SwitchHeader       false def
/PrintOnlyOneHeader false def
/PrintHeader        true def
/PrintHeaderFrame   true def
/HeaderFrameProperties [0.000 0.900 0.400 0.000 0.000 ]def
/PrintFooter        false def
/PrintFooterFrame   true def
/FooterFrameProperties [0.000 0.900 0.400 0.000 0.000 ]def
/LineSpacing      0 def
/ParagraphSpacing 0 def
/LineHeight       8.967500000000001 def
/LinesPerColumn   78 def
/WarnPaperSize    true def
/Zebra            false def
/PrintLineNumber  false def
/SyncLineZebra    false def
/ZebraFollow      0 def
/PrintLineStep    1 def
/PrintLineStart   1 def
/LineNumberColor  [0.000 0.000 0.000] def
/ZebraHeight      3 def
/ZebraColor       0.950 def
/BackgroundColor  [1.000 1.000 1.000] def
/UseSetpagedevice false def

/PageWidth PrintPageWidth LeftMargin add RightMargin add def

/N-Up           1 def
/N-Up-Landscape false def
/N-Up-Border    true def
/N-Up-Lines     1 def
/N-Up-Columns   1 def
/N-Up-Missing   0 def
/N-Up-Margin    28.346456692913385 def
/N-Up-Repeat    N-Up-Lines def
/N-Up-End       N-Up-Columns def
/N-Up-XColumn   PageWidth def
/N-Up-YColumn   0 def
/N-Up-XLine     N-Up-End 1 sub PageWidth mul neg def
/N-Up-YLine     LandscapePageHeight neg def
/N-Up-XStart    0 def
/N-Up-YStart    0 def

% === BEGIN ps-print prologue 1
% version: 6.1

% Copyright (C) 2000-2017 Free Software Foundation, Inc.

% This file is part of GNU Emacs.

% GNU Emacs is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.

% GNU Emacs is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.

% You should have received a copy of the GNU General Public License
% along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.

% As a special exception, the copyright holders of this module give
% you permission to include the module in a Postscript file generated
% by Emacs or other free software together with the result of
% converting text to be printed, regardless of the license terms of
% that text, and to use under terms of your choice the page images
% resulting from formatting said combination.  If you modify this
% module, you may extend this exception to your version of the module
% but you are not obligated to do so.  If you do not wish to do so,
% delete this exception statement from your version.


% ISOLatin1Encoding stolen from ps_init.ps in GhostScript 2.6.1.4:
/ISOLatin1Encoding where{pop}{
% -- The ISO Latin-1 encoding vector isn't known, so define it.
% -- The first half is the same as the standard encoding,
% -- except for minus instead of hyphen at code 055.
/ISOLatin1Encoding
StandardEncoding 0 45 getinterval aload pop
    /minus
StandardEncoding 46 82 getinterval aload pop
%*** NOTE: the following are missing in the Adobe documentation,
%*** but appear in the displayed table:
%*** macron at 0225, dieresis at 0230, cedilla at 0233, space at 0240.
% 0200 (128)
    /.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
    /.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
    /dotlessi/grave/acute/circumflex/tilde/macron/breve/dotaccent
    /dieresis/.notdef/ring/cedilla/.notdef/hungarumlaut/ogonek/caron
% 0240 (160)
    /space/exclamdown/cent/sterling
	/currency/yen/brokenbar/section
    /dieresis/copyright/ordfeminine/guillemotleft
	/logicalnot/hyphen/registered/macron
    /degree/plusminus/twosuperior/threesuperior
	/acute/mu/paragraph/periodcentered
    /cedilla/onesuperior/ordmasculine/guillemotright
	/onequarter/onehalf/threequarters/questiondown
% 0300 (192)
    /Agrave/Aacute/Acircumflex/Atilde
	/Adieresis/Aring/AE/Ccedilla
    /Egrave/Eacute/Ecircumflex/Edieresis
	/Igrave/Iacute/Icircumflex/Idieresis
    /Eth/Ntilde/Ograve/Oacute
	/Ocircumflex/Otilde/Odieresis/multiply
    /Oslash/Ugrave/Uacute/Ucircumflex
	/Udieresis/Yacute/Thorn/germandbls
% 0340 (224)
    /agrave/aacute/acircumflex/atilde
	/adieresis/aring/ae/ccedilla
    /egrave/eacute/ecircumflex/edieresis
	/igrave/iacute/icircumflex/idieresis
    /eth/ntilde/ograve/oacute
	/ocircumflex/otilde/odieresis/divide
    /oslash/ugrave/uacute/ucircumflex
	/udieresis/yacute/thorn/ydieresis
256 packedarray def
}ifelse

/reencodeFontISO{ %def
  dup
  length 12 add dict	% Make a new font (a new dict the same size
			% as the old one) with room for our new symbols.

  begin			% Make the new font the current dictionary.

    % Copy each of the symbols from the old dictionary
    % to the new one except for the font ID.
    {1 index/FID ne{def}{pop pop}ifelse}forall

    % Override the encoding with the ISOLatin1 encoding.
    currentdict/FontType get 0 ne{/Encoding ISOLatin1Encoding def}if

    % Use the font's bounding box to determine the ascent, descent,
    % and overall height; don't forget that these values have to be
    % transformed using the font's matrix.

%          ^    (x2 y2)
%          |       |
%          |       v
%          |  +----+ - -
%          |  |    |   ^
%          |  |    |   | Ascent (usually > 0)
%          |  |    |   |
% (0 0) -> +--+----+-------->
%             |    |   |
%             |    |   v Descent (usually < 0)
% (x1 y1) --> +----+ - -

    currentdict/FontType get 0 ne
    {/FontBBox load aload pop			% -- x1 y1 x2 y2
     FontMatrix transform/Ascent  exch def pop
     FontMatrix transform/Descent exch def pop}
    {/PrimaryFont FDepVector 0 get def
     PrimaryFont/FontBBox get aload pop
     PrimaryFont/FontMatrix get transform/Ascent exch def pop
     PrimaryFont/FontMatrix get transform/Descent exch def pop}ifelse

    /FontHeight Ascent Descent sub def	% use `sub' because descent < 0

    % Define these in case they're not in the FontInfo
    % (also, here they're easier to get to).
    /UnderlinePosition  Descent 0.70 mul def
    /OverlinePosition   Descent UnderlinePosition sub Ascent add def
    /StrikeoutPosition  Ascent 0.30 mul def
    /LineThickness      FontHeight 0.05 mul def
    /Xshadow            FontHeight  0.08 mul def
    /Yshadow            FontHeight -0.09 mul def
    /SpaceBackground    Descent neg UnderlinePosition add def
    /XBox               Descent neg def
    /YBox               LineThickness 0.7 mul def

    currentdict		% Leave the new font on the stack
    end			% Stop using the font as the current dictionary.
    definefont		% Put the font into the font dictionary
    pop			% Discard the returned font.
}bind def

% Font definition
/DefFont{findfont exch scalefont reencodeFontISO}def

% Font selection
/F{
  findfont
  dup/Ascent            get/Ascent            exch def
  dup/Descent           get/Descent           exch def
  dup/FontHeight        get/FontHeight        exch def
  dup/UnderlinePosition get/UnderlinePosition exch def
  dup/OverlinePosition  get/OverlinePosition  exch def
  dup/StrikeoutPosition get/StrikeoutPosition exch def
  dup/LineThickness     get/LineThickness     exch def
  dup/Xshadow           get/Xshadow           exch def
  dup/Yshadow           get/Yshadow           exch def
  dup/SpaceBackground   get/SpaceBackground   exch def
  dup/XBox              get/XBox              exch def
  dup/YBox              get/YBox              exch def
  setfont
}def

/FG/setrgbcolor load def

/bg false def
/BG{
  dup/bg exch def
  {[4 1 roll]}
  {[1.0 1.0 1.0]}
  ifelse
  /bgcolor exch def
}def

%  B    width    C
%   +-----------+
%               | Ascent  (usually > 0)
% A +           +
%               | Descent (usually < 0)
%   +-----------+
%  E    width    D

/dobackground{				% width --
  currentpoint				% -- width x y
  gsave
    newpath
    moveto				% A (x y)
    0 Ascent rmoveto			% B
    dup 0 rlineto			% C
    0 Descent Ascent sub rlineto	% D
    neg 0 rlineto			% E
    closepath
    FillBgColor
  grestore
}def

/eolbg{					% dobackground until right margin
  PrintWidth				% -- x-eol
  currentpoint pop			% -- cur-x
  sub					% -- width until eol
  dobackground
}def

/LineHS LineHeight LineSpacing add def
/ParagraphHS LineHeight ParagraphSpacing add def
/PSL{/h exch def bg{eolbg}if  0  currentpoint exch pop h sub  moveto}def
/PLN{PrintLineNumber{doLineNumber}if}def

/SL{LineHS PSL isLineStep pop}def	% Soft Linefeed

/PHL{ParagraphHS PSL PLN}def		% Paragraph Hard Linefeed
/LHL{LineHS PSL PLN}def			% Hard Linefeed

% Some debug
/dcp{currentpoint exch 40 string cvs print(, )print =}def
/dp{print 2 copy  exch 40 string cvs print(, )print =}def

/W{
  ( )stringwidth	% Get the width of a space in the current font.
  pop			% Discard the Y component.
  mul			% Multiply the width of a space
			% by the number of spaces to plot
  bg{dup dobackground}if
  0 rmoveto
}def

/Effect          0 def
/EffectUnderline false def
/EffectStrikeout false def
/EffectOverline  false def
/EffectShadow    false def
/EffectBox       false def
/EffectOutline   false def

% effect: 1  - underline  2   - strikeout  4  - overline
%         8  - shadow     16  - box        32 - outline
/EF{
  /Effect exch def
  /EffectUnderline Effect 1  and 0 ne def
  /EffectStrikeout Effect 2  and 0 ne def
  /EffectOverline  Effect 4  and 0 ne def
  /EffectShadow    Effect 8  and 0 ne def
  /EffectBox       Effect 16 and 0 ne def
  /EffectOutline   Effect 32 and 0 ne def
}def

% stack:  string  |-  --
/S{
  /xx currentpoint dup Descent add/yy exch def
  Ascent add/YY exch def def
  dup stringwidth pop xx add/XX exch def
  EffectShadow{
    /yy yy Yshadow add def
    /XX XX Xshadow add def
  }if
  bg{
    true
    EffectBox
      {SpaceBackground doBox}
      {xx yy XX YY doRect}
    ifelse
  }if						% background
  EffectBox      {false 0 doBox}if		% box
  EffectShadow   {dup doShadow}if		% shadow
  EffectOutline
    {true doOutline}				% outline
    {show}					% normal text
  ifelse
  EffectUnderline{UnderlinePosition Hline}if	% underline
  EffectStrikeout{StrikeoutPosition Hline}if	% strikeout
  EffectOverline {OverlinePosition  Hline}if	% overline
}bind def

% stack:  position  |-  --
/Hline{
  currentpoint exch pop add dup
  gsave
  newpath
  xx exch moveto
  XX exch lineto
  closepath
  LineThickness setlinewidth stroke
  grestore
}bind def

% stack:  fill-or-not delta  |-  --
/doBox{
  /dd exch def
  xx XBox sub dd sub yy YBox sub dd sub
  XX XBox add dd add YY YBox add dd add
  doRect
}bind def

% stack:  fill-or-not lower-x lower-y upper-x upper-y  |-  --
/doRect{
  /rYY exch def
  /rXX exch def
  /ryy exch def
  /rxx exch def
  gsave
  newpath
  rXX rYY moveto
  rxx rYY lineto
  rxx ryy lineto
  rXX ryy lineto
  closepath
  % top of stack: fill-or-not
  {FillBgColor}
  {LineThickness setlinewidth stroke}ifelse
  grestore
}bind def

% stack:  string  |-  --
/doShadow{
  gsave
  Xshadow Yshadow rmoveto
  false doOutline
  grestore
}bind def

/st 1 string def

% stack:  string fill-or-not  |-  --
/doOutline{
  /-fillp- exch def
  /-ox- currentpoint/-oy- exch def def
  gsave
  LineThickness setlinewidth
  {st 0 3 -1 roll put
   st dup true charpath
   -fillp- {gsave FillBgColor grestore}if
   stroke stringwidth
   -oy- add/-oy- exch def
   -ox- add/-ox- exch def
   -ox- -oy- moveto
  }forall
  grestore
  -ox- -oy- moveto
}bind def

% stack:  --
/FillBgColor{bgcolor aload pop setrgbcolor fill}bind def

% stack:  -- |- boolean
/isLineStep{
  SyncLineZebra
  {PLScounter 0 gt						% or zebra
   {/PLScounter PLScounter 1 sub def PLScounter 0 eq}
   {false}ifelse
   PrintLineStep 1 gt
   {/PrintLineStep PrintLineStep 1 sub def}
   {/PrintLineStep ZebraHeight def
    /PLScounter PrintLineStart def}ifelse}
  {LineNumber PrintLineStart sub PrintLineStep mod 0 eq}ifelse	% or line step
}def

% stack:  --
/doLineNumber{
  /LineNumber where
  {pop
   isLineStep			% or line step
   LineNumber Lines ge or	% or last line
   {currentfont
    gsave
    LineNumberColor SetColor
    /L0 findfont setfont
    LineNumber Lines ge
    {(end      )}
    {LineNumber 6 string cvs(      )strcat}ifelse
    dup stringwidth pop neg 0 rmoveto
    show
    grestore
    setfont}if
    /LineNumber LineNumber 1 add def
  }if
}def

% stack: color-specifier |- --
/SetColor{dup type/realtype eq{setgray}{aload pop setrgbcolor}ifelse}def

% stack: --
/printZebra{
  gsave
  ZebraColor SetColor
  /double-zebra ZebraHeight ZebraHeight add def
  /yiter double-zebra LineHS mul neg def
  /xiter PrintWidth InterColumn add def
  /zebra-line LinesPrinted def
  NumberOfColumns{LinesPerColumn doColumnZebra xiter 0 rmoveto}repeat
  grestore
}def

% stack:  lines-per-column |- --
/doColumnZebra{
  /lpc exch def
  gsave
  ZebraFollow 1 and 0 ne{
    /H ZebraHeight zebra-line ZebraHeight mod sub def
    /lpc lpc H sub def
    zebra-line double-zebra mod ZebraHeight lt
    {H doZebra	% "black" stripe followed by a "white" stripe
     /lpc lpc ZebraHeight sub def
     H ZebraHeight add}
    {H}ifelse	% "white" stripe
    LineHS mul neg 0 exch rmoveto
    /zebra-line zebra-line LinesPerColumn add def
  }if
  /zspacing 0 def
  lpc dup double-zebra idiv{ZebraHeight doZebra 0 yiter rmoveto}repeat
  double-zebra mod dup 0 le{pop}
  {dup ZebraHeight gt
   {pop ZebraHeight}
   {/zspacing LineSpacing def
    ZebraFollow 2 and 0 ne{pop ZebraHeight}if}ifelse
   doZebra}ifelse
  grestore
}def

% stack:  zebra-height (in lines) |- --
/doZebra{
  /zh exch 0.05 sub LineHS mul zspacing sub def
  gsave
  0 LineHeight 0.65 mul rmoveto
  PrintWidth 0 rlineto
  0 zh neg rlineto
  PrintWidth neg 0 rlineto
  0 zh rlineto
  fill
  grestore
}def

% stack: --
/printBackground{
  /BackgroundColor where{
    /LHg LineHeight 0.65 mul def
    /PHg PrintHeight LHg add def
    pop gsave BackgroundColor SetColor
    NumberOfColumns{
     gsave
     0 LHg rmoveto
     PrintWidth 0 rlineto
     0 PHg neg rlineto
     PrintWidth neg 0 rlineto
     0 PHg rlineto
     fill
     grestore
     PrintWidth InterColumn add 0 rmoveto
    }repeat
    grestore
  }if
}def

% tx ty rotation xscale yscale xpos ypos BeginBackImage
/BeginBackImage{
  /-save-image- save def
  /showpage{}def
  translate
  scale
  rotate
  translate
}def

/EndBackImage{-save-image- restore}def

% string fontsize fontname rotation gray xpos ypos ShowBackText
/ShowBackText{
  gsave
  translate
  setgray
  rotate
  findfont exch dup/-offset- exch -0.25 mul def scalefont setfont
  0 -offset- moveto
  /-saveLineThickness- LineThickness def
  /LineThickness 1 def
  false doOutline
  /LineThickness -saveLineThickness- def
  grestore
}def

/SetPageSize{
  BMark/PageSize[PageWidth LandscapePageHeight LandscapeMode{exch}if]EMark setpagedevice
}def

/BeginDoc{
  % ---- Remember space width of the normal text font `f0'.
  /SpaceWidth/f0 findfont setfont( )stringwidth pop def
  % ---- save the state of the document (useful for ghostscript!)
  /docState save def
  % ---- [andrewi] set PageSize based on chosen dimensions
  UseSetpagedevice{
   WarnPaperSize{SetPageSize}{mark{SetPageSize}stopped cleartomark}ifelse
  }if
  /ColumnWidth PrintWidth InterColumn add def
  % ---- define where  printing will start
  /f0 F					% this installs Ascent
  /PrintStartY PrintHeight Ascent sub def
  /ColumnIndex 1 def
  /N-Up-Counter N-Up-End 1 sub def
  /PLScounter PrintLineStart def
}def

/EndDoc{
  % ---- restore the state of the document (useful for ghostscript!)
  docState restore
}def

/BeginDSCPage{
  % ---- when 1st column, save the state of the page
  ColumnIndex 1 eq{/pageState save def}if
  % ---- save the state of the column
  /columnState save def
}def

/PrintHeaderWidth PrintOnlyOneHeader{PrintPageWidth}{PrintWidth}ifelse def

/BeginPage{
  /LinesPrinted exch def
  % ---- when 1st column, print all background effects
  ColumnIndex 1 eq{
    0 PrintStartY moveto		% move to where printing will start
    printBackground
    Zebra{printZebra}if
    printGlobalBackground
    printLocalBackground
  }if
  PrintOnlyOneHeader{ColumnIndex 1 eq}{true}ifelse
  dup PrintHeader and{
    PrintHeaderFrame{HeaderFrame}if
    HeaderText
  }if
  PrintFooter and{
    PrintFooterFrame{FooterFrame}if
    FooterText
  }if
  0 PrintStartY moveto			% move to where printing will start
  /LineNumber where
  {pop
   SyncLineZebra
   {/H PageNumber 1 sub NumberOfColumns mul ColumnIndex 1 sub add
       LinesPerColumn mul ZebraHeight mod def
    /PLScounter H PrintLineStart ge{0}{PrintLineStart H sub}ifelse def
    /PrintLineStep ZebraHeight H sub def}if}if
  PLN
}def

/EndPage{bg{eolbg}if}def

/EndDSCPage{
  ColumnIndex NumberOfColumns eq{
    % ---- restore the state of the page
    pageState restore
    /ColumnIndex 1 def
    % ---- N-up printing
    N-Up 1 gt{
      N-Up-Counter 0 gt
      {% ---- Next page on same row
	/N-Up-Counter N-Up-Counter 1 sub def
	N-Up-XColumn N-Up-YColumn}
      {% ---- Next page on next line
	/N-Up-Counter N-Up-End 1 sub def
	N-Up-XLine N-Up-YLine}ifelse
      translate
    }if
  }{ % else
    % ---- restore the state of the current column
    columnState restore
    % ---- and translate to the next column
    ColumnWidth 0 translate
    /ColumnIndex ColumnIndex 1 add def
  }ifelse
}def

/TextStart{
  LeftMargin BottomMargin
  PrintFooter{
    FooterPad add
    FooterLines FooterLineHeight mul add
    FooterPad add
    FooterOffset add}if
}def

% stack: number-of-pages-per-sheet |- --
/BeginSheet{
  /sheetState save def
  /pages-per-sheet exch def

  % ---- translate to bottom-right corner of Portrait page
  LandscapeMode{
    LandscapePageHeight 0 translate
    90 rotate
  }if
  % ---- [jack] Kludge: my ghostscript window is 21x27.7 instead of 21x29.7
  /JackGhostscript where{pop 1 27.7 29.7 div scale}if
  UpsideDown{PageWidth LandscapePageHeight translate 180 rotate}if
  % ---- N-Up printing
  N-Up 1 gt{
    % ---- landscape
    N-Up-Landscape{
      PageWidth 0 translate
      90 rotate
    }if
    N-Up-Margin dup translate
    % ---- scale
    LandscapeMode{
      /HH PageWidth def
      /WW LandscapePageHeight def
    }{
      /HH LandscapePageHeight def
      /WW PageWidth def
    }ifelse
    /xx 0 def
    N-Up-Landscape{
      /ww WW WW mul N-Up-Lines HH mul div def
      /cc HH N-Up-Columns N-Up-Missing add div def
      ww cc gt{/xx WW def/WW cc ww div WW mul def/xx xx WW sub def}if
    }{
      /hh HH N-Up-Columns N-Up-Missing add div def
      /cc HH N-Up-Lines div def
      hh cc gt{/xx WW def/WW cc hh div WW mul def/xx xx WW sub def}if
    }ifelse
    WW N-Up-Margin sub N-Up-Margin sub
    N-Up-Landscape
    {N-Up-Lines div HH}
    {N-Up-Columns N-Up-Missing add div WW}ifelse
    div dup scale
    LandscapeMode{/yy 0 def}{/yy xx def/xx 0 def}ifelse
    xx N-Up-Repeat 1 sub LandscapePageHeight mul yy add translate
    % ---- go to start position in page matrix
    N-Up-XStart N-Up-Missing 0.5 mul
    LandscapeMode
    {LandscapePageHeight mul N-Up-YStart add}
    {PageWidth mul add N-Up-YStart}ifelse
    translate
  }if
  % ---- translate to lower left corner of TEXT
  TextStart translate

  % ---- N-up printing
  N-Up 1 gt N-Up-Border and pages-per-sheet 0 gt and{
    % ---- page border
    gsave
    0 setgray
    TextStart exch neg exch neg moveto
    N-Up-Repeat
    {N-Up-End
     {gsave
      PageWidth 0 rlineto
      0 LandscapePageHeight rlineto
      PageWidth neg 0 rlineto
      closepath stroke
      grestore
      /pages-per-sheet pages-per-sheet 1 sub def
      pages-per-sheet 0 le{exit}if
      N-Up-XColumn N-Up-YColumn rmoveto
     }repeat
     pages-per-sheet 0 le{exit}if
     N-Up-XLine N-Up-XColumn sub N-Up-YLine rmoveto
    }repeat
    grestore
  }if
}def

/EndSheet{
  showpage
  sheetState restore
}def

/SetHeaderLines{			% nb-lines --
  /HeaderLines exch def
  % ---- bottom up
  HeaderPad
  HeaderLines 1 sub HeaderLineHeight mul add
  HeaderTitleLineHeight add
  HeaderPad add
  /HeaderHeight exch def
}def

/SetFooterLines{			% nb-lines --
  /FooterLines exch def
  % ---- bottom up
  FooterPad
  FooterLines FooterLineHeight mul add
  FooterPad add
  /FooterHeight exch def
}def

% |---------|
% |  tm     |
% |---------|
% |  header |
% |-+-------| <-- (x y)
% |  ho     |
% |---------|
% |  text   |
% |---------|
% |  fo     |
% |---------|
% |  footer |
% |-+-------| <-- (0 0)
% |  bm     |
% |---------|

% -- |- x y
/HeaderFrameStart{0  PrintHeight HeaderOffset add}def
/FooterFrameStart{0  FooterHeight FooterOffset add neg}def

/doFramePath{
  /h exch def
  PrintHeaderWidth	0	rlineto
  0			h	rlineto
  PrintHeaderWidth neg	0	rlineto
  0			h neg	rlineto
}def

/HeaderFramePath{HeaderHeight doFramePath}def
/FooterFramePath{FooterHeight doFramePath}def

% /path-fun /start-fun vector-property doFrame
/doFrame{
  /vecFrame exch def
  /startFrame exch load def
  /pathFrame exch load def
  gsave
    vecFrame 2 get setlinewidth				% frame border width
    % ---- do the shadow of the next rectangle
    startFrame moveto
    1 -1 rmoveto
    pathFrame
    vecFrame 4 get SetColor fill			% frame shadow color
    % ---- do the next rectangle ...
    startFrame moveto
    pathFrame
    gsave vecFrame 1 get SetColor fill grestore		% frame background
    gsave vecFrame 3 get SetColor stroke grestore	% frame border color
  grestore
}def

/HeaderFrame{/HeaderFramePath /HeaderFrameStart HeaderFrameProperties doFrame}def
/FooterFrame{/FooterFramePath /FooterFrameStart FooterFrameProperties doFrame}def

/HeaderStart{
  HeaderFrameStart
  exch HeaderPad add exch	% horizontal pad
  % ---- bottom up
  HeaderPad add			% vertical   pad
  HeaderDescent sub
  HeaderLineHeight HeaderLines 1 sub mul add
}def

/FooterStart{
  FooterFrameStart
  exch FooterPad add exch	% horizontal pad
  % ---- bottom up
  FooterPad add			% vertical   pad
  FooterDescent sub
  FooterLineHeight FooterLines 1 sub mul add
}def

/HeaderClip{HeaderFrameStart moveto HeaderFramePath clip}def
/FooterClip{FooterFrameStart moveto FooterFramePath clip}def

/strcat{
  dup length 3 -1 roll dup length dup 4 -1 roll add string dup
  0 5 -1 roll putinterval
  dup 4 2 roll exch putinterval
}def

/pagenumberstring{
  PageNumber 32 string cvs
  ShowNofN{(/)strcat PageCount 32 string cvs strcat}if
}def

% lines is-right HeaderOrFooterTextLines
/HeaderOrFooterTextLines{
  /is_right exch def
  HFStart moveto
  { % ---- process the lines
   aload pop
   exch F
   gsave
    dup xcheck{exec}if
    is_right{
     dup stringwidth pop
     PrintHeaderWidth exch sub HFPad HFPad add sub 0 rmoveto
    }if
    HFColor SetColor
    show
   grestore
   0 HFLineHeight neg rmoveto
  }forall
}def

% right-lines left-lines /start lineheight pad fore-color HeaderOrFooterText
/HeaderOrFooterText{
  /HFColor exch def
  /HFPad exch def
  /HFLineHeight exch def
  /HFStart exch load def

  % -- rightLines leftLines -- at stack

  % ---- hack: `PN 1 and'  ==  `PN 2 modulo'
  % ---- if even page number and duplex, then exchange left and right
  PageNumber 1 and 0 eq SwitchHeader and{exch}if

  % ---- process the left lines
  false HeaderOrFooterTextLines

  % ---- process the right lines
  true HeaderOrFooterTextLines
}def

/HeaderText{
  gsave HeaderClip
  HeaderLinesRight HeaderLinesLeft
  /HeaderStart HeaderLineHeight HeaderPad
  HeaderFrameProperties 0 get
  HeaderOrFooterText
  grestore
}def

/FooterText{
  gsave FooterClip
  FooterLinesRight FooterLinesLeft
  /FooterStart FooterLineHeight FooterPad
  FooterFrameProperties 0 get
  HeaderOrFooterText
  grestore
}def

/ReportFontInfo{
  2 copy
  /t0 3 1 roll DefFont
  /t0 F
  /lh FontHeight def
  /sw( )stringwidth pop def
  /aw(01234567890abcdefghijklmnopqrstuvwxyz)dup length exch
  stringwidth pop exch div def
  /t1 12/Helvetica-Oblique DefFont
  /t1 F
  gsave
    (languagelevel = )show
    languagelevel 32 string cvs show
  grestore
  0 FontHeight neg rmoveto
  gsave
    (For )show
    128 string cvs show
    ( )show
    32 string cvs show
    ( point, the line height is )show
    lh 32 string cvs show
    (, the space width is )show
    sw 32 string cvs show
    (,)show
  grestore
  0 FontHeight neg rmoveto
  gsave
    (and a crude estimate of average character width is )show
    aw 32 string cvs show
    (.)show
  grestore
  0 FontHeight neg rmoveto
}def

% cm to point
/cm{72 mul 2.54 div}def

/ReportAllFontInfo{
  % key = font name   value = font dictionary
  FontDirectory{pop 10 exch ReportFontInfo}forall
}def

% 3 cm 20 cm moveto  10/Courier ReportFontInfo  showpage
% 3 cm 20 cm moveto  ReportAllFontInfo          showpage

% === END ps-print prologue 1

/printGlobalBackground{
}def
/printLocalBackground{
}def

%%EndProlog

%%BeginSetup

%%IncludeResource: font Times-Roman
%%IncludeResource: font Times-Italic
%%IncludeResource: font Courier
%%IncludeResource: font Courier-Bold
%%IncludeResource: font Courier-Oblique
%%IncludeResource: font Courier-BoldOblique
%%IncludeResource: font Helvetica
%%IncludeResource: font Helvetica-Bold
/h0 14(Helvetica-Bold)cvn DefFont
/h1 12(Helvetica)cvn DefFont
/L0 6(Times-Italic)cvn DefFont
/H0 12(Helvetica)cvn DefFont


% ---- These lines must be kept together because...

/h0 F
/HeaderTitleLineHeight FontHeight def

/h1 F
/HeaderLineHeight FontHeight def
/HeaderDescent    Descent def

/H0 F
/FooterLineHeight FontHeight def
/FooterDescent    Descent def

% ---- ...because `F' has a side-effect on `FontHeight' and `Descent'

/f0 8.5(Courier)cvn DefFont
/f1 8.5(Courier-Bold)cvn DefFont
/f2 8.5(Courier-Oblique)cvn DefFont
/f3 8.5(Courier-BoldOblique)cvn DefFont
/SpaceWidthRatio 0.600000 def

%%BeginFeature: *ManualFeed False
BMark /ManualFeed false EMark setpagedevice
%%EndFeature

%%%% Start of Mule Section

/Latin1Encoding {	% newname fontname  |  font
    findfont dup length dict begin
	{ 1 index /FID ne { def } { pop pop } ifelse } forall
        /Encoding ISOLatin1Encoding def
	currentdict
    end
    definefont
} bind def

%% Redefine fonts for multiple charsets.
/ReDefFont {		     % fontname encoding fdepvector size  |  -
  20 dict begin
  3 index findfont {
    1 index /FID ne 2 index /UniqueID ne and {def} {pop pop} ifelse
  } forall
  /FontType 0 def
  /FMapType 3 def
  /EscChar 0 def
  % FontMatrix ::= [ size 0 0 size 0 0 ]
  /FontMatrix exch [ exch dup 0 exch 0 exch 0 0 ] def
  /FDepVector exch def
  /Encoding exch def
  currentdict
  end			% fontname dic
  definefont pop
} bind def

/EscChar 0 def

%% End of Mule Section

/F00 /Courier findfont def
/ETOP0 256 array def
0 1 255 { ETOP0 exch 0 put } for
ETOP0 0 0 put
/VTOP0 [F00] def
/ETOP1 256 array def
0 1 255 { ETOP1 exch 0 put } for
ETOP1 0 0 put
/VTOP1 [F00] def
/ETOP2 256 array def
0 1 255 { ETOP2 exch 0 put } for
ETOP2 0 0 put
/VTOP2 [F00] def
/ETOP3 256 array def
0 1 255 { ETOP3 exch 0 put } for
ETOP3 0 0 put
/VTOP3 [F00] def
/Vh0 [ VTOP1 aload pop ] def

Vh0 0 /Helvetica-Bold-latin1 /Helvetica-Bold Latin1Encoding put
/h0 ETOP1 Vh0 14.000000 ReDefFont
/Vh1 [ VTOP0 aload pop ] def

Vh1 0 /Helvetica-latin1 /Helvetica Latin1Encoding put
/h1 ETOP0 Vh1 12.000000 ReDefFont
/VH0 [ VTOP0 aload pop ] def

VH0 0 /Helvetica-latin1 /Helvetica Latin1Encoding put
/H0 ETOP0 VH0 12.000000 ReDefFont
/Vf0 [ VTOP0 aload pop ] def

Vf0 0 /Courier-latin1 /Courier Latin1Encoding put
/f0 ETOP0 Vf0 8.500000 ReDefFont
/Vf1 [ VTOP1 aload pop ] def

Vf1 0 /Courier-Bold-latin1 /Courier-Bold Latin1Encoding put
/f1 ETOP1 Vf1 8.500000 ReDefFont
/Vf2 [ VTOP2 aload pop ] def

Vf2 0 /Courier-Oblique-latin1 /Courier-Oblique Latin1Encoding put
/f2 ETOP2 Vf2 8.500000 ReDefFont
/Vf3 [ VTOP3 aload pop ] def

Vf3 0 /Courier-BoldOblique-latin1 /Courier-BoldOblique Latin1Encoding put
/f3 ETOP3 Vf3 8.500000 ReDefFont
BeginDoc
%%EndSetup

%%Page: 1 1
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 1 def
/PageNumber 1 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
0 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
0 EF
(/*) S
LHL
(Use 20 RPC and also two sets of dummy RPC on top and bottom to have easier ) S
LHL
(option of extrapolation.) S
PHL
LHL
(phi/momentum resolution is better for upgoing muon) S
LHL
(There is muon in oppsite direction for downgoing muon) S
LHL
(Shift in theta in opposite direction, most likely due to first iron layer) S
PHL
LHL
(Straight\(\)) S
LHL
(Exact matching of positions) S
LHL
(Extrapolation, how much ?) S
PHL
LHL
(Glo Position -5.94995 -10753.9 -1806.62 glb \(8.65128,-10750.6,-1806.62\)) S
LHL
(Glo Position    24.05 -10753.9 -1907.62 glb \(9.30191,-10752.7,-1907.62\)    : 24.05 ??????) S
LHL
(Glo Position -5.94995 -10753.9 -2008.62 glb \(8.81592,-10753.9,-2008.62\)) S
LHL
(Glo Position -5.94995 -10753.9 -2109.62 glb \(5.67749,-10753.8,-2109.62\)) S
LHL
(Glo Position -5.94995 -10753.9 -2210.62 glb \(2.4078,-10753.2,-2210.62\)) S
LHL
(Glo Position -5.94995 -10753.9 -2311.62 glb \(-1.45657,-10751.1,-2311.62\)) S
LHL
(Glo Position -5.94995 -10753.9 -2412.62 glb \(-2.25651,-10752.5,-2412.62\)) S
LHL
(Glo Position -5.94995 -10753.9 -2513.62 glb \(-3.02203,-10755.8,-2513.62\)) S
LHL
(Glo Position -5.94995 -10753.9 -2614.62 glb \(-5.49412,-10760.2,-2614.62\)) S
LHL
(Glo Position -5.94995 -10753.9 -2715.62 glb \(-8.77315,-10764.7,-2715.62\)) S
PHL
PHL
LHL
(pAnalysis;0 0  x -0.00594995 y -10.7689 zposs -2.69562) S
LHL
(pAnalysis;1 0  x -0.00594995 y -10.754 zposs -2.59462) S
LHL
(pAnalysis;2 0  x -0.00594995 y -10.754 zposs -2.49362) S
LHL
(pAnalysis;3 0  x -0.00594995 y -10.754 zposs -2.39262) S
LHL
(pAnalysis;4 0  x -0.00594995 y -10.754 zposs -2.29162) S
LHL
(pAnalysis;5 0  x -0.00594995 y -10.754 zposs -2.19062) S
LHL
(pAnalysis;6 0  x -0.00594995 y -10.754 zposs -2.08962) S
LHL
(pAnalysis;7 0  x 0.00905005 y -10.754 zposs -1.98862) S
LHL
(pAnalysis;8 0  x 0.00905005 y -10.754 zposs -1.88762) S
LHL
(pAnalysis;9 0  x 0.00905005 y -10.754 zposs -1.78662) S
PHL
PHL
LHL
( */) S
PHL
LHL
(#include <cmath>) S
LHL
(#include "TMath.h") S
LHL
(#include <cassert>) S
LHL
(#include "TSpline.h") S
LHL
(#include "TVector3.h") S
LHL
(#include <sys/time.h>) S
LHL
(#include "vect_manager.h") S
LHL
(#include "SwimParticle.h") S
LHL
(#include "InoTrackFitAlg.h") S
LHL
(// #include "G4SystemOfUnits.hh") S
LHL
(//#include "MultiSimAnalysis.hh") S
PHL
LHL
(//#include "G4Material.hh") S
LHL
(//#include "G4ParticleDefinition.hh") S
LHL
(//#include "G4MuonPlus.hh") S
LHL
(//#include "G4MuonMinus.hh") S
LHL
(//#include "G4VEmFluctuationModel.hh") S
LHL
(//#include "G4EnergyLossForExtrapolator.hh") S
PHL
LHL
(#include <string>) S
LHL
(#include <math.h>) S
LHL
(#include <vector>) S
LHL
(using std::vector;) S
LHL
(#include <fstream>) S
LHL
(#include <cstdlib>) S
LHL
(#include "InoTrack.h") S
LHL
(#include <TRandom3.h>) S
LHL
(#include "InoCluster.h") S
LHL
(#include "SwimSwimmer.h") S
LHL
(#include <Math/ProbFunc.h>) S
LHL
(//#include "Interpolator.h") S
LHL
(#include "InoTrackSegment.h") S
LHL
(//#include "Math/Interpolator.h") S
LHL
(#define MINLAYER 3) S
PHL
LHL
(InoTrackFitAlg::InoTrackFitAlg\(\) {) S
LHL
10 W
(cout<<" InoTrackFitAlg::InoTrackFitAlg\(\) " <<endl;) S
LHL
(  pAnalysis) S
5 W
(= MultiSimAnalysis::AnPointer;) S
LHL
(  pFieldMap) S
5 W
(= micalFieldPropagator::FdPointer;//GM) S
PHL
(  ) S
EndPage
EndDSCPage
EndSheet

%%Page: 2 2
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 79 def
/PageNumber 2 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
78 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  icalGeometry= \(InoGeometry_Manager::APointer\)->icalGeometry;) S
LHL
(  localmat) S
6 W
(= new TGeoMaterial\("Fe",55.845,26,7.874\);) S
PHL
(  ) S
LHL
(  //g4Edisp) S
13 W
(= new G4EnergyLossForExtrapolator\(1\);) S
LHL
(  PoissonRn) S
5 W
(= new TRandom3\(0\);) S
LHL
(  IcalRange) S
5 W
(= new InoMuRange\(\);) S
PHL
(  ) S
LHL
(  debug_fit = false; //true;) S
LHL
(  inoTrackCand_pointer = new InoTrackCand_Manager\(\);) S
PHL
(  ) S
LHL
(  micalDetectorParameterDef* paradef = micalDetectorParameterDef::AnPointer;) S
LHL
(  StripXWidth = \(1/m\)*paradef->GetXStrwd\(\);) S
LHL
(  StripYWidth = \(1/m\)*paradef->GetYStrwd\(\);) S
LHL
(  nLayer      = paradef->GetnLayer\(\);) S
LHL
8 W
(//  cout<<"nLayer"<<nLayer<<endl;) S
LHL
(  LayerThickness = \(1/m\)*2*\(paradef->GetParlay\(2\)+paradef->GetParirlay\(2\)\);) S
LHL
8 W
(//  cout<<"LayerThickness"<<LayerThickness<<endl;) S
LHL
(  ShiftInX = \(1/m\)*paradef->GetShiftInX\(\);) S
LHL
(  ShiftInY = \(1/m\)*paradef->GetShiftInY\(\);) S
LHL
(  ShiftInZ =paradef->GetShiftInZ\(0\);) S
LHL
(  // cout<<"ShiftinXYZ  "<<ShiftInX<<"  " <<ShiftInY<<"  "<<ShiftInZ<<endl;) S
LHL
(  for \(int ij=0; ij<3; ij++\) { ) S
LHL
(    pargasxyz[ij] = \(1/cm\)*paradef->GetPargas\(ij\);) S
PHL
(    ) S
LHL
(  }) S
LHL
8 W
(//  cout<<doubleLa<<endl;) S
LHL
(  for \(unsigned ijk=0; ijk<doubleLa; ijk++\) {) S
LHL
(    //  ZPosLayer[ijk] = \(1/m\)*\(-paradef->GetParino\(2\) + 2*\(paradef->GetParhcoil\(2\)+paradef->G) S
SL
(etParcoilsupport\(2\)\) + 2*\(ijk+1\)*paradef->GetParirlay\(2\) + \(2*ijk+1\)*\(paradef->GetParlay\(2\)\)\) ) S
SL
(+ ShiftInZ;) S
PHL
(    ) S
LHL
(    ZPosLayer[ijk] = \(1/m\)*\(paradef->GetRPCLayerPosZ\(ijk\)+ShiftInZ+paradef->GetINOroomPos\(2\)+ ) S
SL
(paradef->GetStackPosInRoom\(2\)\);) S
PHL
(    ) S
LHL
16 W
(//    cout<< "ZPosLayer "<< ijk <<" "<<1000* ZPosLayer[ijk]<<endl;) S
LHL
(  }) S
LHL
(  //) S
4 W
PHL
(  ) S
LHL
(  IcalX = \(1/m\)*\( \(3\)*\(paradef->GetParino\(0\)\) + 200\); ) S
LHL
(  IcalY = \(1/m\)*paradef->GetParino\(1\);) S
PHL
(  ) S
LHL
(  CorrTimeError = pAnalysis->GetCorrTimeError\(\);) S
LHL
(  UnCorrTimeError = pAnalysis->GetUnCorrTimeError\(\);) S
LHL
(  TimeError = pow\(\(pow\(CorrTimeError,2.\) + pow\(UnCorrTimeError,2.\)\),0.5\);) S
PHL
LHL
(  // cout<<"CorrTimeError = "<<CorrTimeError<<endl;) S
LHL
(  // cout<<"UnCorrTimeError = "<<UnCorrTimeError<<endl;) S
LHL
(  // cout<<"TimeError = "<<TimeError<<endl;) S
PHL
LHL
(  UseGeoSwimmer = 0;) S
LHL
(  if\(pAnalysis->isXtermOut==1\) {) S
LHL
(    cout <<"\\n InoTrackFitAlg::InoTrackFitAlg\(\) "<<StripXWidth<<" "<<StripYWidth<<" "<<LayerTh) S
SL
(ickness<<endl;) S
LHL
(  }) S
PHL
(  ) S
LHL
(  inoHit_pointer = InoHit_Manager::APointer;) S
LHL
(  InoCluster_pointer = InoCluster_Manager::APointer;) S
LHL
(}) S
PHL
LHL
(InoTrackFitAlg::~InoTrackFitAlg\(\) {) S
LHL
(  //GMA need to clear after evergy events;) S
LHL
(  for \(unsigned int ij=0; ij< inoTrackCand_pointer->InoTrackCand_list.size\(\); ij++\) {) S
LHL
(    if \(inoTrackCand_pointer->InoTrackCand_list[ij]\) {) S
LHL
(      delete inoTrackCand_pointer->InoTrackCand_list[ij];) S
LHL
(      inoTrackCand_pointer->InoTrackCand_list[ij]=0;) S
LHL
(    }) S
LHL
(  }) S
LHL
(  inoTrackCand_pointer->InoTrackCand_list.clear\(\);) S
LHL
(  if \(inoTrackCand_pointer\) {) S
LHL
(    delete inoTrackCand_pointer;) S
LHL
(    inoTrackCand_pointer=0;) S
LHL
(  }) S
LHL
(  delete PoissonRn;) S
LHL
(  delete IcalRange;) S
LHL
(}) S
LHL
(void InoTrackFitAlg::RunAlg\( \) { // \(AlgConfig & ac,  CandHandle &ch, CandContext &cx\)) S
LHL
11 W
(cout<<"InoTrackFitAlg::RunAlg\( \){..."<<endl;) S
LHL
(  InoTrack_Manager *ptrackCollection = InoTrack_Manager::APointer;) S
EndPage
EndDSCPage
EndSheet

%%Page: 3 3
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 153 def
/PageNumber 3 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
156 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  //if\(debug_fit\)cout <<"----------------------InoTrackFitAlg::RunAlg\( \) "<<ptrackCollection->) S
SL
(InoTrack_list.size\(\)<<"----------------------"<<endl;) S
LHL
( LOOP:) S
PHL
(  ) S
LHL
(  inoTrackCand_pointer->InoTrackCand_list.clear\(\);) S
PHL
(  ) S
LHL
(  double MinFiltData[100][6];double MaxFiltData[100][6]; //GMA14) S
LHL
(  int Ndt = ptrackCollection->InoTrack_list.size\(\);) S
LHL
(  if \(Ndt>100\) Ndt=100;) S
PHL
(  ) S
LHL
(  if \(ptrackCollection\)) S
1 W
({) S
LHL
(    for \(unsigned int itrk=0; itrk<ptrackCollection->InoTrack_list.size\(\); itrk++\) {) S
LHL
(      // Initialisations) S
LHL
(      for \(int ij=1; ij<2; ij++\) {) S
LHL
(        fFinderTrack = ptrackCollection->InoTrack_list[itrk];) S
LHL
(        pAnalysis->nhits_finder[itrk]=fFinderTrack->ClustsInTrack.size\(\);) S
15 W
(//asm ) S
PHL
(        ) S
LHL
(        double FinderPathLength = 0.0;) S
LHL
(        double FinderDistance= 0.0;) S
PHL
(        ) S
LHL
(        fMT = false;) S
PHL
(        ) S
LHL
(        ZIncreasesWithTime = DirectionFromFinderHits\(ptrackCollection->InoTrack_list[itrk], Fi) S
SL
(nderPathLength, FinderDistance\);) S
PHL
(        ) S
LHL
(        cout<<"ZIncreasesWithTime "<<ZIncreasesWithTime<<endl;) S
LHL
(        // ZIncreasesWithTime= DirectionFromFinderHitsOldFunc\(ptrackCollection->InoTrack_list[) S
SL
(itrk], FinderPathLength, FinderDistance\);) S
LHL
32 W
(cout<<"Track No. = "<<itrk<<endl;) S
PHL
(        ) S
LHL
(        int nhits1 = ptrackCollection->InoTrack_list[itrk]->GetEntries\(\);) S
LHL
32 W
(for\(int ixj = 0; ixj < nhits1; ixj++\) {) S
LHL
40 W
(cout<<"Xpos "<<ptrackCollection->InoTrack_list[itrk]->) S
SL
(ClustsInTrack[ixj]->GetXPos\(\)<<", YPos "<<ptrackCollection->InoTrack_list[itrk]->ClustsInTrack) S
SL
([ixj]->GetYPos\(\)<<", ZPos = "<<ptrackCollection->InoTrack_list[itrk]->ClustsInTrack[ixj]->GetZ) S
SL
(Pos\(\)<<", ZLay = "<<ptrackCollection->InoTrack_list[itrk]->ClustsInTrack[ixj]->GetZPlane\(\)<<en) S
SL
(dl;) S
LHL
(          // ", Time = "<<ptrackCollection->InoTrack_list[itrk]->ClustsInTrack[ixj]->GetTime\(\)) S
SL
(<<" "<<ptrackCollection->InoTrack_list[itrk]->ClustsInTrack[ixj]->GetBegTime\(\)<<" "<<ptrackCol) S
SL
(lection->InoTrack_list[itrk]->ClustsInTrack[ixj]->GetEndTime\(\)<<" "<<ptrackCollection->InoTrac) S
SL
(k_list[itrk]->ClustsInTrack[ixj]->GetHitEntries\(\)<<endl;) S
LHL
32 W
(}) S
PHL
(        ) S
LHL
(        // if\(!ZIncreasesWithTime\) {) S
LHL
(        //   pAnalysis->timeAsciiOutput<<"TrackNo. = "<<itrk<<endl;) S
LHL
(        //   int nhits1 = ptrackCollection->InoTrack_list[itrk]->GetEntries\(\);) S
LHL
(        //   for\(int ixj = 0; ixj < nhits1; ixj++\) {) S
LHL
(        //     pAnalysis->timeAsciiOutput<<"ZPos = "<<ptrackCollection->InoTrack_list[itrk]->C) S
SL
(lustsInTrack[ixj]->GetZPos\(\)<<", ZLay = "<<ptrackCollection->InoTrack_list[itrk]->ClustsInTrac) S
SL
(k[ixj]->GetZPlane\(\)<<", Time = "<<ptrackCollection->InoTrack_list[itrk]->ClustsInTrack[ixj]->G) S
SL
(etTime\(\)<<endl;) S
LHL
(        //   }) S
LHL
(        // }) S
PHL
(        ) S
PHL
(        ) S
LHL
(        InoTrack *trk = ptrackCollection->InoTrack_list[itrk];) S
LHL
(        int nhits) S
7 W
(= trk->GetEntries\(\);) S
LHL
32 W
(//        double VtxX) S
3 W
(= trk->ClustsInTrack[0]->GetXPos\(\);) S
LHL
32 W
(//        double VtxY) S
3 W
(= trk->ClustsInTrack[0]->GetYPos\(\);) S
LHL
32 W
(//        double EndX) S
3 W
(= trk->ClustsInTrack[nhits-1]->GetXPos) S
SL
(\(\);) S
LHL
32 W
(//        double EndY) S
3 W
(= trk->ClustsInTrack[nhits-1]->GetYPos) S
SL
(\(\);) S
PHL
(        ) S
LHL
(        //) S
6 W
(if \(fabs\(fmod\(VtxX,2.0\)\)<0.1 || fabs\(fmod\(VtxX,2.0\)\)>1.9 || fabs\(fmod\(VtxY,2.0) S
SL
(\)\)<0.1 || fabs\(fmod\(VtxY,2.0\)\)>1.9\) {fMT = true;}) S
LHL
(        // || fabs\(fmod\(EndX,2.0\)\)<0.12 || fabs\(fmod\(EndX,2.0\)\)>1.88 || fabs\(fmod\(EndY,2.0\)\)<0) S
SL
(.12 || fabs\(fmod\(EndY,2.0\)\)>1.88) S
PHL
(        ) S
LHL
(        //if \(fabs\(VtxY\)<6.0 && \(\(FinderPathLength-FinderDistance\)/FinderPathLength\)<0.01\)) S
4 W
SL
34 W
(// Very small curvature at higher B => larger momenta) S
LHL
(        fMT = true;) S
PHL
(        ) S
LHL
(        if \(ZIncreasesWithTime\) {) S
LHL
(          if \(MinPlane>100 && \(\(FinderPathLength-FinderDistance\)/FinderPathLength\)<0.01 && nhi) S
SL
(ts<30\) fMT = true;) S
LHL
(        } else {) S
LHL
(          if \(MaxPlane <50 && \(\(FinderPathLength-FinderDistance\)/FinderPathLength\)<0.01 && nhi) S
EndPage
EndDSCPage
EndSheet

%%Page: 4 4
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 211 def
/PageNumber 4 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
234 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(ts<30\) fMT = true;) S
LHL
(        }) S
PHL
(        ) S
LHL
(        fTrackCand = new InoTrackCand\(ptrackCollection->InoTrack_list[itrk], ZIncreasesWithTim) S
SL
(e\); //VALGRIND) S
PHL
(        ) S
LHL
(        if\(debug_fit\) {cout <<"trksize "<<ij << " "<<ptrackCollection->InoTrack_list[itrk]->Ge) S
SL
(tEntries\(\)<<" "<<fTrackCand->GetClusterEntries\(\)<<endl;}) S
PHL
(        ) S
LHL
(        fTrackCand->SetFitType\(\(ZIncreasesWithTime\) ? 1 : 0\);) S
PHL
(        ) S
LHL
(        SaveData=false;) S
LHL
(        SwimThroughShower=false;) S
LHL
(        PassTrack=true;) S
PHL
(        ) S
LHL
(        MaxPlane=) S
7 W
(-20;) S
LHL
(        MinPlane=) S
7 W
(nLayer;) S
LHL
(        OtLStrip=) S
7 W
(0;) S
LHL
(        //?????????????????????? Are these variables doing anything? We can remove them if nec) S
SL
(essary) S
LHL
(        DeltaZ=-99;) S
LHL
(        DeltaPlane=-99;) S
LHL
(        ShowerEntryPlane=-99;) S
PHL
(        ) S
LHL
(        NIter=0;TotalNSwimFail=0; NumFinderStrips=0;) S
LHL
(        x_k[5]=0;) S
LHL
(        x_k_minus[5]=0;) S
LHL
(        //?????????????????????? Are these variables doing anything? We can remove them if nec) S
SL
(essary) S
PHL
(        ) S
LHL
(        for \(unsigned int jk=0; jk<5; ++jk\) {) S
LHL
(          x_k[jk]=0;) S
LHL
(          x_k_minus[jk]=0;) S
LHL
(          EndState[jk]) S
2 W
(=0;) S
LHL
(          prevstate[jk]=0;) S
LHL
(          prevpredn[jk]=0;) S
LHL
(          H_k[0][jk]=0;) S
LHL
(          H_k[1][jk]=0;) S
LHL
(          K_k[jk][0]=0;) S
LHL
(          K_k[jk][1]=0;) S
PHL
(          ) S
LHL
(          VtxCov[jk]=-999; EndCov[jk]=-999;) S
LHL
(          for \(unsigned int kl=0; kl<5; ++kl\) {) S
LHL
(            C_k[jk][kl]=0;) S
LHL
(            C_k_minus[jk][kl]=0;) S
LHL
(            C_k_intermediate[jk][kl]=0;) S
LHL
(            F_k[jk][kl]=0;) S
LHL
(            F_k_minus[jk][kl]=0;) S
LHL
(            Q_k[jk][kl]=0;) S
LHL
(            Q_k_minus[jk][kl]=0;) S
LHL
(            Identity[jk][kl]=0;) S
LHL
(          }) S
LHL
(        }) S
LHL
(        Identity[0][0]=1; Identity[1][1]=1; Identity[2][2]=1; Identity[3][3]=1; Identity[4][4]) S
SL
(=1;) S
PHL
(        ) S
LHL
(        // Set initial parameters) S
LHL
(        //------------------------------------------------------) S
LHL
(        x_k_minus[0]=fTrackCand->GetVtxU\(\);) S
5 W
(//) S
38 W
(cout<<) S
SL
("Used X "<<x_k_minus[0]<<endl;) S
LHL
(        x_k_minus[1]=fTrackCand->GetVtxV\(\);) S
LHL
32 W
(cout<<"Starting X Y "<< x_k_minus[0]<<" "<<x_k_minus[1]<<" "<<) S
SL
(MinPlane<<" "<<MaxPlane<<endl;) S
PHL
(        ) S
LHL
(        if\(fTrackCand->GetVtxDirCosZ\(\)!=0.\) {) S
LHL
(          x_k_minus[2]=fTrackCand->GetVtxDirCosU\(\)/fTrackCand->GetVtxDirCosZ\(\);//cout<<"Used t) S
SL
(x "<<x_k_minus[2]<<endl;) S
LHL
(          x_k_minus[3]=fTrackCand->GetVtxDirCosV\(\)/fTrackCand->GetVtxDirCosZ\(\);//cout<<"Used t) S
SL
(y "<<x_k_minus[3]<<endl;) S
LHL
(        } else {) S
LHL
(          x_k_minus[2]=fTrackCand->GetVtxDirCosU\(\); //This scenario will not appear, but keep ) S
SL
(it for unforseen case) S
LHL
(          x_k_minus[3]=fTrackCand->GetVtxDirCosV\(\); ) S
LHL
(        }) S
PHL
(        ) S
LHL
(        x_k_minus[4]=0.0;) S
PHL
(        ) S
LHL
(        StateIter[0]=0.0;) S
EndPage
EndDSCPage
EndSheet

%%Page: 5 5
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 279 def
/PageNumber 5 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
312 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(        StateIter[1]=0.0;) S
LHL
(        StateIter[2]=0.0;) S
LHL
(        StateIter[3]=0.0;) S
LHL
(        StateIter[4]=0.0;) S
PHL
(        ) S
LHL
(        //x_k_minus[5]=0.0;) S
LHL
(        //x_k4_biased=0;) S
PHL
(        ) S
LHL
(        xxin = x_k_minus[0];) S
LHL
(        yyin = x_k_minus[1];) S
4 W
LHL
(        txin = x_k_minus[2];) S
4 W
LHL
(        tyin = x_k_minus[3];) S
PHL
(        ) S
LHL
(        B_in = 0.0000000000;) S
LHL
(        ds) S
22 W
(= 0.0;) S
LHL
(        ChiSquare) S
7 W
(= 0.0;) S
LHL
(        GPL) S
21 W
(= 0.0;) S
LHL
(        RNG) S
21 W
(= 0.0;) S
LHL
(        I) S
23 W
(= 0.0;) S
LHL
(        BetheBloch) S
6 W
(= 0.0;) S
LHL
(        MagicRatio) S
6 W
(= 0.0;) S
LHL
(        nHit) S
12 W
(= ptrackCollection->InoTrack_list[itrk]->GetEntries\(\);) S
PHL
(        ) S
LHL
(        // Run the high level methods) S
LHL
(        InitialFramework\(\);) S
PHL
(        ) S
LHL
(        RunTheFitter\(\);) S
PHL
(        ) S
LHL
(        bool check1;bool check2;) S
LHL
(        for \(int jk = 0; jk<6; jk++\) {) S
LHL
(          check1 = std::isnan\(MinPlaneData[jk]\);) S
LHL
(          check2 = std::isnan\(MinPlaneData[jk]\);) S
LHL
(          if \(check1 == true || check2 == true\)) S
LHL
(            PassTrack=false;) S
LHL
(          if \(PassTrack == false\)) S
LHL
(            break;) S
LHL
(          MinFiltData[itrk][jk] = MinPlaneData[jk];) S
LHL
(          MaxFiltData[itrk][jk] = MaxPlaneData[jk];) S
LHL
(        }) S
PHL
32 W
LHL
(        // for \(unsigned int jk=0; jk<nLayer; ++jk\)) S
5 W
({) S
LHL
(        //   for \(unsigned int kl=0; kl<FilteredData[jk].size\(\); kl++\) {) S
LHL
(        //     cout <<"FilteredData[jk].size\(\) "<<jk<<" "<<kl<<" "<<FilteredData[jk].size\(\)<<e) S
SL
(ndl;) S
LHL
(        //     cout<<"FilteredData "<<FilteredData[jk][0].x_k0<<" "<<FilteredData[jk][0].x_k1<) S
SL
(<" "<<FilteredData[jk][0].x_k2<<" "<<FilteredData[jk][0].x_k3<<endl;) S
LHL
(        //   }) S
LHL
(        // }) S
PHL
(        ) S
PHL
(        ) S
LHL
(        if \(pAnalysis->ihist < pAnalysis->nhistmx-1 && ij==1 && pAnalysis->isVisOut>=2\) {) S
LHL
(          for \(unsigned int jk=0; jk<nLayer; ++jk\)) S
6 W
({) S
LHL
(            for \(unsigned int kl=0; kl<FilteredData[jk].size\(\); kl++\) {) S
LHL
(              // cout <<"FilteredData[jk].size\(\) "<<jk<<" "<<kl<<" "<<FilteredData[jk].size\(\)<) S
SL
(<endl;) S
LHL
(              if \(InitTrkClustData[jk].size\(\)>0\)) S
8 W
({) S
LHL
(                pAnalysis->gens_list[5][pAnalysis->ihist]->Fill\(FilteredData[jk][kl].x_k0, ) S
LHL
(                                                                FilteredData[jk][kl].x_k1,) S
LHL
(                                                                ZPosLayer[jk]+0.05\); //InitTrk) S
SL
(ClustData[jk][0].csh->GetZPos\(\)+0.05\);) S
LHL
(                cout<<"pAnalysis->gens_list[5][pAnalysis->ihst]->Fill\(\);"<<endl;) S
PHL
(                ) S
LHL
(                vectGr  tmpgr;) S
LHL
(                tmpgr.x = FilteredData[jk][kl].x_k0;) S
LHL
(                tmpgr.y = FilteredData[jk][kl].x_k1;) S
LHL
(                tmpgr.z = ZPosLayer[jk]+0.05; //SlcClustData[jk][0].csh->GetZPos\(\)+0.05;) S
LHL
(                tmpgr.dx = 0.0;) S
LHL
(                tmpgr.dy = 0.0;) S
LHL
(                tmpgr.dz = 0.0;) S
LHL
(                // pAnalysis->fitr_vect.push_back\(tmpgr\);) S
LHL
(                if \(pAnalysis->isVisOut==3\)) S
LHL
(                  pAnalysis->gens_vect[5].push_back\(tmpgr\);) S
LHL
(              }) S
LHL
(            }) S
LHL
(          }) S
LHL
(        }) S
LHL
(        cout<<" fTrackCand->GetNDOF\(\) "<<fTrackCand->GetNDOF\(\)<<endl;) S
LHL
(        if \(/*Ndt==1 && */fTrackCand->GetNDOF\(\)>0 && fTrackCand->GetNDOF\(\)<1000\) {) S
EndPage
EndDSCPage
EndSheet

%%Page: 6 6
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 353 def
/PageNumber 6 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
390 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(          //cout<<"Kolahal"<<endl;) S
LHL
(          inoTrackCand_pointer->InoTrackCand_list.push_back\(fTrackCand\);) S
LHL
(        } else {) S
LHL
(          fTrackCand=0;) S
LHL
(        } ) S
LHL
(        //a) S
5 W
(cout <<" fittrer "<< inoTrackCand_pointer->InoTrackCand_list.size\(\)<<endl;) S
PHL
(        ) S
LHL
(        for \(unsigned int jk=0; jk<doubleLa; ++jk\) {) S
LHL
(          InitTrkClustData[jk].clear\(\);) S
LHL
(          SlcClustData[jk].clear\(\);) S
LHL
(          TrkClustsData[jk].clear\(\);) S
LHL
(          FilteredData[jk].clear\(\);) S
LHL
(        }) S
LHL
(      }) S
LHL
(      //ij=1) S
LHL
(    }) S
PHL
(    ) S
LHL
(    // bool TEM;) S
LHL
(    // Ndt = ptrackCollection->InoTrack_list.size\(\);) S
LHL
(    // cout<<"Total no. of Track segments: "<<Ndt<<endl;) S
LHL
(    // if \(Ndt>1 && PassTrack == true\)  // {) S
LHL
(    //   double TargetZ; bool alpha;) S
LHL
(    //   ////////////////////////////////////////////////////////////) S
LHL
(    //   for \(int jk=Ndt-1; jk>=0; jk--\) {) S
LHL
(    // ) S
1 W
(if \(jk>0\) {) S
LHL
(    // ) S
3 W
(if \(MinFiltData[jk-1][5] > MinFiltData[jk][5]\) {) S
PHL
12 W
LHL
(    // ) S
5 W
(double Tr1[6] = {0};) S
LHL
(    // ) S
5 W
(double Tr2[6] = {0};) S
LHL
(    // ) S
5 W
(// cout<<"alpha->true"<<endl;) S
LHL
(    // ) S
5 W
(Tr1[0] = MaxFiltData[jk][0];) S
8 W
(Tr1[1] = MaxFiltData[jk][1];) S
4 W
(Tr1[2] = MaxFi) S
SL
(ltData[jk][2];) S
LHL
(    // ) S
5 W
(Tr1[3] = MaxFiltData[jk][3];) S
8 W
(Tr1[4] = MaxFiltData[jk][4];) S
4 W
(Tr1[5] = MaxFi) S
SL
(ltData[jk][5];) S
LHL
(    // ) S
5 W
(// sometime sign of the qbyP at the end of the tracjk is wrong. So, we borrow the ) S
SL
(sign from the start of the next) S
LHL
(    // ) S
5 W
(//try this) S
LHL
(    // ) S
5 W
(Tr1[4] = fabs\(MaxFiltData[jk][4]\) * \(MaxFiltData[jk-1][4]/fabs\(MaxFiltData[jk-1][4) S
SL
(]\)\);) S
LHL
(    // ) S
5 W
(TargetZ= MinFiltData[jk-1][5];) S
PHL
12 W
LHL
(    // ) S
5 W
(TrackElementMerging\(Tr1, TargetZ, Tr2\);) S
LHL
(    // ) S
5 W
(alpha = true;) S
LHL
(    // ) S
3 W
(} else {) S
LHL
(    // ) S
5 W
(double Tr1[6] = {0};) S
LHL
(    // ) S
5 W
(double Tr2[6] = {0};) S
LHL
(    // ) S
5 W
(// cout<<"alpha->false"<<endl;) S
LHL
(    // ) S
5 W
(Tr1[0] = MaxFiltData[jk-1][0];) S
6 W
(Tr1[1] = MaxFiltData[jk-1][1];) S
2 W
(Tr1[2] = MaxFi) S
SL
(ltData[jk-1][2];) S
LHL
(    // ) S
5 W
(Tr1[3] = MaxFiltData[jk-1][3];) S
6 W
(Tr1[4] = MaxFiltData[jk-1][4];) S
2 W
(Tr1[5] = MaxFi) S
SL
(ltData[jk-1][5];) S
LHL
(    // ) S
5 W
(// sometime sign of the qbyP at the end of the track is wrong. So, we borrow the s) S
SL
(ign from the start of the next) S
LHL
(    // ) S
5 W
(//try this) S
LHL
(    // ) S
5 W
(Tr1[4] = fabs\(MaxFiltData[jk-1][4]\) * \(MaxFiltData[jk][4]/fabs\(MaxFiltData[jk][4]\)) S
SL
(\);) S
LHL
(    // ) S
5 W
(TargetZ= MinFiltData[jk][5];) S
PHL
12 W
LHL
(    // ) S
5 W
(TrackElementMerging\(Tr1, TargetZ, Tr2\);) S
LHL
(    // ) S
5 W
(alpha =false;) S
LHL
(    // ) S
3 W
(}) S
LHL
(    // ) S
3 W
(//cout<<"Before adding, no. of clusters in 0-th track is"<<ptrackCollection->InoTrac) S
SL
(k_list[jk-1]->ClustsInTrack.size\(\)<<endl;) S
LHL
(    // ) S
3 W
(if \(alpha == true\) {) S
LHL
(    // ) S
5 W
(ptrackCollection->InoTrack_list[jk]->AddTrack\(ptrackCollection->InoTrack_list[jk-1) S
SL
(]\);) S
LHL
(    // ) S
3 W
(} else if \(alpha ==false\) {) S
LHL
(    // ) S
5 W
(ptrackCollection->InoTrack_list[jk-1]->AddTrack\(ptrackCollection->InoTrack_list[jk) S
SL
(]\);) S
LHL
(    // ) S
3 W
(}) S
LHL
(    // ) S
3 W
(vector <InoTrack*>::iterator it;) S
LHL
(    // ) S
3 W
(it = ptrackCollection->InoTrack_list.begin\(\);) S
PHL
10 W
LHL
(    // ) S
3 W
(if \(alpha == true\) {) S
LHL
(    // ) S
5 W
(ptrackCollection->InoTrack_list.erase\(it+jk-1\);) S
LHL
(    // ) S
3 W
(} else if \(alpha ==false\) {) S
LHL
(    // ) S
5 W
(ptrackCollection->InoTrack_list.erase\(it+jk\);) S
LHL
(    // ) S
3 W
(}) S
EndPage
EndDSCPage
EndSheet

%%Page: 7 7
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 420 def
/PageNumber 7 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
468 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
10 W
LHL
(    // ) S
3 W
(if \(ptrackCollection->InoTrack_list.size\(\)==1\) {) S
LHL
(    // ) S
5 W
(TEM = true;) S
LHL
(    // ) S
3 W
(}) S
LHL
(    // ) S
1 W
(}) S
LHL
(    //   }) S
PHL
(      ) S
LHL
(    //   if \(TEM == true\) {) S
LHL
(    // ) S
1 W
(goto LOOP;) S
LHL
(    //   }) S
LHL
(    // }) S
PHL
(    ) S
PHL
PHL
LHL
(    //----------------------------------------------------------------------------------------) S
SL
(---------------------------------) S
LHL
(    //asm: this part of the code was inserted to change the order of the tracks in trackCand v) S
SL
(ector.) S
LHL
(    //Now the vectors are placed so that the segment close to the vertex part will taken placs) S
SL
( as zeroth element of the vector.) S
LHL
(    //Apoorva:      this part of the code was inserted to change the order of the tracks in tr) S
SL
(ackCand vector.) S
LHL
(    // Now the vectors are placed in decreasing order of their length) S
LHL
(    vector <InoTrackCand*>::iterator itt2;) S
LHL
(    if\(inoTrackCand_pointer->InoTrackCand_list.size\(\)>1\) {) S
LHL
(      InoTrackCand* tempTrk;) S
LHL
(      InoTrack* tmpfinder;) S
LHL
(      for\(unsigned int ij=0; ij<inoTrackCand_pointer->InoTrackCand_list.size\(\);ij++\) {) S
LHL
(        for\(unsigned int jk=ij+1; jk<inoTrackCand_pointer->InoTrackCand_list.size\(\);jk++\) {) S
LHL
(          //cout<< inoTrackCand_pointer->InoTrackCand_list.size\(\) << "::"<<endl;) S
LHL
(          if\(inoTrackCand_pointer->InoTrackCand_list[ij]->GetMomentumdS\(\) < inoTrackCand_point) S
SL
(er->InoTrackCand_list[jk]->GetMomentumdS\(\)\) {) S
LHL
(            cout<<"Yo Yo...."<<endl;) S
LHL
(            tempTrk = inoTrackCand_pointer->InoTrackCand_list[jk];) S
LHL
(            tmpfinder = ptrackCollection->InoTrack_list[jk];) S
LHL
(            inoTrackCand_pointer->InoTrackCand_list[jk] = inoTrackCand_pointer->InoTrackCand_l) S
SL
(ist[ij];) S
LHL
(            ptrackCollection->InoTrack_list[jk] = ptrackCollection->InoTrack_list[ij];) S
LHL
(            inoTrackCand_pointer->InoTrackCand_list[ij] = tempTrk;) S
LHL
(            ptrackCollection->InoTrack_list[ij] = tmpfinder;) S
LHL
(          }) S
LHL
(        }) S
LHL
(      }) S
PHL
(      ) S
LHL
24 W
(//      bool TEM = false;) S
LHL
(      bool combTracks = true;) S
LHL
(      if\(combTracks\) {) S
LHL
(        for\(unsigned int ij=0; ij<inoTrackCand_pointer->InoTrackCand_list.size\(\);ij++\) {) S
LHL
(          for\(unsigned int jk=ij+1; jk<inoTrackCand_pointer->InoTrackCand_list.size\(\);jk++\) {) S
LHL
(            int zplaneEndTrk1 = inoTrackCand_pointer->InoTrackCand_list[ij]->GetEndPlane\(\);) S
LHL
(            int zplaneVtxTrk1 = inoTrackCand_pointer->InoTrackCand_list[ij]->GetVtxPlane\(\);) S
LHL
(            int zplaneEndTrk2 = inoTrackCand_pointer->InoTrackCand_list[jk]->GetEndPlane\(\);) S
LHL
(            int zplaneVtxTrk2 = inoTrackCand_pointer->InoTrackCand_list[jk]->GetVtxPlane\(\);) S
LHL
(            int iRPCmodVtx1 = inoTrackCand_pointer->InoTrackCand_list[ij]->GetVtxRPCmod\(\);) S
LHL
(            int iRPCmodEnd1 = inoTrackCand_pointer->InoTrackCand_list[ij]->GetEndRPCmod\(\);) S
LHL
(            int iRPCmodVtx2 = inoTrackCand_pointer->InoTrackCand_list[jk]->GetVtxRPCmod\(\);) S
LHL
(            int iRPCmodEnd2 = inoTrackCand_pointer->InoTrackCand_list[jk]->GetEndRPCmod\(\);) S
LHL
(            int nInCHend1 = iRPCmodEnd1%8;) S
LHL
(            iRPCmodEnd1>>=3;) S
LHL
(            int nInMOend1 = iRPCmodEnd1%8;) S
LHL
(            int nInCHvtx1 = iRPCmodVtx1%8;) S
LHL
(            iRPCmodVtx1>>=3;) S
LHL
(            int nInMOvtx1 = iRPCmodVtx1%8;) S
LHL
(            int nInCHend2 = iRPCmodEnd2%8;) S
LHL
(            iRPCmodEnd2>>=3;) S
LHL
(            int nInMOend2 = iRPCmodEnd2%8;) S
LHL
(            int nInCHvtx2 = iRPCmodVtx2%8;) S
LHL
(            iRPCmodVtx2>>=3;) S
LHL
(            int nInMOvtx2 = iRPCmodVtx2%8;) S
LHL
(            bool VtxEndMatchZ = false;) S
LHL
(            bool VtxEndMatchCHMO = false;) S
LHL
(            if\(inoTrackCand_pointer->InoTrackCand_list[ij]->GetFitType\(\)==1\) {) S
LHL
(              if\(zplaneEndTrk1>zplaneVtxTrk1\) {) S
LHL
(                if\(\(zplaneEndTrk2>zplaneEndTrk1\) && \(zplaneVtxTrk2>zplaneEndTrk1\)\) {) S
LHL
(                  VtxEndMatchZ = true;) S
LHL
(                  if\(\(abs\(nInCHend1-nInCHend2\) == 1\) || \(abs\(nInCHend1-nInCHvtx2\)==1\) || \(abs\() S
SL
(nInMOend1-nInMOend2\) == 1\) || \(abs\(nInMOend1-nInMOvtx2\)==1\)\) {) S
LHL
(                    VtxEndMatchCHMO = true;) S
EndPage
EndDSCPage
EndSheet

%%Page: 8 8
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 491 def
/PageNumber 8 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
546 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(                  } else {) S
LHL
(                    VtxEndMatchCHMO = false;) S
LHL
(                  }) S
LHL
(                } else {) S
LHL
(                  VtxEndMatchZ = false;) S
LHL
(                }) S
LHL
(                if\(\(zplaneEndTrk2<zplaneVtxTrk1\) && \(zplaneVtxTrk2<zplaneVtxTrk1\)\) {) S
LHL
(                  VtxEndMatchZ = true;) S
LHL
(                  if\(\(abs\(nInCHvtx1-nInCHend2\) == 1\) || \(abs\(nInCHvtx1-nInCHvtx2\)==1\) || \(abs\() S
SL
(nInMOvtx1-nInMOend2\) == 1\) || \(abs\(nInMOvtx1-nInMOvtx2\)==1\)\) {) S
LHL
(                    VtxEndMatchCHMO = true;) S
LHL
(                  } else {) S
LHL
(                    VtxEndMatchCHMO = false;) S
LHL
(                  }) S
LHL
(                } else {) S
LHL
(                  VtxEndMatchZ = false;) S
LHL
(                }) S
LHL
(              }) S
LHL
(            } else {) S
LHL
(              if\(zplaneEndTrk1<zplaneVtxTrk1\) {) S
LHL
(                if\(\(zplaneEndTrk2<zplaneEndTrk1\) && \(zplaneVtxTrk2<zplaneEndTrk1\)\) {) S
LHL
(                  VtxEndMatchZ = true;) S
LHL
(                  if\(\(abs\(nInCHend1-nInCHend2\) == 1\) || \(abs\(nInCHend1-nInCHvtx2\)==1\) || \(abs\() S
SL
(nInMOend1-nInMOend2\) == 1\) || \(abs\(nInMOend1-nInMOvtx2\)==1\)\) {) S
LHL
(                    VtxEndMatchCHMO = true;) S
LHL
(                  } else {) S
LHL
(                    VtxEndMatchCHMO = false;) S
LHL
(                  }) S
LHL
(                } else {) S
LHL
(                  VtxEndMatchZ = false;) S
LHL
(                }) S
LHL
(                if\(\(zplaneEndTrk2>zplaneVtxTrk1\) && \(zplaneVtxTrk2>zplaneVtxTrk1\)\) {) S
LHL
(                  VtxEndMatchZ = true;) S
LHL
(                  if\(\(abs\(nInCHvtx1-nInCHend2\) == 1\) || \(abs\(nInCHvtx1-nInCHvtx2\)==1\) || \(abs\() S
SL
(nInMOvtx1-nInMOend2\) == 1\) || \(abs\(nInMOvtx1-nInMOvtx2\)==1\)\) {) S
LHL
(                    VtxEndMatchCHMO = true;) S
LHL
(                  } else {) S
LHL
(                    VtxEndMatchCHMO = false;) S
LHL
(                  }) S
LHL
(                } else {) S
LHL
(                  VtxEndMatchZ = false;) S
LHL
(                }) S
LHL
(              }) S
LHL
(            } // if\(inoTrackCand_pointer->InoTrackCand_list[0]->GetFitType\(\)==1\) {) S
PHL
(            ) S
LHL
(            if\(VtxEndMatchCHMO && VtxEndMatchZ\) {) S
LHL
(              ptrackCollection->InoTrack_list[ij]->AddTrack\(ptrackCollection->InoTrack_list[jk) S
SL
(]\);) S
LHL
(              vector <InoTrack*>::iterator itt3;) S
LHL
(              itt3 = ptrackCollection->InoTrack_list.begin\(\);) S
LHL
(              ptrackCollection->InoTrack_list.erase\(itt3+jk\);) S
LHL
(              goto LOOP;) S
LHL
(            }) S
LHL
(          } // for\(unsigned int jk=ij+1; jk<inoTrackCand_pointer->InoTrackCand_list.size\(\);jk+) S
SL
(+\) {) S
LHL
(        } // for\(unsigned int ij=0; ij<inoTrackCand_pointer->InoTrackCand_list.size\(\);ij++\) {) S
LHL
(      } // if\(combTracks\) {) S
LHL
(    }) S
PHL
(    ) S
PHL
(    ) S
PHL
(    ) S
LHL
(    //----------------------------------------------------------------------------------------) S
SL
(---------------------------------) S
LHL
(    //asm: this part of the code was inserted to change the order of the tracks in trackCand v) S
SL
(ector.) S
LHL
(    //Now the vectors are placed so that the segment close to the vertex part will taken placs) S
SL
( as zeroth element of the vector.) S
PHL
(    ) S
LHL
(    bool tmpnui = false;) S
LHL
(    if\(tmpnui\) {) S
LHL
(      cout<<"LOL...."<<endl;) S
LHL
(      vector <InoTrackCand*>::iterator itt1;) S
LHL
(      if\(inoTrackCand_pointer->InoTrackCand_list.size\(\)>1\) {) S
LHL
(        InoTrackCand* tempTrk;) S
PHL
(        ) S
LHL
(        for\(unsigned int jk=1; jk<inoTrackCand_pointer->InoTrackCand_list.size\(\);jk++\) {) S
LHL
(          //cout<< inoTrackCand_pointer->InoTrackCand_list.size\(\) << "::"<<endl;) S
PHL
(          ) S
EndPage
EndDSCPage
EndSheet

%%Page: 9 9
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 561 def
/PageNumber 9 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
624 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(          if\(abs\(inoTrackCand_pointer->InoTrackCand_list[0]->GetVtxZ\(\)-inoTrackCand_pointer->I) S
SL
(noTrackCand_list[jk]->GetVtxZ\(\)\)>1\) {) S
PHL
(            ) S
LHL
(            if\(inoTrackCand_pointer->InoTrackCand_list[0]->GetFitType\(\)==1 &&inoTrackCand_poin) S
SL
(ter->InoTrackCand_list[jk]->GetFitType\(\)==1  \) {) S
LHL
(              if\(inoTrackCand_pointer->InoTrackCand_list[0]->GetVtxZ\(\)>inoTrackCand_pointer->I) S
SL
(noTrackCand_list[jk]->GetVtxZ\(\)\) {) S
LHL
(                tempTrk = inoTrackCand_pointer->InoTrackCand_list[jk];) S
LHL
(                itt1=inoTrackCand_pointer->InoTrackCand_list.begin\(\);) S
LHL
(                inoTrackCand_pointer->InoTrackCand_list.erase\(itt1+jk\);) S
LHL
(                inoTrackCand_pointer->InoTrackCand_list.insert\(itt1,tempTrk\);) S
PHL
(                ) S
LHL
(              }) S
LHL
(            } else if \( inoTrackCand_pointer->InoTrackCand_list[0]->GetFitType\(\)==0 && inoTrac) S
SL
(kCand_pointer->InoTrackCand_list[jk]->GetFitType\(\)==0\) {) S
LHL
(              if\(inoTrackCand_pointer->InoTrackCand_list[0]->GetVtxZ\(\)<inoTrackCand_pointer->I) S
SL
(noTrackCand_list[jk]->GetVtxZ\(\)\) {) S
PHL
(                ) S
LHL
(                tempTrk = inoTrackCand_pointer->InoTrackCand_list[jk];) S
LHL
(                itt1=inoTrackCand_pointer->InoTrackCand_list.begin\(\);) S
LHL
(                inoTrackCand_pointer->InoTrackCand_list.erase\(itt1+jk\);) S
LHL
(                inoTrackCand_pointer->InoTrackCand_list.insert\(itt1,tempTrk\);) S
LHL
(              }) S
LHL
(            }) S
LHL
(          }) S
LHL
(        }) S
LHL
(      }) S
LHL
(    }) S
LHL
(    //----------------------------------------------------------------------------------------) S
SL
(---------------------------------) S
LHL
(  }) S
PHL
LHL
(  // cout<<"...} InoTrackFitAlg::RunAlg\(\)"<<endl;) S
LHL
(}) S
PHL
LHL
(void InoTrackFitAlg::TrackElementMerging\(double *Tr1, double TargetZ, double *Tr2\) {) S
4 W
LHL
(  double Bx = 0; double By = 0;) S
LHL
(  double Position[3]={0};) S
7 W
(Position[0]=Tr1[0]; Position[1]=Tr1[1];) S
1 W
(Position[2]=Tr1[5];) S
PHL
(  ) S
LHL
(  //) S
4 W
(micalFieldPropagator *pFieldMap;) S
LHL
(  pFieldMap = micalFieldPropagator::FdPointer;) S
PHL
(  ) S
LHL
(  while\(Position[2]>=Tr1[5] && Position[2] < TargetZ\) {) S
LHL
(    // Scale the Position array for calling Magnetic Field) S
LHL
(    Position[0] *= 1000;) S
8 W
(Position[1] *= 1000;) S
4 W
(Position[2] *= 1000;) S
PHL
(    ) S
LHL
(    pFieldMap->ElectroMagneticField\(Position,Bx,By,1\);) S
LHL
(    Bx *= 1000;) S
1 W
(By *= 1000;) S
PHL
(    ) S
PHL
(    ) S
PHL
(   ) S
LHL
(    // ReScale the Position array after calling Magnetic Field) S
LHL
(    Position[0] /= 1000;) S
8 W
(Position[1] /= 1000;) S
4 W
(Position[2] /= 1000;) S
12 W
PHL
(    ) S
LHL
(    // Take small steps) S
LHL
(    double dz = 0.002;) S
PHL
(    ) S
LHL
(    double x; double y; double tx; double ty; double qbyP; double z;) S
LHL
(    x = Tr1[0];) S
1 W
(tx= Tr1[2];) S
5 W
(qbyP= Tr1[4];) S
LHL
(    y = Tr1[1];) S
1 W
(ty= Tr1[3];) S
5 W
(z) S
7 W
(= Tr1[5];) S
PHL
(    ) S
LHL
(    double pos[3]={0.0};) S
LHL
(    double dir[3]={0.0};) S
PHL
(    ) S
LHL
(    //int signp = \(ZIncreasesWithTime != GoForward\) ? -1 : 1;) S
PHL
(    ) S
LHL
(    double dxdz = tx;) S
LHL
(    double dydz = ty;) S
LHL
(    double dsdz = pow\(\(1.+pow\(tx,2\)+pow\(ty,2\)\),0.5\);) S
PHL
(    ) S
LHL
(    pos[0] = 1.e2*x;) S
LHL
(    pos[1] = 1.e2*y;) S
LHL
(    pos[2] = 1.e2*z;) S
PHL
(    ) S
LHL
(    dir[0] = dxdz/dsdz;) S
LHL
(    dir[1] = dydz/dsdz;) S
LHL
(    dir[2] = 1.0/dsdz;) S
10 W
PHL
(    ) S
EndPage
EndDSCPage
EndSheet

%%Page: 10 10
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 633 def
/PageNumber 10 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
702 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(    double state[5] ={x,y,tx,ty,qbyP};) S
PHL
(    ) S
LHL
(    icalGeometry->InitTrack\(pos, dir\);) S
LHL
(    localmat = icalGeometry->GetCurrentVolume\(\)->GetMaterial\(\);) S
LHL
(    double Eloss = 0;) S
LHL
(    Eloss = GetEnergyLoss\(state, dz, xi, T_max, I, localmat\);) S
LHL
(    //cout<<"Eloss "<<Eloss<<endl;) S
PHL
(    ) S
LHL
(    double P = 0; double E = 0; double amu = 0.1056; double P_ex;) S
7 W
(double E_ex;) S
LHL
(    {) S
LHL
(      P) S
1 W
(= fabs\(1/qbyP\);) S
71 W
SL
2 W
(//cout<<"PSC\(iron\) P = "<<P<<endl;) S
LHL
(      E) S
1 W
(= sqrt\(pow\(P,2\) + pow\(amu,2\)\);) S
42 W
(//cout<<"PSC\(i) S
SL
(ron\) E = "<<E<<endl;) S
LHL
(      E_ex= E - Eloss;) S
PHL
(      ) S
LHL
(      if \(\(E_ex-amu\)>0\)) S
1 W
({) S
LHL
8 W
(P_ex= sqrt\(pow\(E_ex,2\) - pow\(amu,2\)\);) S
LHL
(      } else {) S
LHL
8 W
(P_ex= P;) S
LHL
(      }) S
LHL
(    }) S
PHL
(    ) S
LHL
(    double kappa) S
8 W
(= 0.299792458;) S
LHL
(    double T) S
12 W
(= sqrt\(1+pow\(tx,2\)+pow\(ty,2\)\);) S
LHL
(    //    double T2) S
13 W
(= pow\(T,2\);) S
LHL
(    double h) S
12 W
(= kappa*qbyP*T;) S
LHL
(    double Rx) S
11 W
(= Bx*dz*h;) S
LHL
(    //    double Rxx = 0.5 * Bx * Bx * pow\(dz,2\);) S
LHL
(    //    double Sxx = \(1/6\)*Bx*Bx*pow\(dz,3\);) S
LHL
(    double Ry) S
11 W
(= By*dz*h;) S
LHL
(    //    double Rxy = 0.5 * Bx * By * pow\(dz,2\);) S
LHL
(    //    double Sxy = \(1/6\)*Bx*By*pow\(dz,3\);) S
LHL
(    double Sx) S
11 W
(= 0.5*Bx*pow\(dz,2\)*h;) S
3 W
LHL
(    //    double Ryx = 0.5 * By * Bx * pow\(dz,2\);) S
7 W
LHL
(    //    double Syx = \(1/6\)*By*Bx*pow\(dz,3\);) S
LHL
(    double Sy) S
11 W
(= 0.5*By*pow\(dz,2\)*h;) S
3 W
LHL
(    //    double Ryy = 0.5 * By * By * pow\(dz,2\);) S
LHL
(    //    double Syy = \(1/6\)*By*By*pow\(dz,3\);) S
PHL
(    ) S
LHL
(    Tr1[0] = x + tx * dz + tx * ty * Sx - \(pow\(tx,2\)+1\) * Sy;// + h*h * \(tx*\(3*ty*ty+1\)*Sxx - ) S
SL
(ty*\(3*tx*tx+1\)*Sxy -ty*\(3*tx*tx+1\)*Syx + tx*\(3*ty*ty+3\)*Syy\);) S
LHL
(    if \(fabs\(qbyP\)>4.0\) Tr1[0] = x + tx * dz;) S
PHL
(    ) S
LHL
(    Tr1[1] = y + ty * dz + \(pow\(ty,2\)+1\) * Sx - tx * ty * Sy;// + h*h * \(ty*\(3*ty*ty+3\)*Sxx - ) S
SL
(tx*\(3*ty*ty+1\)*Sxy -tx*\(3*ty*ty+1\)*Syx + ty*\(3*tx*tx+1\)*Syy\);) S
LHL
(    if \(fabs\(qbyP\)>4.0\) Tr1[1] = y + ty * dz;) S
PHL
(    ) S
LHL
(    Tr1[2] = tx + tx * ty * Rx - \(pow\(tx,2\)+1\) * Ry;// + h*h * \(tx*\(3*ty*ty+1\)*Rxx - ty*\(3*tx*) S
SL
(tx+1\)*Rxy -ty*\(3*tx*tx+1\)*Ryx + tx*\(3*ty*ty+3\)*Ryy\);) S
LHL
(    if \(fabs\(qbyP\)>4.0\) Tr1[2] = tx;) S
PHL
(    ) S
LHL
(    Tr1[3] = ty + \(pow\(ty,2\)+1\) * Rx - tx * ty * Ry;// + h*h * \(ty*\(3*ty*ty+3\)*Rxx - tx*\(3*ty*) S
SL
(ty+1\)*Rxy -tx*\(3*ty*ty+1\)*Ryx + ty*\(3*tx*tx+1\)*Ryy\);) S
LHL
(    if \(fabs\(qbyP\)>4.0\) Tr1[3] = ty;) S
PHL
(    ) S
LHL
(    Tr1[4] = Tr1[4] * \(P/P_ex\);) S
PHL
(    ) S
LHL
(    Tr1[5] = Position[2] + dz;) S
PHL
(    ) S
LHL
(    Position[2] = Position[2] + dz;) S
PHL
(    ) S
LHL
(    //cout<<"Tr1X "<<Tr1[0]<<"     "<<"Tr1Y "<<Tr1[1]<<"     "<<"Tr1Z "<<Tr1[5]<<"     "<<"Tr1) S
SL
(Tx "<<Tr1[2]<<"     "<<"Tr1Ty"<<Tr1[3]<<endl;) S
LHL
(  }) S
LHL
(  for \(int ij = 0; ij<6; ij++\) {) S
LHL
(    Tr2[ij] = Tr1[ij];) S
LHL
(  }) S
LHL
(  //cout<<"Extrapolated X "<<Tr2[0]<<"     "<<"Extrapolated Y "<<Tr2[1]<<endl;) S
LHL
(}) S
PHL
LHL
(void InoTrackFitAlg::InitialFramework\(\) { //const CandSliceHandle* slice,CandContext &cx\)) S
LHL
(  if\(debug_fit\) { cout<<"  InoTrackFitAlg::InitialFramework\(\) " <<endl;}) S
LHL
(  // Store InoHit and make the strips accessible by plane number) S
LHL
(  double MisalignmentError=0.0; //2.5e-5;) S
PHL
(  ) S
LHL
(  //  double MisalignmentError=1e-8; //1e-6; //1e-4; //4e-4; //1e-8; //4e-6;  // GMA need numb) S
SL
(er from INO : Squared error for misalignment of strips) S
EndPage
EndDSCPage
EndSheet

%%Page: 11 11
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 703 def
/PageNumber 11 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
780 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  //  double strXwd = StripXWidth; // 0.0196;  //GMA use common variable, this is in metre \(NO) S
SL
(T IN CM\)) S
LHL
(  //  double XposErrorSq = pow\(strXwd/pow\(12.,0.5\),2.\);) S
LHL
(  //  double strYwd = StripYWidth; //0.0196;  //GMA use common variable, this is in metre \(NOT) S
SL
( IN CM\)) S
LHL
(  //  double YposErrorSq = pow\(strYwd/pow\(12.,0.5\),2.\);) S
PHL
(  ) S
LHL
(  int SlicePlane;) S
PHL
(  ) S
LHL
(  // a cout <<"inside InitialFramework "<<endl;) S
LHL
(  // Store all clusters) S
PHL
(  ) S
LHL
(  //a  cout <<"1size "<< InoCluster_pointer->InoCluster_list.size\(\)<<endl;) S
LHL
(  for \(unsigned ij=0; ij<InoCluster_pointer->InoCluster_list.size\(\); ij++\) {) S
LHL
(    SlicePlane=InoCluster_pointer->InoCluster_list[ij]->GetZPlane\(\);) S
LHL
(    ClustStruct temp;) S
LHL
(    temp.csh=InoCluster_pointer->InoCluster_list[ij];) S
LHL
(    SlcClustData[SlicePlane].push_back\(temp\);) S
LHL
(  }) S
PHL
(  ) S
LHL
(  int TrackPlane;) S
PHL
(  ) S
LHL
(  //  Store all track clusters found,) S
LHL
(  for \(unsigned ij=0; ij<fFinderTrack->ClustsInTrack.size\(\); ij++\) {) S
LHL
(    SlicePlane=fFinderTrack->ClustsInTrack[ij]->GetZPlane\(\);) S
LHL
(    ClustStruct temp;) S
LHL
(    temp.csh=fFinderTrack->ClustsInTrack[ij];) S
PHL
(    ) S
LHL
(    TrackPlane=temp.csh->GetZPlane\(\);) S
PHL
(    ) S
LHL
(    TrkDataStruct tempdata;) S
LHL
(    tempdata.numInList = ij;) S
LHL
(    tempdata.cltime =temp.csh->GetTime\(\); ) S
PHL
(    ) S
LHL
(    tempdata.ZPos=ZPosLayer[TrackPlane];) S
LHL
(    tempdata.PlaneView = temp.csh->GetView\(\);) S
PHL
(    ) S
LHL
(    tempdata.XPos=temp.csh->GetXPos\(\);) S
LHL
(    tempdata.XPosErrSq = pow\(temp.csh->GetXPosErr\(\),2.0\) + MisalignmentError ; // + XposErrorS) S
SL
(q; // pow\(temp.csh->GetXPosErr\(\),2.0\);) S
PHL
(    ) S
LHL
(    tempdata.YPos=temp.csh->GetYPos\(\);) S
LHL
(    tempdata.YPosErrSq = pow\(temp.csh->GetYPosErr\(\),2.0\) + MisalignmentError; //  + YposErrorS) S
SL
(q; // pow\(temp.csh->GetYPosErr\(\),2.0\);) S
PHL
(    ) S
LHL
(    tempdata.Straight = fFinderTrack->ClustsInTrack[ij]->GetStraight\(\);) S
LHL
(    int ishift = \(fFinderTrack->ClustsInTrack[ij]->GetStraight\(\)\) ? 0 : shiftLa;) S
LHL
(    TrkClustsData[TrackPlane+ishift].push_back\(tempdata\);) S
LHL
(    InitTrkClustData[SlicePlane+ishift].push_back\(temp\);) S
PHL
(    ) S
LHL
(    if \(ishift >0\) {) S
LHL
(      temp.csh->SetStraight\(false\);) S
LHL
(    } else {) S
LHL
(      temp.csh->SetStraight\(true\);) S
LHL
(    }) S
PHL
(    ) S
LHL
(    // Identify ends of initial track) S
LHL
(    if \(TrackPlane>MaxPlane\) {MaxPlane=TrackPlane;}) S
LHL
(    if \(TrackPlane<MinPlane\) {MinPlane=TrackPlane;}) S
LHL
(  }) S
LHL
(  //a cout <<"Exiting InitialFramework "<<MinPlane<<" "<<MaxPlane<<endl;) S
LHL
(}) S
PHL
PHL
LHL
(// void InoTrackFitAlg::ShowerStrips\(\) {) S
LHL
(//   //a  cout <<"InoTrackFitAlg : ShowerStrips, Look for large vertex shower" << endl;) S
LHL
(//   // It is not being used currently \(even not with implimenation of Geometry\): Kolahal \(Nov) S
SL
(5,2013\)) S
LHL
(//   // Initialisations) S
LHL
(//   int Increment; int NumberOfHits;) S
LHL
(//   int Plane; int NewPlane;) S
PHL
(  ) S
LHL
(//   int VtxShwWindow=8;) S
LHL
(//   int HitsForShw=4;) S
LHL
(//   double PEThreshold=0.00001; //GMA  .1;) S
PHL
(  ) S
LHL
(//   if\(ZIncreasesWithTime==true\) {) S
LHL
(//     Plane=MinPlane; Increment=1;) S
EndPage
EndDSCPage
EndSheet

%%Page: 12 12
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 776 def
/PageNumber 12 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
858 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(//   } else {) S
LHL
(//     Plane=MaxPlane; Increment=-1;) S
LHL
(//   }) S
LHL
(//   NewPlane=Plane;) S
PHL
(  ) S
LHL
(//   // Identify any vertex showers) S
LHL
(//   while\(abs\(Plane-NewPlane\)<=VtxShwWindow && NewPlane>=MinPlane && NewPlane<=MaxPlane\) {) S
LHL
(//     if\(SlcClustData[NewPlane].size\(\)>0\) {) S
LHL
(//       NumberOfHits=0;) S
LHL
(//       // Set the number of hits on a plane required for the plane to be identified as 'in t) S
SL
(he) S
LHL
(//       // shower'. We account for the gradient of the track, with the factor of 0.25 represe) S
SL
(nting) S
LHL
(//       // the approximate ratio of strip thickness to strip width.) S
PHL
(      ) S
LHL
(//       if\(FilteredData[NewPlane].size\(\)>0\) {) S
LHL
(// ) S
5 W
(//GMA Need optimisation) S
LHL
(// ) S
5 W
(//GMA 07/02/2009 Excluding layer, which does not have any hit points,) S
LHL
(// ) S
5 W
(//but in track extrapolation, it is stored.) S
LHL
(// ) S
5 W
(if \(FilteredData[NewPlane][0].x_k4 !=0.0\) {) S
LHL
(// ) S
7 W
(if\(SlcClustData[NewPlane][0].csh->GetView\(\)==2\) {) S
LHL
(// ) S
9 W
(//GMA what is this view) S
LHL
(// ) S
9 W
(HitsForShw=max\(min\(7,int\( 4+\(0.25*fabs\(FilteredData[NewPlane][0].x_k2\)\) \)\),min\(7,i) S
SL
(nt\( 4+\(0.25*fabs\(FilteredData[NewPlane][0].x_k3\)\) \)\)\);) S
LHL
(// ) S
7 W
(} else if \(SlcClustData[NewPlane][0].csh->GetView\(\)==0\) {) S
LHL
(// ) S
9 W
(HitsForShw=min\(7,int\( 4+\(0.25*fabs\(FilteredData[NewPlane][0].x_k2\)\) \)\);) S
LHL
(// ) S
7 W
(} else {) S
LHL
(// ) S
9 W
(HitsForShw=min\(7,int\( 4+\(0.25*fabs\(FilteredData[NewPlane][0].x_k3\)\) \)\);) S
LHL
(// ) S
7 W
(}) S
LHL
(// ) S
5 W
(}) S
LHL
(//       } else {) S
LHL
(// ) S
5 W
(HitsForShw=4;) S
LHL
(//       }) S
PHL
(      ) S
LHL
(//       // Count number of strips on plane with greater than 2PEs) S
LHL
(//       for\(unsigned int ij=0; ij<SlcClustData[NewPlane].size\(\); ++ij\) {) S
LHL
(// ) S
5 W
(if\(SlcClustData[NewPlane][ij].csh->GetPulse\(\)>PEThreshold\) {NumberOfHits++;}) S
LHL
(//       }) S
PHL
(      ) S
LHL
(//       // If a vertex shower is found, note that we should use the Swimmer) S
LHL
(//       // to find the most likely track strips inside the shower) S
LHL
(//       if\(NumberOfHits>=HitsForShw\) {ShowerEntryPlane=NewPlane; SwimThroughShower=true; brea) S
SL
(k;}) S
LHL
(//       NewPlane+=Increment;) S
LHL
(//     } else {) S
LHL
(//       NewPlane+=Increment;) S
LHL
(//     }) S
LHL
(//   }) S
LHL
(//   // Find the plane at which the 'clean' section of track enters the shower) S
LHL
(//   if\(SwimThroughShower==true\) {) S
LHL
(//     NewPlane=ShowerEntryPlane+Increment;) S
LHL
(//     int PlanesSinceLastHit=0;) S
LHL
(//     int PlaneWindow=4;) S
PHL
(    ) S
LHL
(//     while\(PlanesSinceLastHit<PlaneWindow && NewPlane>=MinPlane && NewPlane<=MaxPlane\) {) S
LHL
(//       if\(SlcClustData[NewPlane].size\(\)>0\) {) S
LHL
(// ) S
5 W
(NumberOfHits=0;) S
PHL
8 W
LHL
(// ) S
5 W
(// Account for gradient of track, as before) S
LHL
(// ) S
5 W
(if\(FilteredData[NewPlane].size\(\)>0\) {) S
LHL
(// ) S
7 W
(// GMA 07/02/2009 Excluding layer, which does not have any hit points,) S
LHL
(// ) S
7 W
(// but in track extrapolation, it is stored.) S
LHL
(// ) S
7 W
(if \(FilteredData[NewPlane][0].x_k4 !=0.0\) {) S
LHL
(// ) S
9 W
(if\(SlcClustData[NewPlane][0].csh->GetView\(\)==2\) {) S
LHL
(// ) S
11 W
(HitsForShw=max\(min\(7,int\(4+\(0.25*fabs\(FilteredData[NewPlane][0].x_k2\)\) \)\),min\(7,) S
SL
(int\(4+\(0.25*fabs\(FilteredData[NewPlane][0].x_k3\)\) \)\)\);) S
LHL
(// ) S
9 W
(} else if \(SlcClustData[NewPlane][0].csh->GetView\(\)==0\) {) S
LHL
(// ) S
11 W
(HitsForShw= min\(7,int\(4+\(0.25*fabs\(FilteredData[NewPlane][0].x_k2\)\) \)\);) S
LHL
(// ) S
9 W
(} else {) S
LHL
(// ) S
11 W
(HitsForShw=min\(7,int\(4+\(0.25*fabs\(FilteredData[NewPlane][0].x_k3\)\) \)\);) S
LHL
(// ) S
9 W
(}) S
LHL
(// ) S
7 W
(}) S
LHL
(// ) S
5 W
(} else {) S
LHL
(// ) S
7 W
(HitsForShw=4;) S
LHL
(// ) S
5 W
(}) S
PHL
8 W
LHL
(// ) S
5 W
(// Count number of strips on plane with greater than 2PEs) S
LHL
(// ) S
5 W
(for\(unsigned int ij=0; ij<SlcClustData[NewPlane].size\(\); ++ij\) {) S
EndPage
EndDSCPage
EndSheet

%%Page: 13 13
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 849 def
/PageNumber 13 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
936 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(// ) S
7 W
(if\(SlcClustData[NewPlane][ij].csh->GetPulse\(\)>PEThreshold\) {) S
LHL
(// ) S
9 W
(NumberOfHits++;) S
LHL
(// ) S
7 W
(}) S
LHL
(// ) S
5 W
(}) S
LHL
(// ) S
5 W
(if\(NumberOfHits>=HitsForShw\) {) S
LHL
(// ) S
7 W
(ShowerEntryPlane=NewPlane; NewPlane+=Increment; PlanesSinceLastHit=0;) S
LHL
(// ) S
5 W
(} else {) S
LHL
(// ) S
7 W
(PlanesSinceLastHit++; NewPlane+=Increment;) S
LHL
(// ) S
5 W
(}) S
LHL
(//       } else {) S
LHL
(// ) S
5 W
(PlanesSinceLastHit++; NewPlane+=Increment;) S
LHL
(//       }) S
LHL
(//     }) S
LHL
(//   }) S
LHL
(// }) S
PHL
LHL
(void InoTrackFitAlg::RunTheFitter\( \) {) S
LHL
(  if\(debug_fit\) { cout<< " InoTrackFitAlg::RunTheFitter\(\)" <<PassTrack<<endl;}) S
PHL
(    ) S
LHL
(  // cout <<"InoTrackFitAlg : RunTheFitter, Call methods in the appropriate order" << endl;) S
LHL
(  GetInitialCovarianceMatrix\(true\);) S
PHL
(  ) S
LHL
(  const bool GoForward=true;) S
LHL
(  const bool GoBackward=false;) S
PHL
(  ) S
LHL
(  double StateVector[6]) S
1 W
(= {0.0};) S
LHL
(  double Prediction[6]) S
2 W
(= {0.0};) S
PHL
(  ) S
LHL
(  // Control the iterations backwards and forwards) S
LHL
(  // Detector::Detector_t detector = vldc->GetDetector\(\);) S
PHL
(  ) S
LHL
(  int niteration=5;) S
LHL
(  double chisq_old=-100;) S
LHL
(  int ndof_old = -100;) S
LHL
(  int ndifchi = -1;) S
LHL
(  //  double CSQ[5]={0.0};) S
LHL
8 W
(double xvtx_parameter[6] = {0.0};) S
LHL
(  // Control iterations over a track for which ZIncreasesWithTime) S
LHL
(  if\(ZIncreasesWithTime==true\) {) S
LHL
(    cout<<"ZIncreasesWithTime"<<endl;) S
PHL
(    ) S
LHL
(    //First iteration) S
LHL
(    NIter++;) S
PHL
(    ) S
LHL
(    //Vtx to End \(Forwards\)) S
PHL
(    ) S
LHL
(    SaveData=true;) S
LHL
(    StoreFilteredData\(MinPlane\);) S
LHL
(    LastIteration=false;) S
PHL
(    ) S
LHL
(    GoForwards\(false\);) S
LHL
(    //ResetCovarianceMatrix\(\);) S
PHL
(    ) S
LHL
(    //cout <<"true============ResetCovarianceMatrix============================="<<endl;) S
PHL
(    ) S
LHL
(    // ShowerStrips\(\) was not explicitly given here; it is explicitly givrn \(albeit commented\)) S
SL
( for ZDecreasesWitTime. GMA did not use it at all.) S
LHL
(    // ShowerStrips\(\);) S
LHL
(    if\(SwimThroughShower==true\) {) S
LHL
(      RemoveTrkHitsInShw\(\);) S
LHL
(    }) S
LHL
(    // SwimThroughShower conditionally set to true only within ShowerStrips\(\) which is ) S
LHL
(    // never called. So, effectively, this command does nothing.) S
PHL
(    ) S
LHL
(    for \(unsigned int ij=0; ij<doubleLa; ++ij\) {) S
LHL
(      FilteredData[ij].clear\(\);) S
LHL
(    }) S
PHL
(    ) S
LHL
(    StoreFilteredData\(MaxPlane\);) S
PHL
(    ) S
LHL
(    //End to Vtx: Backwards) S
PHL
(    ) S
LHL
(    GoBackwards\(false\);) S
PHL
(    ) S
LHL
(    if\(SwimThroughShower==true\) {) S
LHL
(      ShowerSwim\(\);) S
LHL
(    }) S
LHL
(    // SwimThroughShower conditionally set to true only within ShowerStrips\(\) which is ) S
EndPage
EndDSCPage
EndSheet

%%Page: 14 14
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 926 def
/PageNumber 14 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
1014 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(    // never called. So, effectively, this command does nothing.) S
PHL
(    ) S
LHL
(    for\(int ij= 0; ij<5; ij++\){StateIter[ij] = x_k[ij];}) S
LHL
(    //cout<<"C00 "<<C_k[0][0]<<"     C11 "<<C_k[1][1]<<"     C22 "<<C_k[2][2]<<"     C33 "<<C_) S
SL
(k[3][3]<<"     C44 "<<C_k[4][4]<<endl;) S
LHL
(    ResetCovarianceMatrix\(\);) S
PHL
(    ) S
LHL
(    bool ClusterFound = true;) S
PHL
(    ) S
LHL
(    // FindTheStrips\(false\);) S
LHL
(    // cth,false\);) S
LHL
(    // asm: here we can set some check to decide when no cluster found) S
PHL
(    ) S
LHL
(    if\(ClusterFound==true\) { //GMA 210625 Why this) S
LHL
(      // cout<<"cluster found"<<endl;) S
LHL
(      // Guard against finding no strips) S
LHL
(      for\(int nint=0; nint <= niteration; nint++\) {) S
LHL
(        double fi = 0.0;) S
LHL
(        for\(int ij = 0; ij<5; ij++\) {) S
LHL
(          if\(NIter>2\)) S
LHL
(            fi = \(x_k[ij]-StateIter[ij]\)/StateIter[ij];) S
LHL
(          StateIter[ij] = x_k[ij];) S
LHL
(          /*if \(fabs\(fi\) > 0.1\)) S
LHL
(            cout<<fi<<" for ij= "<<ij<<" @ N "<<NIter<<endl;*/) S
LHL
(        }) S
PHL
(        ) S
LHL
(        double chisq_new = fTrackCand->GetChi2\(\);) S
LHL
(        int ndof_new = fTrackCand->GetNDOF\(\);) S
LHL
(        //cout<<chisq_old<<"     "<<chisq_new<<"     "<<ndifchi<<"     "<<NIter<<endl;) S
PHL
(        ) S
LHL
(        if \(ndof_old == ndof_new && abs\(chisq_old - chisq_new\) < 0.01\) {) S
LHL
(          ndifchi=0;) S
LHL
(        }) S
LHL
(        //Valgrind comments : Conditional jump or move depends on uninitialised value) S
PHL
(        ) S
LHL
(        ndof_old = ndof_new;) S
LHL
(        chisq_old = chisq_new;) S
PHL
(        ) S
LHL
(        //GMA stop loop if there is no change in hit points) S
LHL
(        //Keep in mind SaveData=true \(Data from only last iteration is stored\);) S
PHL
(        ) S
LHL
(        NIter++;) S
PHL
(        ) S
LHL
(        if\(\(nint==niteration || ndifchi==0\) && nint>1\) {) S
LHL
(          LastIteration = true;) S
LHL
(        }) S
LHL
(        if \(nint>0\) {) S
LHL
(          GetFitData\(MinPlane,MaxPlane\);) S
LHL
(        }) S
7 W
LHL
(        // cout<<"GetFitData_new "<<"MinPlane = "<<MinPlane<<"   "<<"MaxPlane = "<<MaxPlane<<e) S
SL
(ndl;) S
LHL
(        if \(MinPlane > MaxPlane\) {) S
LHL
(          cout<<" PassTrack 3a " << MinPlane<< "<"<< MaxPlane<<endl;) S
LHL
(          PassTrack=false;) S
LHL
(          break;) S
LHL
(        }) S
LHL
(        //a cout <<"2true=====ResetCovarianceMatrix====="<<endl;) S
PHL
(        ) S
LHL
(        SaveData=true;) S
26 W
(// Here Savedata was set to false) S
LHL
(        StoreFilteredData\(MinPlane\);// This command was absent. It is introduced to keep parit) S
SL
(y with GB) S
PHL
(        ) S
LHL
(        fTrackCand->f2dS.clear\(\);) S
LHL
(        fTrackCand->f2Range.clear\(\);) S
PHL
(        ) S
LHL
(        GoForwards\(true\);) S
PHL
(        ) S
LHL
(        //Abhijit's Work. ADB 2015/05/06) S
LHL
(        //>>) S
LHL
(        // Extrapolating upwards) S
LHL
(        //Upward = 1 , Downward = 0) S
LHL
(        // cout<<"NIter FCorPCForward "<<NIter<<endl;) S
LHL
(        if \(NIter == 4 \) {) S
LHL
(          // cout<<"XXXXXXXXXXXXXXXXXX"<<endl;) S
LHL
(          FCorPCForward = CheckFCPCUpOrDn\(x_k, 1, MaxPlane, GoForward\);) S
LHL
(          // cout<<"1FCorPCForward "<<FCorPCForward<<endl;) S
LHL
(          // cout<<"-------------------------------"<<endl;) S
LHL
(        }) S
EndPage
EndDSCPage
EndSheet

%%Page: 15 15
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 1001 def
/PageNumber 15 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
1092 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(        //<< ) S
LHL
(        //Abhijit's Work ADB 2015/05/06) S
PHL
(        ) S
PHL
(        ) S
LHL
(        //ResetCovarianceMatrix\(\);) S
LHL
(        //Look on this) S
PHL
(        ) S
LHL
(        //End back to vtx again) S
LHL
(        for \(unsigned int ij=0; ij<doubleLa; ++ij\) {) S
LHL
(          for \(unsigned jk=0; jk<FilteredData[ij].size\(\); jk++\) {) S
LHL
(            if \(FilteredData[ij][jk].x_k5==1\) {) S
LHL
(              FilteredData[ij].erase\(FilteredData[ij].begin\(\)+jk\);) S
LHL
(              jk--;) S
LHL
(            }) S
LHL
(          }) S
LHL
(        }) S
PHL
(        ) S
LHL
(        SaveData=true;) S
LHL
(        StoreFilteredData\(MaxPlane\);) S
PHL
(        ) S
LHL
(        fTrackCand->fdS.clear\(\);) S
LHL
(        fTrackCand->fRange.clear\(\);) S
PHL
(        ) S
LHL
(        GoBackwards\(false\);) S
LHL
(        //Abhijit's Work. ADB 2015/05/06) S
LHL
(        //>>) S
LHL
(        // Extrapolating downwards) S
LHL
(        //Upward = 1 , Downward = 0) S
LHL
(        // cout<<"NIter FCorPCBackward "<<NIter<<endl;) S
LHL
(        if \(NIter == 4 \) {) S
LHL
(          FCorPCBackward = CheckFCPCUpOrDn\(x_k, 0, MinPlane, GoBackward\);) S
LHL
(          // cout<<"2FCorPCBackward "<<FCorPCBackward<<endl;) S
LHL
(          // cout<<"XXXXXXXXXXXXXXXXXX"<<endl;) S
LHL
(        }) S
LHL
(        //<< ) S
LHL
(        //Abhijit's Work ADB 2015/05/06) S
LHL
(        ResetCovarianceMatrix\(\);) S
PHL
(        ) S
LHL
(        if\(nint==0\)) S
LHL
(          x_k4_biased= x_k[4];) S
PHL
(        ) S
LHL
(        if \(\(nint == niteration || ndifchi==0\) && nint>1\) {) S
LHL
(          //int nextplane=100;) S
LHL
(          //bool GetPrediction=PredictedStateCov\(StateVector, MinPlane, nextplane, GoBackward,) S
SL
( Prediction, 0\);) S
LHL
(          bool ok1 = true;) S
LHL
(          if\(pAnalysis->isXtermOut==1\) {) S
LHL
(            if \(ok1\) {) S
2 W
(//GetPrediction) S
LHL
(              for \(int ij=0; ij<6; ij++\) {) S
LHL
(                cout <<ij<<" "<<StateVector[ij]<<" "<< Prediction[ij]<<endl;) S
LHL
(              }) S
LHL
(              cout <<" end "<< 1/StateVector[4]<<" "<<1/Prediction[4]<<endl;) S
LHL
(            }) S
LHL
(          }) S
LHL
(          break;) S
LHL
(        }) S
LHL
(        // if \(ndifchi==0\) break;) S
LHL
(      }) S
LHL
(    } else { // clusterfound) S
LHL
(      cout<<" PassTrack 3.1 " <<endl;) S
LHL
(      PassTrack=false;) S
LHL
(    }) S
LHL
(  } else {) S
LHL
16 W
(//    cout<<" Control iterations over a track for which ZDecreasesWithTime"<<") S
SL
(NIter "<<NIter<<endl;) S
LHL
(    // First iteration) S
LHL
(    NIter++;) S
PHL
(    ) S
LHL
(    // Vtx to End \(Backwards\)) S
LHL
(    SaveData=true;) S
LHL
16 W
(//) S
14 W
(cout <<"MaxPlane "<<MaxPlane<<endl;) S
LHL
(    StoreFilteredData\(MaxPlane\);) S
LHL
(    LastIteration=false;) S
PHL
(    ) S
LHL
(    GoBackwards\(false\);) S
LHL
(    ResetCovarianceMatrix\(\);) S
PHL
(    ) S
LHL
(    // ShowerStrips\(\);) S
EndPage
EndDSCPage
EndSheet

%%Page: 16 16
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 1077 def
/PageNumber 16 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
1170 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(    if\(SwimThroughShower==true\) {) S
LHL
(      RemoveTrkHitsInShw\(\);) S
LHL
(    }) S
LHL
(    // SwimThroughShower conditionally set to true only within ShowerStrips\(\) which is ) S
LHL
(    // never called. So, effectively, this command does nothing.) S
LHL
16 W
(//    cout <<"doubleLa "<<doubleLa<<endl;) S
LHL
(    for \(unsigned int ij=0; ij<doubleLa; ++ij\) {) S
LHL
(      FilteredData[ij].clear\(\);) S
LHL
(    }) S
PHL
LHL
16 W
(//) S
14 W
(cout <<"MinPlane "<<MinPlane<<endl;) S
LHL
(    StoreFilteredData\(MinPlane\);) S
PHL
(    ) S
LHL
(    // End to Vtx: Forwards) S
LHL
(    GoForwards\(false\);) S
PHL
(    ) S
LHL
(    if\(SwimThroughShower==true\) {) S
LHL
(      ShowerSwim\(\);) S
LHL
(    }) S
LHL
(    // SwimThroughShower conditionally set to true only within ShowerStrips\(\) which is ) S
LHL
(    // never called. So, effectively, this command does nothing.) S
PHL
(    ) S
LHL
(    ResetCovarianceMatrix\(\);) S
PHL
(    ) S
LHL
(    bool ClusterFound = true;) S
LHL
(    // GMAA FindTheStrips\(false\); // cth,false\);) S
LHL
(    // bool ClusterFound = FindTheStrips\(false\); // cth,false\);) S
LHL
(    // Second iteration) S
PHL
(    ) S
LHL
(    if\(ClusterFound==true\) {) S
LHL
(      // Guard against finding no strips) S
LHL
(      for\(int nint=0;nint<=niteration;nint++\) {) S
LHL
(        double chisq_new = fTrackCand->GetChi2\(\);) S
LHL
(        int ndof_new = fTrackCand->GetNDOF\(\);) S
LHL
(        if \(ndof_old == ndof_new && abs\(chisq_old - chisq_new\) < 0.01\) {) S
LHL
(          ndifchi=0;) S
LHL
(        }) S
LHL
(        ndof_old = ndof_new;) S
LHL
(        chisq_old = chisq_new;) S
PHL
(        ) S
LHL
(        NIter++;) S
PHL
(        ) S
LHL
(        if\(\(nint==niteration || ndifchi==0\) && nint>1\)) S
LHL
(          LastIteration = true;) S
PHL
(        ) S
LHL
(        if \(nint>0\)) S
LHL
(          GetFitData\(MinPlane,MaxPlane\);) S
PHL
(        ) S
LHL
(        if \(MinPlane > MaxPlane\) {) S
LHL
(          cout<<" PassTrack 3.2 " << MinPlane<< "<"<< MaxPlane<<endl;) S
LHL
(          PassTrack=false;) S
LHL
(          break;) S
LHL
(        }) S
PHL
(        ) S
LHL
(        SaveData=true;) S
26 W
(// Here Savedata was set to false) S
LHL
(        StoreFilteredData\(MaxPlane\);// This command was absent. It is introduced to keep parit) S
SL
(y with GF) S
PHL
(        ) S
LHL
(        fTrackCand->f2dS.clear\(\);) S
LHL
(        fTrackCand->f2Range.clear\(\);) S
PHL
(        ) S
LHL
(        // if \(nint==0\) { GoBackwards\(true\); } else { GoBackwards\(false\); }) S
PHL
(        ) S
LHL
(        GoBackwards\(true\);) S
LHL
(        //Abhijit's Work. ADB 2015/05/06) S
LHL
(        //>>) S
LHL
(        // Extrapolating downwards) S
LHL
(        //Upward = 1 , Downward = 0) S
LHL
(        // cout<<"NIter FCorPCBackward "<<NIter<<endl;) S
LHL
(        if \(NIter == 4 \) {) S
LHL
(          // cout<<"XXXXXXXXXXXXXXXXXX"<<endl;) S
LHL
(          FCorPCBackward = CheckFCPCUpOrDn\(x_k, 0, MinPlane, GoForward\);) S
LHL
(          // cout<<"-------------------------------"<<endl;) S
LHL
(          // cout<<"3FCorPCBackward "<<FCorPCBackward<<endl;) S
LHL
(        }) S
LHL
(        //<< ) S
LHL
(        //Abhijit's Work ADB 2015/05/06) S
LHL
(        ResetCovarianceMatrix\(\);) S
EndPage
EndDSCPage
EndSheet

%%Page: 17 17
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 1154 def
/PageNumber 17 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
1248 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(        ) S
LHL
(        // End to Vtx again) S
LHL
(        for \(unsigned int ij=0; ij<doubleLa; ++ij\) {) S
LHL
(          for \(unsigned jk=0; jk<FilteredData[ij].size\(\); jk++\) {) S
LHL
(            if \(FilteredData[ij][jk].x_k5==1\) {) S
LHL
(              FilteredData[ij].erase\(FilteredData[ij].begin\(\)+jk\);) S
LHL
(              jk--;) S
LHL
(            }) S
LHL
(          }) S
LHL
(        }) S
LHL
(        // if \(TrkClustsData[i].size\(\)>0\) FilteredData[i].clear\(\);}) S
LHL
(        // if\(nint==niteration || ndifchi==0 \)) S
PHL
(        ) S
LHL
(        SaveData=true;) S
LHL
(        StoreFilteredData\(MinPlane\);) S
PHL
(        ) S
LHL
(        fTrackCand->fdS.clear\(\);) S
LHL
(        fTrackCand->fRange.clear\(\);) S
PHL
(        ) S
LHL
(        GoForwards\(false\);) S
LHL
(        //Abhijit's Work. ADB 2015/05/06) S
LHL
(        //>>) S
LHL
(        // Extrapolating upwards) S
LHL
(        //Upward = 1 , Downward = 0) S
LHL
(        // cout<<"NIter FCorPCForward "<<NIter<<endl;) S
LHL
(        if \(NIter == 4 \) {) S
LHL
(          FCorPCForward = CheckFCPCUpOrDn\(x_k, 1, MaxPlane, GoBackward\);) S
LHL
(          // cout<<"4FCorPCForward "<<FCorPCForward<<endl;) S
LHL
(          // cout<<"XXXXXXXXXXXXXXXXXX"<<endl;) S
LHL
(        }) S
LHL
(        //<< ) S
LHL
(        //Abhijit's Work ADB 2015/05/06) S
PHL
(        ) S
LHL
(        ResetCovarianceMatrix\(\);) S
PHL
(        ) S
LHL
(        if\(nint==0\) {) S
LHL
(          x_k4_biased= x_k[4];) S
LHL
(        }) S
LHL
(        if \(\(nint == niteration || ndifchi==0 \)&&nint>1\) {) S
PHL
(          ) S
LHL
(          //GMA Move this prediction to new code) S
LHL
(          //) S
6 W
(int nextplane=100;) S
LHL
(          //bool GetPrediction=PredictedStateCov\(StateVector, MaxPlane, nextplane, GoForward, ) S
SL
(Prediction, 1\);) S
LHL
(          bool ok2 = true;) S
PHL
(          ) S
LHL
(          if\(pAnalysis->isXtermOut==1\) {) S
LHL
(            if \(ok2\) {) S
10 W
(//GetPrediction) S
LHL
(              for \(int ij=0; ij<6; ij++\) {) S
LHL
(                cout <<ij<<" "<<StateVector[ij]<<" "<< Prediction[ij]<<endl;) S
LHL
(              }) S
LHL
(              cout <<" endf "<< 1/StateVector[4]<<" "<<1/Prediction[4]<<endl;) S
LHL
(            }) S
LHL
(          }) S
LHL
(          break;) S
LHL
(        }) S
LHL
(        // if \(ndifchi==0\) break;) S
LHL
(      }) S
LHL
24 W
(double tmpmom =\(abs\(x_k_minus[4]\)>1.e-12\) ? 1/x_k_minus[4] : 0;) S
LHL
24 W
(//) S
22 W
(cout <<"MinXPlane " <<MinPlane<<" "<<MaxPlane<) S
SL
(<" "<<x_k_minus[0]<<" "<<x_k_minus[1]<<" "<<x_k_minus[2]<<" "<<x_k_minus[3]<<" "<<x_k_minus[4]) S
SL
(<<" "<<" "<<tmpmom<<endl;) S
LHL
24 W
(int NPlane=11;) S
LHL
24 W
(double ds=0;) S
LHL
24 W
(double drange=0;) S
LHL
24 W
(double xvtx_para[5] = {0.0};) S
LHL
24 W
(PredictedStateCov\(x_k_minus, MaxPlane, NPlane, GoBackward, xvtx_para, ) S
SL
(0, &ds, &drange\);) S
LHL
24 W
(tmpmom =\(abs\(xvtx_para[4]\)>1.e-12\) ? 1/xvtx_para[4] : 0;) S
LHL
24 W
(cout <<"extrapol "<<NPlane <<" "<<xvtx_para[0]<<" "<<xvtx_para[1]<<" ") S
SL
(<<xvtx_para[2]<<" "<<xvtx_para[3]<<" "<<xvtx_para[4]<<" "<<tmpmom<<" "<<ds<<" "<<drange<<" "<<) S
SL
(ZPosLayer[NPlane]<<endl;) S
LHL
24 W
(xvtx_parameter[0] = \(xvtx_para[4]!=0\) ? 1./xvtx_para[4] : -100;) S
LHL
24 W
(double dsdzvx = sqrt\(1.0 + xvtx_para[2]*xvtx_para[2] + xvtx_para[3]*xv) S
SL
(tx_para[3]\);) S
LHL
24 W
(xvtx_parameter[1] = acos\(-1./dsdzvx\);) S
LHL
24 W
(xvtx_parameter[2] = atan2\(-xvtx_para[3], -xvtx_para[2]\);) S
LHL
24 W
(xvtx_parameter[3] = xvtx_para[0];) S
EndPage
EndDSCPage
EndSheet

%%Page: 18 18
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 1225 def
/PageNumber 18 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
1326 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
24 W
(xvtx_parameter[4] = xvtx_para[1];) S
LHL
24 W
(xvtx_parameter[5] = ZPosLayer[NPlane];) S
LHL
(    } else {) S
LHL
(      cout<<" PassTrack 3.3 " << endl;) S
LHL
(      PassTrack=false;) S
LHL
(    }) S
LHL
(  }) S
PHL
(  ) S
LHL
(  // checkfcorpc = 0;) S
LHL
(  FCorPC = 0;) S
LHL
(  // G4int fcpc_tmp123 =0;) S
LHL
(  if\(NIter==4\) {) S
PHL
(    ) S
LHL
(    FCorPC = \(\(\(FCorPCBackward<<4\)&0x0ffff0\)|\(FCorPCForward&0x0f\)\);) S
LHL
(    // cout<<"FCorPC = "<<FCorPC<<", checkfcorpc = "<<checkfcorpc<<endl;) S
LHL
(    // cout<<" FCPC = "<<FCPC<<", FCorPC = "<<FCorPC<<", FCorPCForward = "<<FCorPCForward<<", ) S
SL
(FCorPCBackward = "<<FCorPCBackward<<endl;) S
LHL
(  }) S
LHL
(  // Organise the output) S
LHL
(  if\(pAnalysis->isXtermOut==1\) {) S
LHL
(    for \(int ij=MinPlane; ij<=MaxPlane; ij++\) {) S
LHL
(      for \(unsigned jk=0; jk<FilteredData[ij].size\(\); jk++\) {) S
LHL
(        cout<<"iMax "<<ij<<" "<<jk<<" "<<FilteredData[ij][jk].x_k5<<" "<<FilteredData[ij][jk].) S
SL
(x_k0<<" "<<FilteredData[ij][jk].x_k1<<" "<<FilteredData[ij][jk].x_k2<<" "<<FilteredData[ij][jk) S
SL
(].x_k3<<" "<<1./\(FilteredData[ij][jk].x_k4\)<<" "<<FilteredData[ij][jk].x_k5<<endl;) S
LHL
(      }) S
LHL
(    }) S
LHL
(  }) S
PHL
8 W
LHL
(  if\(pAnalysis->isXtermOut==1\) {) S
LHL
(    if \(MaxPlane >=0 && MaxPlane <int\(doubleLa\)\) {) S
LHL
(      cout<<endl;) S
LHL
(      //cout<<"-------------------------------------------------------------------"<<endl;) S
LHL
(      //cout<< " indx "<<" Pln no " <<"FilteredData.x_k5 "<<"x_k0 " << "x_k1 " << "x_k2 " << ") S
SL
(x_k3 " << "1./x_k4 "<< "x_k5 "<<endl;) S
LHL
(      cout<<endl;) S
LHL
(      for \(unsigned ij=0; ij<FilteredData[MaxPlane].size\(\); ij++\) {) S
LHL
(        cout<<"iMax "<<ij<<" "<<MaxPlane<<" "<<FilteredData[MaxPlane][ij].x_k5<<" "<<FilteredD) S
SL
(ata[MaxPlane][ij].x_k0<<" "<<FilteredData[MaxPlane][ij].x_k1<<" "<<FilteredData[MaxPlane][ij].) S
SL
(x_k2<<" "<<FilteredData[MaxPlane][ij].x_k3<<" "<<1./\(FilteredData[MaxPlane][ij].x_k4\)<<" "<<Fi) S
SL
(lteredData[MaxPlane][ij].x_k5<<endl;) S
LHL
(      }) S
LHL
(    }) S
LHL
(    if \(MinPlane >=0 && MinPlane <int\(doubleLa\)\) {) S
LHL
(      for \(unsigned ij=0; ij<FilteredData[MinPlane].size\(\); ij++\) {) S
LHL
(        cout<<"iMin "<<ij<<" "<<MinPlane<<" "<<FilteredData[MinPlane][ij].x_k5<<" "<<FilteredD) S
SL
(ata[MinPlane][ij].x_k0<<" "<<FilteredData[MinPlane][ij].x_k1<<" "<<FilteredData[MinPlane][ij].) S
SL
(x_k2<<" "<<FilteredData[MinPlane][ij].x_k3<<" "<<1./\(FilteredData[MinPlane][ij].x_k4\)<<" "<<Fi) S
SL
(lteredData[MinPlane][ij].x_k5<<endl;) S
LHL
(      }) S
LHL
(    }) S
LHL
(  }) S
PHL
(  ) S
LHL
(  double PI = 3.14159;) S
LHL
(  double theta = 0.00;) S
LHL
(  theta = \(180/PI\) * acos\(1/sqrt\(1+pow\(x_k[2],2\)+pow\(x_k[3],2\)\)\); //GMA 210625 Similarly for p) S
SL
(hi ?) S
LHL
(  if \(ZIncreasesWithTime==false\) {) S
LHL
(    theta = \(180/PI\) * acos\(-1.0/sqrt\(1+pow\(x_k[2],2\)+pow\(x_k[3],2\)\)\);) S
LHL
(  }) S
PHL
(  ) S
LHL
(  int n = 0;) S
LHL
(  InoTrack_Manager *ptrackCollection = InoTrack_Manager::APointer;) S
PHL
(  ) S
LHL
(  // If the fit was successful) S
LHL
(  // ChiSquare) S
2 W
(= 0; // ChiSquare;  //GMA14) S
LHL
(  // GPL) S
24 W
(= 0.5 * GPL;) S
LHL
(  // RNG) S
24 W
(= 0.5 * RNG;) S
LHL
(  // In equations above, the factor '0.5' comes to account for the double counting of forward ) S
SL
(and backward iteration) S
LHL
(  //  cout<<"GPL "<<GPL<<"     "<<"RNG "<<RNG<<endl;) S
PHL
(  ) S
LHL
(  // if\(ptrackCollection->InoTrack_list.size\(\) == 1 && x_k[4]!=0. && PassTrack==true\) {) S
LHL
(  n = ptrackCollection->InoTrack_list[0]->ClustsInTrack.size\(\);) S
PHL
(  ) S
LHL
(  // cout<<"----------------------------------------------------------------------------------) S
SL
(---------------------------------------"<<endl;) S
LHL
(  // cout<<"Reconstructed P = "<<1/x_k[4]<<"  |  "<<"theta "<<theta<<"  |  L "<<FinderPathLeng) S
EndPage
EndDSCPage
EndSheet

%%Page: 19 19
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 1289 def
/PageNumber 19 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
1404 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(th<<"  |  MaxPlane "<<MaxPlane<<"  |  MinPlane "<<MinPlane<<"  |  #hits "<<n<<"  |  chisq/dof ) S
SL
("<<ChiSquare/\(2*n-5\)<<endl;) S
LHL
(  // cout<<"----------------------------------------------------------------------------------) S
SL
(---------------------------------------"<<endl;) S
PHL
(  ) S
LHL
(  // cout<<"No. of hits for this track was "<<n<<"     "<<"MinPlane "<<MinPlane<<"     "<<"Max) S
SL
(Plane "<<MaxPlane<<endl;) S
LHL
(  //cout<<"ChiSquare/dof "<<ChiSquare/\(2*n-5\)<<endl;) S
PHL
(  ) S
LHL
8 W
(FillGapsInTrack\(\);) S
PHL
(  ) S
LHL
8 W
(bool FinalClusterFound = true; // GMA) S
LHL
8 W
(if\(FinalClusterFound==true\) {) S
LHL
16 W
(int NumInUView = fTrackCand->GetNPlane\(0\);) S
LHL
16 W
(int NumInVView = fTrackCand->GetNPlane\(1\);) S
PHL
(    ) S
LHL
(  //   //    cout <<"numview "<< NumInUView <<" "<<NumInVView<<" "<<fTrackCand->GetClusterEntr) S
SL
(ies\(\)<<endl;) S
LHL
(  //   //if\(\(ChiSquare/\(2*n-5\)\)<10 && \(ChiSquare/\(2*n-5\)\)>0.01 &&\(NumInUView>1 && NumInVView>1) S
SL
(\)\)) S
PHL
(    ) S
LHL
16 W
(if \(NumInUView>1 && NumInVView>1\)) S
7 W
({) S
LHL
24 W
(double inputx[6]={0};) S
LHL
24 W
(SetTrackProperties\(x_k, xvtx_parameter\); //cth\);) S
LHL
16 W
(} else {) S
LHL
24 W
(PassTrack=false;) S
LHL
16 W
(}) S
LHL
8 W
(} else { // Otherwise fail the track at this final stage) S
LHL
16 W
(cout<<" PassTrack 6" << endl;) S
LHL
16 W
(PassTrack=false;) S
LHL
8 W
(}) S
LHL
(  // // }) S
LHL
(  // // If the fit has failed \(e.g. q/p is zero and/or u, v are nonsense\)) S
LHL
(  // if\(x_k[4]==0. || PassTrack==false\) {) S
LHL
(  // }) S
PHL
(  ) S
LHL
(}) S
PHL
LHL
(void InoTrackFitAlg::RemoveTrkHitsInShw\(\) {) S
LHL
(  // If the 'clean' section of track is large enough, remove the track finding) S
LHL
(  // data for planes before the ShowerEntryPlane) S
LHL
(  if\(debug_fit\)  { cout <<"InoTrackFitAlg : RemoveTrkHitsInShw, Discard track finding data in ) S
SL
(shower" << endl;}) S
PHL
(  ) S
LHL
(  int NumTrackHitsLeft=0;) S
PHL
(  ) S
LHL
(  if\(ZIncreasesWithTime==true\) {) S
LHL
(    for\(int ij=ShowerEntryPlane; ij<=MaxPlane; ++ij\) {) S
LHL
(      if\(TrkClustsData[ij].size\(\)>0\) {NumTrackHitsLeft++;}) S
LHL
(    }) S
LHL
(  } else if\(ZIncreasesWithTime==false\) {) S
LHL
(    for\(int ij=MinPlane; ij<=ShowerEntryPlane; ++ij\) {) S
LHL
(      if\(TrkClustsData[ij].size\(\)>0\) {NumTrackHitsLeft++;}) S
LHL
(    }) S
LHL
(  }) S
PHL
(  ) S
LHL
(  // Carry out removal if there will be 6 or more strips left afterwards) S
LHL
(  if\(NumTrackHitsLeft>5\) { ) S
LHL
(    if\(ZIncreasesWithTime==true\) {) S
LHL
(      for\(int ij=MinPlane; ij<=ShowerEntryPlane; ++ij\) {TrkClustsData[ij].clear\(\);}) S
LHL
(    } else if\(ZIncreasesWithTime==false\) {) S
LHL
(      for\(int ij=ShowerEntryPlane; ij<=MaxPlane; ++ij\) {TrkClustsData[ij].clear\(\);    }) S
LHL
(    }) S
LHL
(  } else {  // Otherwise note that we should not run the ShowerSwim method) S
LHL
(    cout <<"InoTrackFitAlg : RemoveTrkHitsInShw, not enough hits after removal. Must use all f) S
SL
(inder data." << endl;) S
LHL
(    SwimThroughShower=false;) S
LHL
(  }) S
PHL
(  ) S
LHL
(  // Find the new max and min planes) S
LHL
(  MaxPlane=-20; MinPlane=5000;) S
LHL
(  for \(int ij=0; ij<\(int\)nLayer; ++ij\) {   ) S
LHL
(    if\(TrkClustsData[ij].size\(\)>0\) {) S
LHL
(      if\(ij>MaxPlane\) {MaxPlane=ij;}) S
LHL
(      if\(ij<MinPlane\) {MinPlane=ij;}) S
LHL
(    }) S
LHL
(  }) S
LHL
(}) S
EndPage
EndDSCPage
EndSheet

%%Page: 20 20
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 1360 def
/PageNumber 20 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
1482 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
LHL
( void InoTrackFitAlg::ShowerSwim\(\) {) S
LHL
(//   // Method is called if we have a large shower near the track vertex) S
LHL
(//   // The Swimmer is used to find the most likely track strip in the shower) S
LHL
(//   // and this strip is added to the fit) S
PHL
(  ) S
LHL
(//   if\(debug_fit\) {) S
LHL
(//     cout<<" =========================================================="<<endl;) S
LHL
(//     cout <<"InoTrackFitAlg : ShowerSwim, improved track finding in shower" << endl;) S
LHL
(//     cout<<" =========================================================="<<endl;) S
LHL
(//   }) S
LHL
(//   // Initialisations) S
LHL
(//   int Plane; int NewPlane;) S
LHL
(//   double StateVector[6]; double NState[6]; double x__minus[6];) S
LHL
(//   bool GoForward; bool SwimBack;) S
LHL
(//   int PlanesSinceLastHit=0;) S
LHL
(//   int PlaneView;) S
LHL
(//   int Increment;) S
PHL
(  ) S
LHL
(//   double StripXDistance=0; double StripYDistance=0;) S
LHL
(//   double MinXDistanceToStrip=999; double MinYDistanceToStrip=999.;) S
LHL
(//   //  double StripXWidth=2.00e-2; double StripYWidth=2.00e-2;// 4.108e-2;) S
PHL
(  ) S
LHL
(//   if\(ZIncreasesWithTime==true\) {) S
LHL
(//     GoForward=false; Plane=MinPlane; Increment=-1;) S
LHL
(//   } else {) S
LHL
(//     GoForward=true; Plane=MaxPlane; Increment=1;) S
LHL
(//   }) S
PHL
(  ) S
LHL
(//   NewPlane=Plane+Increment;) S
PHL
(  ) S
LHL
(//   // Continue until we reach a 4 plane window with no likely hit or we reach ) S
LHL
(//   // the end of the detector) S
PHL
(  ) S
LHL
(//   while\(PlanesSinceLastHit<4 && NewPlane>0 && NewPlane<=\(int\)nLayer-5\) {) S
LHL
(//     //145\) { //GMA Put those number from database) S
LHL
(//     if\(SlcClustData[NewPlane].size\(\)>0\) {) S
LHL
(//       PlaneView = SlcClustData[NewPlane][0].csh->GetView\(\);) S
LHL
(//       for\(int ij=0; ij<6; ++ij\) {) S
LHL
(//         StateVector[ij]=x_k_minus[ij];) S
LHL
(//       }) S
PHL
(      ) S
LHL
(//       SwimBack=Swim\(StateVector, NState, Plane, NewPlane, GoForward\);) S
PHL
(      ) S
LHL
(//       if\(!SwimBack\) {) S
LHL
(//         break;) S
LHL
(//       }) S
LHL
(//       for\(int ij=0; ij<6; ++ij\) {) S
LHL
(//         x_k[ij]=NState[ij];) S
LHL
(//       }) S
PHL
(      ) S
LHL
(//       // Find the closest strip \(within a distance 'MinDistanceToStrip'\) and) S
LHL
(//       // temporarily store CandStripHandle) S
LHL
(//       // Results are very sensitive to value of MinDistanceToStrip) S
PHL
(      ) S
LHL
(//       InoCluster* CurrentClust=0;) S
PHL
(      ) S
LHL
(//       //GMA Original 0.0055, but do not have much clue about it) S
LHL
(//       // Is it \(0.01*gap/stripwidth\) ? Then for INO it is 0.0426) S
LHL
(//       //Was put 0.0852 also why donot remember now \(30/01/08\)) S
PHL
(      ) S
LHL
(//       MinXDistanceToStrip=\(1.5*StripXWidth\)+ fabs\(0.0055*x_k[2]\); //Original) S
LHL
(//       MinYDistanceToStrip=\(1.5*StripYWidth\)+ fabs\(0.0055*x_k[3]\);) S
PHL
(      ) S
LHL
(//       for\(unsigned int j=0; j<SlcClustData[NewPlane].size\(\); ++j\) {) S
LHL
(//         if \(PlaneView%2==0\) StripXDistance=fabs\(SlcClustData[NewPlane][j].csh->GetXPos\(\)-x_) S
SL
(k[0]\);) S
LHL
(//         if \(PlaneView>0\) StripYDistance=fabs\(SlcClustData[NewPlane][j].csh->GetYPos\(\)-x_k[1) S
SL
(]\);) S
PHL
(        ) S
LHL
(//         if\(StripXDistance<MinXDistanceToStrip && StripYDistance<MinYDistanceToStrip\) {) S
LHL
(//           if \(PlaneView%2==0\) MinXDistanceToStrip=StripXDistance;) S
LHL
(//           if \(PlaneView>0\)    MinYDistanceToStrip=StripYDistance;) S
LHL
(//           CurrentClust=SlcClustData[NewPlane][j].csh;) S
LHL
(//         }) S
LHL
(//       }) S
PHL
(      ) S
LHL
(//       // If we find a likely track strip, add it to the fit data and call the Kalman) S
EndPage
EndDSCPage
EndSheet

%%Page: 21 21
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 1436 def
/PageNumber 21 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
1560 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(//       // update equations before repeating process to find next track strips in the shower) S
LHL
(//       //      cout <<"CurrentClust "<<int\(CurrentClust\)<<" "<<NewPlane<<" "<<SlcClustData[N) S
SL
(ewPlane].size\(\)<<endl;) S
LHL
(//       //      cout <<"CurrentClust  "<<NewPlane<<" "<<SlcClustData[NewPlane].size\(\)<<endl;) S
LHL
(//       if\(CurrentClust\) {) S
LHL
(//         ClustStruct temp;) S
LHL
(//         temp.csh = CurrentClust;) S
LHL
(//         InitTrkClustData[NewPlane].push_back\(temp\);) S
PHL
(        ) S
LHL
(//         // Convert the strip to data required for Kalman fit) S
LHL
(//         GetFitData\(NewPlane,NewPlane\);) S
PHL
(        ) S
LHL
(//         // Carry out the Kalman fit) S
LHL
(//         for \(int ij=0; ij<2; ij++\) {) S
LHL
(//           for \(int jk=0; jk<5; jk++\) {) S
LHL
(//             H_k[ij][jk]=0;) S
LHL
(//           }) S
LHL
(//         }) S
LHL
(//         if \(PlaneView%2==0\) {) S
LHL
(//           H_k[0][0]=1;) S
LHL
(//         }) S
LHL
(//         if \(PlaneView>0\) {) S
LHL
(//           H_k[1][1]=1;) S
LHL
(//         }) S
LHL
(//         //) S
5 W
(cout <<"InoTrackFitAlg.Showerswim : WARNING : PlaneView for hits is not matc) S
SL
(hing with 0/1/2"<<endl;) S
PHL
(        ) S
PHL
(        ) S
LHL
(//         // bool CombiPropagatorOk=GetCombiPropagator\(Plane,NewPlane,GoForward\);) S
LHL
(//         bool CombiPropagatorOk = 1;) S
LHL
(//         if\(CombiPropagatorOk\) {) S
PHL
(          ) S
LHL
(//           //GetMultipleScattering\(istate,dz,eloss\);) S
LHL
(//           //GetEnergyLoss\(istate,dz\);) S
LHL
(//           //ExtrapolatedCovariance\(ifmultiplescattering\);) S
LHL
(//           //cout<<"State Vector \(1st\): "<<StateVector[0]<<") S
2 W
("<<StateVector[1]<<") S
4 W
("<<Sta) S
SL
(teVector[2]<<") S
4 W
("<<StateVector[3]<<") S
4 W
("<<StateVector[4]<<") S
4 W
("<<StateVector[5]<<") S
4 W
("<<e) S
SL
(ndl;) S
LHL
(//           ds = 0.0;) S
LHL
(//           drange = 0.0;) S
LHL
(//           PredictedStateCov\(x_k_minus,Plane,NewPlane, GoForward, x__minus, 0, &ds, &drange\)) S
SL
(;) S
LHL
(//           CalcKalmanGain\(x__minus,NewPlane\);) S
LHL
(//           //UpdateStateVector\(i,NewPlane,direction\); //true\);) S
LHL
(//           KalmanFilterStateVector\(x__minus, Plane, GoForward,x_k\);) S
LHL
(//           //UpdateStateVector\(Plane,NewPlane,true\);) S
LHL
(//           UpdateCovMatrix\(NewPlane\);) S
LHL
(//           MoveArrays\(NewPlane,GoForward\);) S
PHL
(          ) S
PHL
(          ) S
LHL
(//           StoreFilteredData\(NewPlane\);) S
PHL
(          ) S
LHL
(//           if\(ZIncreasesWithTime\) {) S
LHL
(//             MinPlane=NewPlane;) S
LHL
(//             Plane=MinPlane;) S
LHL
(//           } else {) S
LHL
(//             MaxPlane=NewPlane;) S
LHL
(//             Plane=MaxPlane;) S
LHL
(//           }) S
LHL
(//           NewPlane=Plane+Increment;) S
PHL
(          ) S
LHL
(//           PlanesSinceLastHit=0;) S
LHL
(//         }) S
LHL
(//       } else {) S
LHL
(//         NewPlane+=Increment; PlanesSinceLastHit++;) S
LHL
(//       }) S
LHL
(//     } else {) S
LHL
(//       NewPlane+=Increment; PlanesSinceLastHit++;) S
LHL
(//     }) S
LHL
(//   }) S
LHL
(//   // Note that shower swim is complete) S
LHL
(//   SwimThroughShower=false; //GMA why false ?) S
LHL
( }) S
PHL
LHL
(void InoTrackFitAlg::GetFitData\(int& Plane1, int& Plane2\) {) S
LHL
(  // Loop over the initial track strip data and create the final data for fitting) S
LHL
(  if\(debug_fit\) { cout <<"InoTrackFitAlg : GetFitData "<<"Plane1 "<<Plane1<<" Plane2 "<<Plane2) S
SL
(<<endl;}) S
EndPage
EndDSCPage
EndSheet

%%Page: 22 22
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 1508 def
/PageNumber 22 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
1638 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  ) S
LHL
(  // Initialsmislaiisations) S
LHL
(  double MisalignmentError=0.0; //2.5e-5; //  double MisalignmentError=1e-8; //1e-6; //1e-4; /) S
SL
(/4e-4; //1e-8; //4e-6;  // GMA need number from INO : Squared error for misalignment of strips) S
PHL
(  ) S
LHL
(  Plane1=10000;) S
LHL
(  Plane2 = -20;) S
LHL
(  fTrackCand->ClustsInTrack.clear\(\);) S
LHL
(  //cout<<"doubleLa = "<<doubleLa<<endl;) S
LHL
(  for \(unsigned int ij=0; ij<doubleLa; ++ij\) {) S
LHL
(    InitTrkClustData[ij].clear\(\);) S
LHL
(    TrkClustsData[ij].clear\(\);) S
LHL
(  }) S
PHL
(  ) S
LHL
(  for \(unsigned ijk=0; ijk<doubleLa; ijk++\) {) S
LHL
(    if \(FilteredData[ijk].size\(\)==0\)) S
LHL
(      continue;) S
LHL
(    // cout <<"ijlayer "<<ijk<<" "<<FilteredData[ijk].size\(\)<<endl;) S
PHL
(    ) S
LHL
(    for \(unsigned ij=0; ij<FilteredData[ijk].size\(\); ij++\) {) S
LHL
(      double x1 = FilteredData[ijk][ij].x_k0;) S
LHL
(      double y1 = FilteredData[ijk][ij].x_k1;) S
LHL
(      // cout<<"x1 = "<<x1<<"     "<<"y1 = "<<y1<<"     "<<"shiftLa = "<<shiftLa<<endl;) S
LHL
(      int jk = \(ijk >=shiftLa\) ? ijk-shiftLa : ijk;) S
PHL
(      ) S
LHL
(      double dmn = 0.07; //Maximum 10 cm               asm: note this 270711) S
LHL
(      int klx = -1;) S
PHL
(      ) S
LHL
(      for\(unsigned int kl=0; kl<SlcClustData[jk].size\(\); ++kl\) {) S
LHL
32 W
(double dx = fabs\(SlcClustData[jk][kl].csh->GetXPos\(\)-x1\); // /) S
SL
(SlcClustData[jk][kl].csh->GetXPosErr\(\);) S
LHL
32 W
(double dy = fabs\(SlcClustData[jk][kl].csh->GetYPos\(\)-y1\); // /) S
SL
(SlcClustData[jk][kl].csh->GetYPosErr\(\);) S
LHL
32 W
(if \(dmn > pow\(dx*dx+dy*dy,0.5\)\) {) S
LHL
40 W
(dmn = pow\(dx*dx+dy*dy,0.5\);) S
LHL
40 W
(klx=kl;) S
LHL
32 W
(}) S
LHL
(      }) S
PHL
(      ) S
LHL
(      if \(klx>=0\) {) S
LHL
32 W
(fTrackCand->ClustsInTrack.push_back\(SlcClustData[jk][klx].csh\)) S
SL
(;) S
LHL
32 W
(// InitTrkClustData[jk].push_back\(SlcClustData[jk][klx]\);) S
LHL
32 W
(// const InoCluster* tempcls = SlcClustData[jk][klx].csh;) S
PHL
32 W
LHL
32 W
(int TrackPlane= SlcClustData[jk][klx].csh->GetZPlane\(\);) S
LHL
32 W
(TrkDataStruct tempdata;) S
LHL
32 W
(tempdata.numInList = fTrackCand->GetClusterEntries\(\)-1;) S
PHL
32 W
LHL
32 W
(tempdata.cltime =SlcClustData[jk][klx].csh->GetTime\(\);) S
LHL
32 W
(tempdata.ZPos=ZPosLayer[TrackPlane];) S
LHL
32 W
(tempdata.PlaneView =  SlcClustData[jk][klx].csh->GetView\(\);) S
LHL
32 W
(tempdata.XPos=  SlcClustData[jk][klx].csh->GetXPos\(\);) S
LHL
32 W
(tempdata.XPosErrSq = pow\(SlcClustData[jk][klx].csh->GetXPosErr) S
SL
(\(\),2.0\) + MisalignmentError; //  + XposErrorSq; // pow\(temp.csh->GetXPosErr\(\),2.0\);) S
LHL
32 W
(tempdata.YPos= SlcClustData[jk][klx].csh->GetYPos\(\);) S
LHL
32 W
(tempdata.YPosErrSq = pow\(SlcClustData[jk][klx].csh->GetYPosErr) S
SL
(\(\),2.0\) + MisalignmentError ; // + YposErrorSq; // pow\(temp.csh->GetYPosErr\(\),2.0\);) S
PHL
32 W
LHL
32 W
(//) S
30 W
(cout <<"tmpdata "<< jk<<" "<< ) S
SL
(klx<<" "<<tempdata.cltime <<" "<<SlcClustData[jk][klx].csh->GetTime\(\)<<" "<<tempdata.XPos<<" ") S
SL
(<<tempdata.YPos<<" "<<tempdata.ZPos<< endl;) S
PHL
32 W
LHL
32 W
(tempdata.Straight = FilteredData[ijk][ij].x_k6;) S
LHL
32 W
(int ishift = \(FilteredData[ijk][ij].x_k6\) ? 0 : shiftLa;) S
LHL
32 W
(TrkClustsData[TrackPlane+ishift].push_back\(tempdata\);) S
LHL
32 W
(InitTrkClustData[jk+ishift].push_back\(SlcClustData[jk][klx]\);) S
LHL
32 W
(if \(ishift >0\) {) S
LHL
40 W
(SlcClustData[jk][klx].csh->SetStraight\(false\);) S
LHL
32 W
(} else {) S
LHL
40 W
(SlcClustData[jk][klx].csh->SetStraight\(true\);) S
LHL
32 W
(}) S
PHL
32 W
LHL
32 W
(// TrkClustsData[TrackPlane].push_back\(tempdata\);) S
LHL
32 W
(// cout <<"TrackPlane1 "<< TrackPlane<<" "<<Plane1<<" "<<Plane) S
SL
(2<<endl;) S
LHL
32 W
(// cout<<"ishift = "<<ishift<<endl;) S
LHL
32 W
(if \(TrackPlane>Plane2 && ishift==0\) Plane2 = TrackPlane;) S
EndPage
EndDSCPage
EndSheet

%%Page: 23 23
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 1577 def
/PageNumber 23 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
1716 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
32 W
(if \(TrackPlane<Plane1 && ishift==0\) Plane1 = TrackPlane;) S
LHL
32 W
(//) S
30 W
(cout <<"TrackPlane2 "<< TrackP) S
SL
(lane<<" "<<Plane1<<" "<<Plane2<<endl;) S
LHL
(      } else {) S
LHL
32 W
(// FilteredData[ijk].clear\(\);) S
LHL
32 W
(FilteredData[ijk].erase\(FilteredData[ijk].begin\(\)+ij\);) S
LHL
32 W
(ij-- ;) S
LHL
(      }) S
LHL
(    }) S
LHL
(  }) S
LHL
(}) S
PHL
LHL
(void InoTrackFitAlg::FillGapsInTrack\(\) {) S
LHL
(  // If there is no filtered data for a plane \(between MinPlane and MaxPlane\),) S
LHL
(  // but this plane has hits in the slice, we interpolate from the nearest ) S
LHL
(  // state vectors) S
LHL
(  //) S
LHL
(  // As with all filtered data, the interpolated data will be compared to) S
LHL
(  // strip positions in the FindTheStrips method) S
LHL
(  if \(debug_fit\) { cout <<"InoTrackFitAlg :: FillGapsInTrack" << endl;}) S
PHL
(  ) S
LHL
(  int CurrentPlane; int ForwardsPlane; int BackwardsPlane;) S
LHL
(  int Plane; int NewPlane;  bool GoForward;) S
LHL
(  double StateVector[6]; double Prediction[6]; bool GetPrediction;) S
PHL
(  ) S
LHL
(  for \(int ij=MinPlane; ij<=MaxPlane; ++ij\) {) S
LHL
(    if\(SlcClustData[ij].size\(\)>0\) {) S
LHL
(      if\(FilteredData[ij].size\(\)==0\) {) S
LHL
8 W
(// Find nearest filtered state vectors \(within two planes\) and ZPos differences) S
LHL
8 W
(// Forwards) S
LHL
8 W
(CurrentPlane=ij+1; ForwardsPlane=-99;) S
LHL
8 W
(while\(CurrentPlane<=MaxPlane && CurrentPlane<=\(ij+2\)\) {) S
LHL
10 W
(if\(FilteredData[CurrentPlane].size\(\)>0\) {) S
LHL
12 W
(ForwardsPlane=CurrentPlane; break;) S
LHL
10 W
(} else {) S
LHL
12 W
(CurrentPlane++;) S
LHL
10 W
(}) S
LHL
8 W
(}) S
PHL
8 W
LHL
8 W
(// Backwards) S
LHL
8 W
(CurrentPlane=ij-1; BackwardsPlane=-99;) S
PHL
8 W
LHL
8 W
(while\(CurrentPlane>=MinPlane && CurrentPlane>=\(ij-2\) \) {) S
LHL
10 W
(if\(FilteredData[CurrentPlane].size\(\)>0\) {) S
LHL
12 W
(BackwardsPlane=CurrentPlane; break;) S
LHL
10 W
(} else {) S
LHL
12 W
(CurrentPlane--;) S
LHL
10 W
(}) S
LHL
8 W
(}) S
PHL
8 W
LHL
8 W
(// Find and store possible new filtered data, range and dS) S
LHL
8 W
(if\(ForwardsPlane!=-99 && BackwardsPlane!=-99\) {) S
LHL
10 W
(// Swimmer method) S
LHL
10 W
(GetPrediction=false;) S
LHL
10 W
(NewPlane=ij;) S
LHL
10 W
(if\(ZIncreasesWithTime==true\) {Plane=ForwardsPlane; GoForward=false;}) S
LHL
10 W
(else{Plane=BackwardsPlane; GoForward=true;}) S
LHL
10 W
(if\(FilteredData[Plane].size\(\)>0\) {) S
LHL
12 W
(StateVector[0] = FilteredData[Plane][0].x_k0;) S
LHL
12 W
(StateVector[1] = FilteredData[Plane][0].x_k1;) S
LHL
12 W
(StateVector[2] = FilteredData[Plane][0].x_k2;) S
LHL
12 W
(StateVector[3] = FilteredData[Plane][0].x_k3;) S
LHL
12 W
(StateVector[4] = FilteredData[Plane][0].x_k4;) S
LHL
12 W
(StateVector[5] = \(double\)FilteredData[Plane][0].x_k5;) S
LHL
12 W
(GetPrediction=Swim\(StateVector, Prediction, Plane, NewPlane, GoForward\);) S
PHL
12 W
LHL
12 W
(if\(GetPrediction==true\) {) S
LHL
14 W
(// Store possible new state vector) S
LHL
14 W
(FiltDataStruct temp;) S
LHL
14 W
(temp.x_k0 = Prediction[0];) S
LHL
14 W
(temp.x_k1 = Prediction[1];) S
LHL
14 W
(temp.x_k2 = Prediction[2];) S
LHL
14 W
(temp.x_k3 = Prediction[3];) S
LHL
14 W
(temp.x_k4 = Prediction[4];) S
LHL
14 W
(temp.x_k5 = int\(Prediction[5]\);) S
LHL
14 W
(temp.x_k6 = true; //11Nov2009) S
LHL
14 W
(// FilteredData[ij].clear\(\); // 110809) S
LHL
14 W
(FilteredData[ij].push_back\(temp\);) S
EndPage
EndDSCPage
EndSheet

%%Page: 24 24
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 1654 def
/PageNumber 24 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
1794 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
12 W
(}) S
LHL
10 W
(}) S
LHL
8 W
(}) S
LHL
(      }) S
LHL
(    }) S
LHL
(  }) S
LHL
(}) S
PHL
LHL
(bool InoTrackFitAlg::Swim\(double* StateVector, double* Output, const int Plane, ) S
LHL
(                          const int NewPlane,const bool GoForward, double* dS, double* Range, ) S
SL
(double* dE\) {) S
PHL
(  ) S
LHL
(  if\(debug_fit\) {cout <<" InoTrackFitAlg : Swim "<< Plane<<" "<<NewPlane<<endl;}) S
PHL
(  ) S
LHL
(  // Initialisations) S
LHL
(  // customize for bfield scaling.) S
LHL
(  //  BField * bf = new BField\(*vldc,-1,0\);) S
LHL
(  SwimSwimmer* myswimmer = new SwimSwimmer\(fabs\(LayerThickness*\(Plane-NewPlane\)\), 0.5*LayerThi) S
SL
(ckness\); //*vldc,bf\);) S
LHL
(  if\(debug_fit\) { cout <<" InoTrackFitAlg : Swim "<< Plane<<" "<<NewPlane<<endl;}) S
PHL
(  ) S
LHL
(  //  if\(UseGeoSwimmer\) GeoSwimmer::Instance\(\)->Initialize\(*vldc\);) S
PHL
(  ) S
LHL
(  //  double invSqrt2 = pow\(1./2.,0.5\);) S
LHL
(  double charge = 0.;) S
LHL
(  bool done = false;) S
PHL
(  ) S
LHL
(  if\(fabs\(StateVector[4]\)>1.e-10\) {) S
PHL
(    ) S
LHL
(    double modp = fabs\(1./StateVector[4]\);) S
PHL
(    ) S
LHL
(    // Fix, to account for fact the cosmic muons could move in direction of negative z) S
LHL
(    if\(ZIncreasesWithTime==false\) {modp=-modp;}) S
PHL
(    ) S
LHL
(    double dsdz = pow\(\(1.+pow\(StateVector[2],2\)+pow\(StateVector[3],2\)\),0.5\);) S
PHL
(    ) S
LHL
(    double angle = 0;) S
LHL
(    double ct=cos\(angle\);) S
LHL
(    double st=sin\(angle\);) S
PHL
(    ) S
LHL
(    //    double dxdz = invSqrt2*\(StateVector[2]-StateVector[3]\);) S
LHL
(    //    double dydz = invSqrt2*\(StateVector[2]+StateVector[3]\);) S
LHL
(    double dxdz = ct*StateVector[2]-st*StateVector[3];) S
LHL
(    double dydz = st*StateVector[2]+ct*StateVector[3];) S
PHL
(    ) S
LHL
(    // Set up current muon details) S
LHL
(    if\(StateVector[4]>0.\) charge = 1.;) S
LHL
(    else if\(StateVector[4]<0.\) charge = -1.;) S
PHL
(    ) S
LHL
(    TVector3 position\(ct*StateVector[0]-st*StateVector[1],) S
LHL
(                      st*StateVector[0]+ct*StateVector[1],) S
LHL
(                      ZPosLayer[Plane]\); //SlcClustData[Plane][0].csh->GetZPos\(\)\);) S
PHL
LHL
(    TVector3 momentum\(modp*\(dxdz/dsdz\),) S
LHL
(                      modp*\(dydz/dsdz\),) S
LHL
(                      modp/dsdz\);) S
PHL
LHL
(    //    TVector3 bfield = bf->GetBField\(position\);) S
LHL
(    //TVector3 bfield\(1.,1.,0.\); //GMA-magnetic field  //AAR: commented out) S
LHL
(    //    TVector3 bfield\(1.5,0.,0.\); //GMA-magnetic field) S
LHL
(    //bave += TMath::Sqrt\(bfield[0]*bfield[0]+bfield[1]*bfield[1]+bfield[2]*bfield[2]\); //AAR:) S
SL
( commented out) S
LHL
(    //    bave += pow\(bfield[0]*bfield[0]+bfield[1]*bfield[1]+bfield[2]*bfield[2],0.5\);) S
PHL
LHL
(    //nbfield++;   //AAR: commented out) S
PHL
(    ) S
LHL
(    SwimParticle muon\(position,momentum\);) S
LHL
(    muon.SetCharge\(charge\);) S
LHL
(    //    cout <<"charge === "<<charge<<" "<<momentum.X\(\)<<" "<<momentum.Y\(\)<<" "<<momentum.Z\() S
SL
(\)<<" "<<position.X\(\)<<" "<<position.Y\(\)<<" "<<position.Z\(\)<<" "<<dxdz<<" "<<dydz<<" "<<dsdz<<") S
SL
( st "<<StateVector[0]<<" "<<StateVector[1]<<" "<<StateVector[2]<<" "<<StateVector[3]<<" "<<Sta) S
SL
(teVector[4]<<" "<<muon.GetMomentum\(\).Z\(\)<<endl;) S
PHL
(    ) S
LHL
(    //GMA    SwimZCondition zc\(ZPosLayer[NewPlane]\); //SlcClustData[NewPlane][0].csh->GetZPos\() S
SL
(\)\);) S
LHL
(    // Do the swim, accounting for direction of motion w.r.t time too) S
LHL
(    if\( \(GoForward==true && ZIncreasesWithTime==true\)  || \(GoForward==false && ZIncreasesWithT) S
SL
(ime==false\) \) {) S
EndPage
EndDSCPage
EndSheet

%%Page: 25 25
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 1724 def
/PageNumber 25 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
1872 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(      if\(UseGeoSwimmer\) {) S
LHL
(        //        done = GeoSwimmer::Instance\(\)->SwimForward\(muon,ZPosLayer[NewPlane]\); //SlcC) S
SL
(lustData[NewPlane][0].csh->GetZPos\(\)\);) S
LHL
(      } else {) S
LHL
(        done = myswimmer->SwimForward\(muon,t_bave\);) S
LHL
(      }) S
LHL
(    } else if\( \(GoForward==true && ZIncreasesWithTime==false\)  || \(GoForward==false && ZIncrea) S
SL
(sesWithTime==true\) \) {) S
LHL
(      if\(UseGeoSwimmer\) {) S
LHL
(        //        done = GeoSwimmer::Instance\(\)->SwimBackward\(muon,ZPosLayer[NewPlane]\); //Slc) S
SL
(ClustData[NewPlane][0].csh->GetZPos\(\)\);) S
LHL
(      } else {) S
LHL
(        done = myswimmer->SwimBackward\(muon,t_bave\);) S
LHL
(      }) S
LHL
(    }) S
PHL
(    ) S
PHL
(    ) S
LHL
(    bave += t_bave;  //AAR:  added) S
LHL
(    nbfield++;       //AAR:  added) S
LHL
(    if\(done==true\) {) S
PHL
(      ) S
LHL
(      if\(muon.GetDirection\(\).Z\(\)!=0. && muon.GetMomentumModulus\(\)!=0.\) {) S
LHL
(        angle = 0;) S
LHL
(        ct=cos\(angle\);) S
LHL
(        st=sin\(angle\);) S
LHL
(        Output[0]=\(st*muon.GetPosition\(\).Y\(\)+ct*muon.GetPosition\(\).X\(\)\);) S
LHL
(        Output[1]=\(ct*muon.GetPosition\(\).Y\(\)-st*muon.GetPosition\(\).X\(\)\);) S
LHL
(        Output[2]=\(st*\(muon.GetDirection\(\).Y\(\)/muon.GetDirection\(\).Z\(\)\)+ct*\(muon.GetDirection\() S
SL
(\).X\(\)/muon.GetDirection\(\).Z\(\)\)\);) S
LHL
(        Output[3]=\(ct*\(muon.GetDirection\(\).Y\(\)/muon.GetDirection\(\).Z\(\)\)-st*\(muon.GetDirection\() S
SL
(\).X\(\)/muon.GetDirection\(\).Z\(\)\)\);) S
LHL
(        Output[4]=muon.GetCharge\(\)/muon.GetMomentumModulus\(\);) S
PHL
8 W
LHL
(        Output[5]= StateVector[5];) S
LHL
(        // Get range and dS from the Swimmer) S
LHL
(        if\(dS\) {*dS=muon.GetS\(\);} ) S
LHL
(        if\(Range\) {*Range=muon.GetRange\(\);} ) S
LHL
(        if\(dE\){*dE=muon.GetMomentumModulus\(\)-momentum.Mag\(\);} ) S
PHL
(        ) S
LHL
(        //GMA put this more elegantly) S
LHL
(        fTrackCand->fdS[NewPlane] =muon.GetS\(\);) S
LHL
(        fTrackCand->fRange[NewPlane] =muon.GetRange\(\);) S
PHL
(        ) S
LHL
(      } else {done=false;}) S
LHL
(    }) S
PHL
(    ) S
LHL
(  } else {) S
LHL
(    // If infinite momentum, use straight line extrapolation) S
LHL
(    double delz = LayerThickness;) S
LHL
(    //    cout <<"delz "<< delz<<endl;) S
LHL
(    if \(SlcClustData[NewPlane].size\(\)>0 && SlcClustData[Plane].size\(\)>0\) {) S
LHL
(      //      delz = \(SlcClustData[NewPlane][0].csh->GetZPos\(\)-SlcClustData[Plane][0].csh->Get) S
SL
(ZPos\(\)\);) S
LHL
(      delz = ZPosLayer[NewPlane] - ZPosLayer[Plane];) S
LHL
(    }) S
PHL
(    ) S
LHL
(    //    cout <<"delz "<< delz<<endl;) S
PHL
(    ) S
LHL
(    Output[0]=StateVector[0] + StateVector[2]*delz;) S
LHL
(    Output[1]=StateVector[1] + StateVector[3]*delz;) S
LHL
(    Output[2]=StateVector[2];) S
LHL
(    Output[3]=StateVector[3];) S
LHL
(    Output[4]=StateVector[4];) S
LHL
(    Output[5]=StateVector[5];) S
PHL
LHL
(    done=true;) S
LHL
(  }) S
LHL
(  //cout <<" Input S1 "<< StateVector[0]<<" "<<StateVector[1]<<" "<<StateVector[2]<<" "<<State) S
SL
(Vector[3]<<" "<<StateVector[4]<<endl;) S
LHL
(  //cout <<" Output S1 "<< Output[0]<<" "<<Output[1]<<" "<<Output[2]<<" "<<Output[3]<<" "<<Out) S
SL
(put[4]<<endl;) S
LHL
(  delete myswimmer;) S
LHL
(  //  delete bf;) S
LHL
(  return done;) S
LHL
(}) S
PHL
PHL
LHL
(bool InoTrackFitAlg::Swim\(double* StateVector, double* Output, const int Plane, ) S
EndPage
EndDSCPage
EndSheet

%%Page: 26 26
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 1794 def
/PageNumber 26 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
1950 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(                          const double zend, const bool GoForward, double* dS, double* Range, ) S
SL
(double* dE\) {) S
PHL
(  ) S
LHL
(  SwimSwimmer* myswimmer = new SwimSwimmer\(zend, 0.5*LayerThickness\); //*vldc,bf\);) S
PHL
(  ) S
LHL
(  double charge = 0.;) S
LHL
(  bool done = false;) S
PHL
(    ) S
LHL
(  if\(fabs\(StateVector[4]\)>1.e-10\) {) S
LHL
(    double modp = fabs\(1./StateVector[4]\);) S
PHL
(    ) S
LHL
(    if\(ZIncreasesWithTime==false\) {modp=-modp;}) S
PHL
(    ) S
LHL
(    double dsdz = pow\(\(1.+pow\(StateVector[2],2\)+pow\(StateVector[3],2\)\),0.5\);) S
PHL
LHL
(    double angle = 0;) S
LHL
(    double ct=cos\(angle\);) S
LHL
(    double st=sin\(angle\);) S
PHL
LHL
(    double dxdz = ct*StateVector[2]-st*StateVector[3];) S
LHL
(    double dydz = st*StateVector[2]+ct*StateVector[3];) S
PHL
LHL
(    // Set up current muon details) S
LHL
(    if\(StateVector[4]>0.\) charge = 1.;) S
LHL
(    else if\(StateVector[4]<0.\) charge = -1.;) S
PHL
(    ) S
LHL
(    TVector3 position\(ct*StateVector[0]-st*StateVector[1],) S
LHL
(                      st*StateVector[0]+ct*StateVector[1],) S
LHL
(                      ZPosLayer[Plane]\); //SlcClustData[Plane][0].csh->GetZPos\(\)\);) S
PHL
LHL
(    TVector3 momentum\(modp*\(dxdz/dsdz\),) S
LHL
(                      modp*\(dydz/dsdz\),) S
LHL
(                      modp/dsdz\);) S
PHL
LHL
(    //TVector3 bfield\(1.,1.,0.\); //GMA-magnetic field  //AAR  commented out) S
LHL
(    //    TVector3 bfield\(1.5,0.,0.\); //GMA-magnetic field) S
LHL
(    //bave += //TMath::Sqrt\(bfield[0]*bfield[0]+bfield[1]*bfield[1]+bfield[2]*bfield[2]\); //AA) S
SL
(R commented out) S
LHL
(    //    bave += pow\(bfield[0]*bfield[0]+bfield[1]*bfield[1]+bfield[2]*bfield[2],0.5\);) S
LHL
(    //nbfield++; //AAR commented out) S
PHL
LHL
(    SwimParticle muon\(position,momentum\);) S
LHL
(    muon.SetCharge\(charge\);) S
PHL
LHL
(    //GMA    SwimZCondition zc\(ZPosLayer[NewPlane]\); //SlcClustData[NewPlane][0].csh->GetZPos\() S
SL
(\)\);) S
LHL
(    // Do the swim, accounting for direction of motion w.r.t time too) S
LHL
(    if\( \(GoForward==true && ZIncreasesWithTime==true\)  || \(GoForward==false && ZIncreasesWithT) S
SL
(ime==false\) \) {) S
LHL
(      done = myswimmer->SwimForward\(muon,t_bave\);) S
LHL
(    }) S
LHL
(    else if\( \(GoForward==true && ZIncreasesWithTime==false\)  || \(GoForward==false && ZIncrease) S
SL
(sWithTime==true\) \) {) S
LHL
(      done = myswimmer->SwimBackward\(muon,t_bave\);) S
LHL
(    }) S
LHL
(    bave += t_bave;  //AAR:  added) S
LHL
(    nbfield++;       //AAR:  added) S
LHL
(    if\(done==true\) {) S
LHL
(      if\(muon.GetDirection\(\).Z\(\)!=0. && muon.GetMomentumModulus\(\)!=0.\) {) S
LHL
(        angle = 0;) S
LHL
(        ct=cos\(angle\);) S
LHL
(        st=sin\(angle\);) S
LHL
(        Output[0]=\(st*muon.GetPosition\(\).Y\(\)+ct*muon.GetPosition\(\).X\(\)\);) S
LHL
(        Output[1]=\(ct*muon.GetPosition\(\).Y\(\)-st*muon.GetPosition\(\).X\(\)\);) S
LHL
(        Output[2]=\(st*\(muon.GetDirection\(\).Y\(\)/muon.GetDirection\(\).Z\(\)\)+ct*\(muon.GetDirection\() S
SL
(\).X\(\)/muon.GetDirection\(\).Z\(\)\)\);) S
LHL
(        Output[3]=\(ct*\(muon.GetDirection\(\).Y\(\)/muon.GetDirection\(\).Z\(\)\)-st*\(muon.GetDirection\() S
SL
(\).X\(\)/muon.GetDirection\(\).Z\(\)\)\);) S
LHL
(        Output[4]=muon.GetCharge\(\)/muon.GetMomentumModulus\(\);) S
LHL
(        Output[5]= StateVector[5];) S
PHL
(        ) S
LHL
(        // Get range and dS from the Swimmer) S
LHL
(        if\(dS\) {*dS=muon.GetS\(\);} ) S
LHL
(        if\(Range\) {*Range=muon.GetRange\(\);} ) S
LHL
(        if\(dE\){*dE=muon.GetMomentumModulus\(\)-momentum.Mag\(\);} ) S
PHL
(        ) S
LHL
(        //GMA put this more elegantly) S
LHL
(        fTrackCand->SetdSExtra\(muon.GetS\(\)\);) S
EndPage
EndDSCPage
EndSheet

%%Page: 27 27
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 1865 def
/PageNumber 27 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
2028 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(        fTrackCand->SetRangeExtra\(muon.GetRange\(\)\);) S
PHL
(        ) S
LHL
(      } else {done=false;}) S
LHL
(    }) S
LHL
(  } else {) S
LHL
(    // If infinite momentum, use straight line extrapolation) S
LHL
(    Output[0]=StateVector[0] + StateVector[2]*zend;) S
LHL
(    Output[1]=StateVector[1] + StateVector[3]*zend;) S
LHL
(    Output[2]=StateVector[2];) S
LHL
(    Output[3]=StateVector[3];) S
LHL
(    Output[4]=StateVector[4];) S
LHL
(    Output[5]=StateVector[5];) S
PHL
LHL
(    done=true;) S
LHL
(  }    ) S
LHL
(  //cout <<" Output "<< Output[0]<<" "<<Output[1]<<" "<<Output[2]<<" "<<Output[3]<<" "<<Output) S
SL
([4]<<endl;) S
LHL
(  delete myswimmer;) S
LHL
(  //  delete bf;) S
LHL
(  return done;) S
LHL
(}) S
PHL
LHL
(bool InoTrackFitAlg::Swim\(double* StateVector, double* Output, const double zzz, ) S
LHL
26 W
(const int NewPlane,const bool GoForward, double* dS, double* Range, ) S
SL
(double* dE\) {) S
LHL
(  if\(debug_fit\) { cout <<" InoTrackFitAlg : Swim, specified starting Z" << endl;}) S
PHL
(  ) S
LHL
(  // Initialisations) S
LHL
(  // customize for bfield scaling.) S
LHL
(  //  BField * bf = new BField\(*vldc,-1,0\);) S
PHL
(  ) S
LHL
(  // GMA Need to extrace proper Z values for a plane) S
LHL
(  SwimSwimmer* myswimmer = new SwimSwimmer\(fabs\(LayerThickness*NewPlane-zzz\), 0.5*LayerThickne) S
SL
(ss\);) S
PHL
(  ) S
LHL
(  //  if\(UseGeoSwimmer\) GeoSwimmer::Instance\(\)->Initialize\(*vldc\);) S
PHL
(  ) S
LHL
(  //  double invSqrt2 = pow\(1./2.,0.5\);) S
LHL
(  double charge = 0.;) S
LHL
(  bool done = false;) S
PHL
(  ) S
LHL
(  if\(fabs\(StateVector[4]\)>1.e-10\) {) S
LHL
(    double modp = fabs\(1./StateVector[4]\);) S
PHL
(    ) S
LHL
(    // Fix, to account for fact the cosmic muons could move in direction of negative z) S
LHL
(    if\(ZIncreasesWithTime==false\) {modp=-modp;}) S
PHL
(    ) S
LHL
(    double dsdz = pow\(\(1.+pow\(StateVector[2],2\)+pow\(StateVector[3],2\)\),0.5\);) S
LHL
(    double angle=0;) S
LHL
(    double ct=cos\(angle\);) S
LHL
(    double st=sin\(angle\);) S
LHL
(    double dxdz = ct*StateVector[2]-st*StateVector[3];) S
LHL
(    double dydz = st*StateVector[2]+ct*StateVector[3];) S
PHL
(    ) S
LHL
(    // Set up current muon details) S
LHL
(    if\(StateVector[4]>0.\) charge = 1.;) S
LHL
(    else if\(StateVector[4]<0.\) charge = -1.;) S
PHL
(    ) S
LHL
(    TVector3 position\(ct*StateVector[0]-st*StateVector[1],) S
LHL
(                      st*StateVector[0]+ct*StateVector[1],) S
LHL
(                      zzz\);) S
PHL
LHL
(    TVector3 momentum\(modp*\(dxdz/dsdz\),) S
LHL
(                      modp*\(dydz/dsdz\),) S
LHL
(                      modp/dsdz\);) S
LHL
(    SwimParticle muon\(position,momentum\);) S
LHL
(    muon.SetCharge\(charge\);) S
LHL
(    //GMA    SwimZCondition zc\(ZPosLayer[NewPlane]\); //SlcClustData[NewPlane][0].csh->GetZPos\() S
SL
(\)\);) S
PHL
PHL
(   ) S
LHL
(    // Do the swim, accounting for direction of motion w.r.t time too) S
LHL
(    if\( \(GoForward==true && ZIncreasesWithTime==true\)  || \(GoForward==false && ZIncreasesWithT) S
SL
(ime==false\) \) {) S
LHL
(      if\(UseGeoSwimmer\) {) S
LHL
(        //        done = GeoSwimmer::Instance\(\)->SwimForward\(muon,ZPosLayer[NewPlane]\); //SlcC) S
SL
(lustData[NewPlane][0].csh->GetZPos\(\)\);) S
LHL
(      } else {) S
EndPage
EndDSCPage
EndSheet

%%Page: 28 28
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 1937 def
/PageNumber 28 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
2106 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(        done = myswimmer->SwimForward\(muon,t_bave\);) S
LHL
(      } ) S
LHL
(    }) S
LHL
(    else if\( \(GoForward==true && ZIncreasesWithTime==false\)  || \(GoForward==false && ZIncrease) S
SL
(sWithTime==true\) \) {) S
LHL
(      if\(UseGeoSwimmer\) {) S
LHL
(        //        done = GeoSwimmer::Instance\(\)->SwimBackward\(muon,ZPosLayer[NewPlane]\); //Slc) S
SL
(ClustData[NewPlane][0].csh->GetZPos\(\)\);) S
PHL
(        ) S
LHL
(      } else {) S
LHL
(        done = myswimmer->SwimBackward\(muon,t_bave\);) S
LHL
(      }     ) S
LHL
(    }) S
LHL
(    if\(done==true\) {) S
LHL
(      angle=0;) S
LHL
(      ct=cos\(angle\);) S
LHL
(      st=sin\(angle\);) S
PHL
(      ) S
LHL
(      if\(muon.GetDirection\(\).Z\(\)!=0. && muon.GetMomentumModulus\(\)!=0.\) {) S
LHL
(        Output[0]=\(st*muon.GetPosition\(\).Y\(\)+ct*muon.GetPosition\(\).X\(\)\);) S
LHL
(        Output[1]=\(ct*muon.GetPosition\(\).Y\(\)-st*muon.GetPosition\(\).X\(\)\);) S
LHL
(        Output[2]=\(st*\(muon.GetDirection\(\).Y\(\)/muon.GetDirection\(\).Z\(\)\)+ct*\(muon.GetDirection\() S
SL
(\).X\(\)/muon.GetDirection\(\).Z\(\)\)\);) S
LHL
(        Output[3]=\(ct*\(muon.GetDirection\(\).Y\(\)/muon.GetDirection\(\).Z\(\)\)-st*\(muon.GetDirection\() S
SL
(\).X\(\)/muon.GetDirection\(\).Z\(\)\)\);) S
LHL
(        Output[4]=muon.GetCharge\(\)/muon.GetMomentumModulus\(\);) S
LHL
(        Output[5]=StateVector[5];) S
LHL
(        // Get range and dS from the Swimmer) S
LHL
(        if\(dS\) {*dS=muon.GetS\(\);} if\(Range\) {*Range=muon.GetRange\(\);} if\(dE\){*dE=muon.GetMomen) S
SL
(tumModulus\(\)-momentum.Mag\(\);} ) S
LHL
(      } else {done=false;}) S
LHL
(    }) S
LHL
(  } else {) S
LHL
(    // If infinite momentum, use straight line extrapolation) S
LHL
(    double delz = \(ZPosLayer[NewPlane] -zzz\); //SlcClustData[NewPlane][0].csh->GetZPos\(\)-z\);) S
LHL
(    Output[0]=StateVector[0] + StateVector[2]*delz;) S
LHL
(    Output[1]=StateVector[1] + StateVector[3]*delz;) S
LHL
(    Output[2]=StateVector[2];) S
LHL
(    Output[3]=StateVector[3];) S
LHL
(    Output[4]=StateVector[4];) S
LHL
(    Output[5]=StateVector[5];) S
LHL
(    done=true;) S
LHL
(  }    ) S
LHL
(  //cout <<" Output "<< Output[0]<<" "<<Output[1]<<" "<<Output[2]<<" "<<Output[3]<<" "<<Output) S
SL
([4]<<endl;) S
LHL
(  delete myswimmer;) S
LHL
(  //  delete bf;) S
PHL
(  ) S
LHL
(  return done;) S
LHL
(}) S
LHL
(void InoTrackFitAlg::ResetCovarianceMatrix\(\) {) S
LHL
(  // Simple method reset variables/arrays to allow propagation again) S
PHL
(  ) S
LHL
(  DeltaPlane=0; DeltaZ=0;) S
LHL
(  GetInitialCovarianceMatrix\(false\);) S
LHL
(}) S
PHL
LHL
(void InoTrackFitAlg::GetInitialCovarianceMatrix\(const bool FirstIteration1\) {) S
LHL
(  if \(debug_fit\) { cout <<" InoTrackFitAlg : GetInitialCovarianceMatrix " << FirstIteration1 <) S
SL
(< endl;}) S
PHL
(  ) S
LHL
(  if\(FirstIteration1==true\) {) S
LHL
(    for\(int ij=0; ij<5; ++ij\) {) S
LHL
(      for\(int jk=0; jk<5; ++jk\) {) S
LHL
(        C_k_minus[ij][jk]=0.0;) S
PHL
(        ) S
LHL
(        if \(jk == ij\) {) S
LHL
(          C_k_minus[ij][jk]=1.e5;) S
LHL
(        }) S
LHL
(      }) S
LHL
(    }) S
LHL
(  } else if \(FirstIteration1==false\) {) S
LHL
(    for \(int ij = 0; ij < 5; ++ij\) {) S
LHL
(      for \(int jk = 0; jk < 5; ++jk\) {) S
LHL
(        C_k_minus[ij][jk] = 1.e2*C_k_minus[ij][jk];) S
LHL
(      }) S
LHL
(    }) S
LHL
(  }) S
EndPage
EndDSCPage
EndSheet

%%Page: 29 29
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 2008 def
/PageNumber 29 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
2184 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  // Display) S
LHL
(  if\(debug_fit\) {) S
LHL
(    cout<<"---------------------------------------------------------- "<<endl; ) S
LHL
(    cout << "Initial covariance matrix" << endl;) S
LHL
(    for\(int ij=0; ij<5; ++ij\) {) S
LHL
(      for\(int jk=0; jk<5; ++jk\) {) S
LHL
(        cout << C_k_minus[ij][jk] << " ";) S
LHL
(      }  ) S
LHL
(      cout << endl;) S
LHL
(    }) S
LHL
(    cout<<"---------------------------------------------------------- "<<endl; ) S
LHL
(  }) S
LHL
(}) S
PHL
LHL
(void InoTrackFitAlg::CalcKalmanGain\(double *x__minus,const int NewPlane\) {) S
LHL
(  if\(debug_fit\) {) S
LHL
(    cout <<" InoTrackFitAlg : CalcKalmanGain" <<x__minus[0]<<" "<<x__minus[1]<<" "<<x__minus[2) S
SL
(]<<" "<<x__minus[3]<<" "<<x__minus[4]<< endl;) S
LHL
(  }) S
LHL
(  // K_k = C_k_intermediate * H_k^T * \( V_k + H_k * C_k_intermediate * H_k^T \)^-1) S
LHL
(  //) S
68 W
(\( = A1_k\)^-1) S
LHL
(  //) S
68 W
(= B2_k;) S
PHL
(  ) S
LHL
(  double hitX = 0.0;) S
LHL
(  double hitY = 0.0;) S
LHL
(  double A1_k[2][2];) S
LHL
(  double B1_k[2][2];) S
LHL
(  bool OutLier=true;) S
PHL
(  ) S
LHL
(  if \(NewPlane==OtLStrip\) {) S
LHL
(    //cout<<"strip identified: "<<NewPlane<<endl;) S
LHL
(    OutLier = true;) S
LHL
(  }) S
PHL
(  ) S
LHL
(  for \(int ij=0; ij<2; ij++\) {) S
LHL
(    for \(int jk=0; jk<2; jk++\) {) S
LHL
(      A1_k[ij][jk] = 0;) S
LHL
(      B1_k[ij][jk] = 0;) S
LHL
(    }) S
LHL
(  }) S
LHL
(  // H_k has only one non-zero element, so we can reduce matrix multiplication required) S
PHL
(  ) S
LHL
(  int PlaneView = TrkClustsData[NewPlane][0].PlaneView;) S
PHL
(  ) S
LHL
(  if\(PlaneView%2==0\) {) S
LHL
(    hitX) S
16 W
(= TrkClustsData[NewPlane][0].XPos;) S
LHL
(    A1_k[0][0]) S
2 W
(= C_k_intermediate[0][0];) S
LHL
(    if \(fMT==false\) {) S
LHL
(      A1_k[0][0] += 1.00*TrkClustsData[NewPlane][0].XPosErrSq;  // Add uncertainty in measurem) S
SL
(ent::xx 3.20133e-05) S
LHL
(    } else {) S
LHL
(      A1_k[0][0] += 1.00*TrkClustsData[NewPlane][0].XPosErrSq;) S
LHL
(    }) S
LHL
(  }) S
LHL
(  if \(PlaneView >0\) {) S
LHL
(    hitY) S
16 W
(= TrkClustsData[NewPlane][0].YPos;) S
LHL
(    A1_k[1][1]) S
2 W
(= C_k_intermediate[1][1];) S
LHL
(    if \(fMT==false\) {) S
LHL
(      A1_k[1][1] += 1.00*TrkClustsData[NewPlane][0].YPosErrSq;  // Add uncertainty in measurem) S
SL
(ent::yy 3.20133e-05) S
LHL
(    } else {) S
LHL
(      A1_k[1][1] += 1.00*TrkClustsData[NewPlane][0].YPosErrSq;) S
LHL
(    }) S
LHL
(  }) S
PHL
(  ) S
LHL
(  if \(PlaneView==2\) {) S
LHL
(    A1_k[0][1] = C_k_intermediate[0][1];) S
LHL
(    A1_k[1][0] = C_k_intermediate[1][0];) S
LHL
(  }) S
PHL
(  ) S
LHL
(  if \(OutLier == false\) {) S
LHL
(    //cout<<"exercised"<<endl;) S
LHL
(    A1_k[0][0]) S
2 W
(= C_k_intermediate[0][0] - TrkClustsData[NewPlane][0].XPosErrSq;) S
LHL
(    A1_k[1][1]) S
2 W
(= C_k_intermediate[1][1] - TrkClustsData[NewPlane][0].YPosErrSq;) S
LHL
(  }) S
PHL
(  ) S
LHL
(  double determinant = A1_k[0][0]*A1_k[1][1] - A1_k[0][1]*A1_k[1][0];) S
LHL
(  // cout<<"det = "<<determinant<<endl;) S
EndPage
EndDSCPage
EndSheet

%%Page: 30 30
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 2083 def
/PageNumber 30 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
2262 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  // Inverse matrix;) S
LHL
(  // cout <<" InoTrackFitAlg : V_k " << NewPlane<<" "<<TrkClustsData[NewPlane][0].XPosErrSq <<) S
SL
(" " <<TrkClustsData[NewPlane][0].YPosErrSq<<" "<<PlaneView<<" "<<determinant<<" "<<A1_k[0][0]<) S
SL
(<" "<<A1_k[0][1]<<" "<<A1_k[1][0]<<" "<<A1_k[1][1]<<endl;) S
LHL
(  if \(determinant !=0\) {) S
LHL
(    B1_k[0][0] =  A1_k[1][1]/determinant;) S
LHL
(    B1_k[0][1] = -A1_k[0][1]/determinant;) S
LHL
(    B1_k[1][0] = -A1_k[1][0]/determinant;) S
LHL
(    B1_k[1][1] =  A1_k[0][0]/determinant;) S
PHL
(    ) S
LHL
(    for \(int ij=0; ij<5; ++ij\) {) S
LHL
(      for \(int jk =0; jk<2; jk++\) {) S
LHL
(        K_k[ij][jk]=0;) S
LHL
(        for \(int kl=0; kl<5; ++kl\) {) S
LHL
(          for \(int lm=0; lm<2; lm++\) {) S
LHL
(            K_k[ij][jk] +=C_k_intermediate[ij][kl]*H_k[lm][kl]*B1_k[lm][jk];) S
LHL
(          }) S
LHL
(        }) S
LHL
(      }) S
LHL
(    }) S
PHL
(    ) S
LHL
(    for \(int ij = 0; ij < 5; ij++\) {) S
LHL
(      for \(int jk = 0; jk < 2; jk++\) {) S
LHL
(        //cout<<"K_k["<<ij<<"]["<<jk<<"] "<<K_k[ij][jk]<<endl;) S
LHL
(      }) S
LHL
(    }) S
PHL
(    ) S
LHL
(  } else {) S
LHL
(    //   cout <<" InoTrackFitAlg : V_k + \(H_k * C_k_intermediate * H_k_transpose\) is zero!" <<) S
SL
( endl;) S
LHL
(  }) S
LHL
(}) S
PHL
LHL
(void InoTrackFitAlg::UpdateCovMatrix\(const int NewPlane\) {) S
LHL
(  // C_k = \(Identity - \(K_k * H_k\) \) * C_k_intermediate) S
LHL
(  // if\(debug_fit\) {cout <<"*****InoTrackFitAlg : UpdateCovMatrix*****" << endl;}) S
PHL
(  ) S
LHL
(  double KH[5][5] = {{0.0}};) S
LHL
(  double Ck[5][5] = {{0.0}};) S
LHL
(  double Vk[2][2] = {{0.0}};) S
LHL
(  double KVKt[5][5]={{0.0}};) S
PHL
(  ) S
LHL
(  // Evaluate KH = K_k * H_k) S
LHL
(  for \(int ij = 0; ij  <5; ij++\) {) S
LHL
(    for \(int jk = 0; jk < 5; jk++\) {) S
LHL
(      KH[ij][jk] = 0;) S
LHL
(      for \(int kl = 0; kl < 2; kl++\) {) S
LHL
(        KH[ij][jk] += K_k[ij][kl]*H_k[kl][jk];) S
LHL
(      }) S
LHL
(    }) S
LHL
(  }) S
PHL
LHL
(  // Now, find \(I - KH\) = \(I - K_k*H_k\): Redefine KH:=\(I - KH\)) S
LHL
(  for \(int ij = 0; ij < 5; ij++\) {) S
LHL
(    for \(int jk = 0; jk < 5; jk++\) {) S
LHL
(      KH[ij][jk] = Identity[ij][jk] - KH[ij][jk];) S
LHL
(    }) S
LHL
(  }) S
PHL
(  ) S
LHL
(  // The expression: C_k = \(I-KH\) * C_p has known issues with rounding errors) S
LHL
(  // They may lead to -ve elements in the diagonal of error covariance) S
LHL
(  // Use the following expression: C_k = \(I-KH\) * C_p * \(I-KH\)^ + K * V * K^) S
LHL
(  // This expression is the sum of two positive definite matrices) S
PHL
(  ) S
LHL
(  // First find K * V * K^) S
LHL
(  //------------------------------------------------------------------) S
LHL
(  // definition of Vk:) S
LHL
(  if \(fMT==false\) {) S
LHL
(    Vk[0][0] = 1.0*TrkClustsData[NewPlane][0].XPosErrSq;) S
8 W
(//cout<<"Vk[0][0]"<<Vk[0][0]<<) S
SL
(endl;) S
LHL
(    Vk[1][1] = 1.0*TrkClustsData[NewPlane][0].YPosErrSq;) S
8 W
(//cout<<"Vk[1][1]"<<Vk[1][1]<<) S
SL
(endl;) S
LHL
(  } else {) S
LHL
(    Vk[0][0] =1.0*TrkClustsData[NewPlane][0].XPosErrSq;) S
1 W
(//cout<<"Vk[0][0]"<<Vk[0][0]<<endl;) S
LHL
(    Vk[1][1] =1.0*TrkClustsData[NewPlane][0].YPosErrSq;) S
1 W
(//cout<<"Vk[1][1]"<<Vk[1][1]<<endl;) S
LHL
(  }) S
PHL
(  ) S
LHL
(  //cout<<"....................................................."<<endl;) S
EndPage
EndDSCPage
EndSheet

%%Page: 31 31
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 2156 def
/PageNumber 31 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
2340 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  ) S
LHL
(  // Obtaining K * V * K^) S
LHL
(  for \(int ij = 0; ij < 5; ij++\) {) S
LHL
(    for \(int jk = 0; jk < 5; jk++\) {) S
LHL
(      KVKt[ij][jk] = 0;) S
LHL
(      for \(int kl = 0; kl < 2; kl++\) {) S
LHL
(        for \(int lm = 0; lm < 2; lm++\) {) S
LHL
(          KVKt[ij][jk] += K_k[ij][lm] * Vk[lm][kl] * K_k[jk][kl];) S
LHL
(        }) S
LHL
(      }) S
LHL
(    }) S
LHL
(  }) S
LHL
(  //------------------------------------------------------------------) S
LHL
(  // Then, find \(I-KH\) * C_p * \(I-KH\)^) S
LHL
(  //------------------------------------------------------------------) S
LHL
(  for \(int ij = 0; ij < 5; ij++\) {) S
LHL
(    for \(int jk = 0; jk < 5; jk++\) {) S
LHL
(      Ck[ij][jk] = 0;) S
LHL
(      for \(int kl = 0; kl < 5; kl++\) {) S
LHL
(        for \(int lm = 0; lm < 5; lm++\) {) S
LHL
(          Ck[ij][jk] += KH[ij][lm] * C_k_intermediate[lm][kl] * KH[jk][kl];) S
LHL
(        }) S
LHL
(      }) S
LHL
(    }) S
LHL
(  }) S
LHL
(  //------------------------------------------------------------------) S
LHL
(  // Hence, find C_k \(filtered covariance\)) S
LHL
(  //------------------------------------------------------------------) S
LHL
(  for\(int ij = 0; ij < 5; ij++\) {) S
LHL
(    for\(int jk = 0; jk < 5; jk++\) {) S
LHL
(      C_k[ij][jk] = Ck[ij][jk] + KVKt[ij][jk];) S
LHL
(    }) S
LHL
(  }) S
PHL
(  ) S
LHL
(  if\(debug_fit\) {cout <<" InoTrackFitAlg : UpdateCovMatrix ends" << endl;}) S
LHL
(}) S
LHL
(void InoTrackFitAlg::MoveArrays\(const int NewPlane, const bool GoForward\) {) S
LHL
(  // Move k to k-1 ready to consider next clust) S
LHL
(  for \(int ij=0; ij<5; ++ij\) {) S
LHL
(    for \(int jk=0; jk<5; ++jk\) {) S
LHL
(      C_k_minus[ij][jk]=0;) S
LHL
(      C_k_minus[ij][jk]=C_k[ij][jk];) S
LHL
(    }) S
LHL
(  }) S
PHL
(  ) S
LHL
(  for \(int ij=0; ij<5; ++ij\) {) S
LHL
(    x_k_minus[ij]= 0.0;) S
LHL
(    x_k_minus[ij]=x_k[ij];) S
LHL
(  }) S
PHL
(  ) S
LHL
(  //  double chisquare=0.; GMA14) S
LHL
(  double m_k[2]={0.0};) S
LHL
(  double sigma_xx=0.0;) S
LHL
(  double sigma_yy=0.0;) S
PHL
(  ) S
LHL
(  m_k[0]) S
8 W
(= TrkClustsData[NewPlane][0].XPos;) S
LHL
(  m_k[1]) S
8 W
(= TrkClustsData[NewPlane][0].YPos;) S
PHL
(  ) S
LHL
(  if \(fMT==false\) {) S
LHL
(    sigma_xx= TrkClustsData[NewPlane][0].XPosErrSq;) S
LHL
(    sigma_yy= TrkClustsData[NewPlane][0].YPosErrSq;) S
LHL
(  } else {) S
LHL
(    sigma_xx=1.0*TrkClustsData[NewPlane][0].XPosErrSq;) S
LHL
(    sigma_yy=1.0*TrkClustsData[NewPlane][0].YPosErrSq;) S
LHL
(  }) S
PHL
(  ) S
LHL
(  double r_k[2]) S
1 W
(= {0.0};) S
LHL
(  r_k[0]) S
24 W
(= m_k[0]-x_k[0];) S
LHL
(  r_k[1]) S
24 W
(= m_k[1]-x_k[1];) S
PHL
(  ) S
LHL
(  double R_kDet) S
1 W
(= \(sigma_xx-C_k[0][0]\)*\(sigma_yy-C_k[1][1]\)-C_k[0][1]*C_k[1][0];) S
LHL
(  double R_k[2][2]= {{0.0}};) S
LHL
(  R_k[0][0]) S
13 W
(= \(1.0/R_kDet\)*\(sigma_yy-C_k[1][1]\);) S
LHL
(  R_k[0][1]) S
13 W
(= \(1.0/R_kDet\)*C_k[0][1];) S
LHL
(  R_k[1][0]) S
13 W
(= \(1.0/R_kDet\)*C_k[1][0];) S
LHL
(  R_k[1][1]) S
13 W
(= \(1.0/R_kDet\)*\(sigma_xx-C_k[0][0]\);) S
PHL
(  ) S
LHL
(  double chi2) S
3 W
(= R_k[0][0]*r_k[0]*r_k[0] + R_k[0][1]*r_k[0]*r_k[1] + R_k[1][0]*r_k[1]*r_k[0] ) S
EndPage
EndDSCPage
EndSheet

%%Page: 32 32
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 2233 def
/PageNumber 32 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
2418 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(+ R_k[1][1]*r_k[1]*r_k[1];) S
PHL
(  ) S
LHL
(  if \(\(FirstIteration\) && \(GoForward==false\) && \(chi2 > 5.0\)\) {) S
LHL
(    OtLStrip=NewPlane;) S
LHL
(    //cout<<NewPlane<<" fed into OltStrip"<<endl;) S
LHL
(  }) S
PHL
(  ) S
LHL
(  if \(\(LastIteration\) && \(GoForward == true\)\) {) S
LHL
(    ChiSquare += chi2;) S
LHL
(  }) S
LHL
(  if\(debug_fit\) {) S
LHL
(    cout <<" InoTrackFitAlg : MoveArrays end" << endl;) S
LHL
(  }) S
LHL
(}) S
PHL
LHL
(void InoTrackFitAlg::StoreFilteredData\(const int NewPlane\) {) S
LHL
(  // Store the data required for matching Kalman output data to strips) S
LHL
(  if\(debug_fit\) { cout <<" InoTrackFitAlg : StoreFilteredData" << endl;}) S
LHL
8 W
(//) S
6 W
(cout <<"size "<< FilteredData[NewPlane].size\(\)<<endl;) S
LHL
(  for \(unsigned ij=0; ij<FilteredData[NewPlane].size\(\); ij++\) {) S
LHL
(    if \(FilteredData[NewPlane][ij].x_k5==0\) {) S
LHL
(      FilteredData[NewPlane].erase\(FilteredData[NewPlane].begin\(\)+ij\);) S
LHL
(      ij-- ;) S
LHL
(    }) S
LHL
(  }) S
PHL
(  ) S
LHL
(  FiltDataStruct temp;) S
PHL
(  ) S
LHL
(  temp.x_k0=x_k[0]; temp.x_k1=x_k[1];) S
LHL
(  temp.x_k2=x_k[2]; temp.x_k3=x_k[3];) S
LHL
(  temp.x_k4=x_k[4];) S
PHL
(  ) S
LHL
(  temp.x_k5=int\(x_k[5]\);) S
LHL
(  temp.x_k6=true;) S
LHL
(  //  FilteredData[NewPlane].clear\(\);) S
LHL
8 W
(//) S
6 W
(cout <<"x_k[0] "<<x_k[0]<<" "<< x_k[1]<<endl;) S
LHL
(  FilteredData[NewPlane].push_back\(temp\);) S
LHL
(}) S
PHL
LHL
(void InoTrackFitAlg::StoreFilteredData_sr\(const int NewPlane, double* prediction, bool str\) {) S
LHL
(  // Store the data required for matching Kalman output data to strips) S
LHL
(  if\(debug_fit\) {  cout <<"InoTrackFitAlg : StoreFilteredData_sr"<<endl;}) S
LHL
(  for \(unsigned ij=0; ij<FilteredData[NewPlane].size\(\); ij++\) {) S
LHL
16 W
(cout <<"ij "<<ij<<" "<< FilteredData[NewPlane][ij].x_k5<<endl;) S
LHL
(    if \(FilteredData[NewPlane][ij].x_k5==0\) {) S
LHL
(      FilteredData[NewPlane].erase\(FilteredData[NewPlane].begin\(\)+ij\);) S
LHL
(      ij-- ;) S
LHL
(    }) S
LHL
(  }) S
PHL
(  ) S
LHL
(  FiltDataStruct temp;) S
LHL
(  temp.x_k0=prediction[0];) S
LHL
(  temp.x_k1=prediction[1];) S
LHL
(  temp.x_k2=prediction[2];) S
LHL
(  temp.x_k3=prediction[3];) S
LHL
(  temp.x_k4=prediction[4];) S
LHL
(  temp.x_k5=0;) S
LHL
(  temp.x_k6=str;) S
LHL
(  // FilteredData[NewPlane].clear\(\);) S
LHL
(  FilteredData[NewPlane].push_back\(temp\);) S
LHL
(  if\(debug_fit\) {cout <<"InoTrackFitAlg : StoreFilteredData_sr end"<<endl;}) S
LHL
(}) S
PHL
LHL
(void InoTrackFitAlg::SetTrackProperties\(double* x_xk, double* y_yk\) {) S
LHL
(  // Carry out the assignment of variables to the new fitted track) S
LHL
(  //  if\(debug_fit\) {cout <<"InoTrackFitAlg: SetTrackProperties"<<endl;}) S
LHL
(  // -----------------------------------------------------------------) S
LHL
(  if\(x_xk[4]>0.\) {) S
LHL
(    fTrackCand->SetEMCharge\(+1.0\);) S
LHL
(  } else if\(x_xk[4]<0.\) {) S
LHL
(    fTrackCand->SetEMCharge\(-1.0\);) S
LHL
(  }) S
LHL
(  // -----------------------------------------------------------------) S
LHL
(  // Vtx & End planes of the fit) S
LHL
(  int VtxPlane;) S
LHL
(  int EndPlane;) S
PHL
(  ) S
LHL
(  if\(ZIncreasesWithTime==true\) {) S
EndPage
EndDSCPage
EndSheet

%%Page: 33 33
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 2311 def
/PageNumber 33 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
2496 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(    VtxPlane=MinPlane;) S
LHL
(    EndPlane=MaxPlane;) S
LHL
(  } else {) S
LHL
(    VtxPlane=MaxPlane;) S
LHL
(    EndPlane=MinPlane;) S
LHL
(  }) S
PHL
LHL
(  // cout<<"ZIncreasesWithTime = "<<ZIncreasesWithTime<<endl;) S
LHL
(  // cout<<"VtxPlane = "<<VtxPlane<<", EndPlane = "<<EndPlane<<endl;) S
LHL
(  // cout<<"1./x_xk[4] = "<<1./x_xk[4]<<endl;) S
PHL
(  ) S
LHL
(  fTrackCand->SetVtxZ\(ZPosLayer[VtxPlane]\); //SlcClustData[VtxPlane][0].csh->GetZPos\(\)\);) S
LHL
(  fTrackCand->SetVtxPlane\(VtxPlane\);) S
LHL
(  fTrackCand->SetVtxRPCmod\(VtxPlane\);) S
LHL
(  fTrackCand->SetEndZ\(ZPosLayer[EndPlane]\); //SlcClustData[EndPlane][0].csh->GetZPos\(\)\);) S
LHL
(  fTrackCand->SetEndPlane\(EndPlane\);) S
LHL
(  fTrackCand->SetEndRPCmod\(EndPlane\);) S
LHL
(  // -----------------------------------------------------------------) S
LHL
(  // Input Parameters to KF) S
LHL
(  fTrackCand->SetVtxXX\(xxin\);) S
LHL
(  fTrackCand->SetVtxYY\(yyin\);) S
LHL
(  fTrackCand->SetVtxTX\(txin\);) S
LHL
(  fTrackCand->SetVtxTY\(tyin\);) S
LHL
(  // -----------------------------------------------------------------) S
LHL
(  // Fit parameters at vtx) S
LHL
(  //++++++++++++++++++++++++++++++Vtx+++++++++++++++++++++++++++++++++) S
PHL
LHL
(  fTrackCand->SetVtxU\(x_xk[0]\);) S
LHL
(  fTrackCand->SetVtxV\(x_xk[1]\);) S
LHL
(  fTrackCand->SetVtxdU\(x_xk[2]\);) S
LHL
(  fTrackCand->SetVtxdV\(x_xk[3]\);) S
PHL
(  ) S
LHL
(  double dsdz;) S
LHL
(  dsdz=sqrt\(1.0 + x_xk[2]*x_xk[2] + x_xk[3]*x_xk[3]\);) S
LHL
8 W
(//reflect phi for ) S
LHL
(  if\(ZIncreasesWithTime==false\) {dsdz = - dsdz;}) S
PHL
(  ) S
LHL
(  fTrackCand->SetTheta\(acos\(1./dsdz\)\);) S
PHL
LHL
8 W
(double phi = atan2\(x_xk[3],x_xk[2]\);) S
LHL
8 W
(if \(ZIncreasesWithTime==false\) {) S
LHL
16 W
(double PI = acos\(-1.0\);) S
LHL
16 W
(phi +=PI;) S
LHL
16 W
(if \(phi > PI\) { phi -=2*PI;}) S
LHL
8 W
(}) S
PHL
8 W
LHL
(  fTrackCand->SetPhi\(phi\); //atan2\(x_xk[3],x_xk[2]\)\);) S
PHL
(  ) S
LHL
(  fTrackCand->SetFCPC\(FCorPC\);) S
PHL
(  ) S
LHL
(  // cout<<"FCorPC = "<<FCorPC<<", fTrackCand->SetFCPC\(FCorPC\); = "<<fTrackCand->GetFCPC\(\)<<en) S
SL
(dl;) S
LHL
(  if \(x_xk[4]!=0\) {) S
LHL
(    fTrackCand->SetMomentum\(1./x_xk[4]\);) S
LHL
(  }) S
PHL
(  ) S
LHL
(  double therr = 0.0;) S
LHL
(  double pherr = 0.0;) S
PHL
LHL
(  // Following formulae for therr & pherr developed from txerr and tyerr by standard error pro) S
SL
(pagation) S
LHL
(  therr = \(1./\(1. + x_xk[2]*x_xk[2] + x_xk[3]*x_xk[3]\)\)*\(sqrt\(x_xk[2]*x_xk[2]*VtxCov[2]+x_xk[3) S
SL
(]*x_xk[3]*VtxCov[3]+2*x_xk[2]*x_xk[3]*C_k[2][3]\)/sqrt\(x_xk[2]*x_xk[2]+x_xk[3]*x_xk[3]\)\);) S
LHL
(  pherr = sqrt\(x_xk[2]*x_xk[2]*VtxCov[3] + x_xk[3]*x_xk[3]*VtxCov[2] - 2*x_xk[2]*x_xk[3]*C_k[2) S
SL
(][3]\)/\(x_xk[2]*x_xk[2] + x_xk[3]*x_xk[3]\);) S
PHL
(  ) S
LHL
(  fTrackCand->SetThErr\(therr\);) S
LHL
(  fTrackCand->SetPhErr\(pherr\);) S
PHL
LHL
(  cout<<"covariance matric display"<<endl;) S
LHL
(  for\(int ij=0;ij<5;ij++\){) S
LHL
(    for\(int jk=0;jk<5;jk++\){) S
LHL
(      cout<<ij<<" "<<jk<<" "<<C_k[ij][jk]<<" ";) S
PHL
LHL
(    }) S
LHL
(    cout<<endl;) S
LHL
(  }) S
LHL
(  cout<<C_k[0][0]<<" "<<C_k[1][1]<<" " <<C_k[2][3]<<endl;) S
EndPage
EndDSCPage
EndSheet

%%Page: 34 34
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 2385 def
/PageNumber 34 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
2574 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  // Errors on vtx positions, angles and q/p) S
LHL
(  fTrackCand->SetVtxUError\(pow\(VtxCov[0],0.5\)\);) S
LHL
(  fTrackCand->SetVtxVError\(pow\(VtxCov[1],0.5\)\);) S
LHL
(  fTrackCand->SetVtxdUError\(pow\(VtxCov[2],0.5\)\);) S
LHL
(  fTrackCand->SetVtxdVError\(pow\(VtxCov[3],0.5\)\);) S
LHL
(  fTrackCand->SetVtxQPError\(pow\(VtxCov[4],0.5\)\);) S
LHL
(  cout<<"check"<<C_k[0][2]<<"   "<<C_k[1][3]<<endl;) S
LHL
(   fTrackCand->SetVtxUdUError\(pow\(C_k[0][2],0.5\)\);) S
LHL
(  fTrackCand->SetVtxVdVError\(pow\(C_k[1][3],0.5\)\);) S
LHL
(  fTrackCand->SetVtxVdUError\(pow\(C_k[1][2],0.5\)\);) S
LHL
(  fTrackCand->SetVtxdUdVError\(pow\(C_k[2][3],0.5\)\);) S
LHL
(  // -----------------------------------------------------------------) S
LHL
(  //+++++++++++++++++++++++++++++++End++++++++++++++++++++++++++++++++) S
PHL
LHL
(  // Vtx and end direction cosines) S
LHL
8 W
(//GMA Updated for only miniICAL veto getector) S
LHL
(  dsdz=pow\(1.+pow\(FilteredData[VtxPlane][0].x_k2,2\)+pow\(FilteredData[VtxPlane][0].x_k3,2\),0.5\)) S
SL
(;) S
PHL
LHL
(  if\(ZIncreasesWithTime==false\) {dsdz=-dsdz;}) S
LHL
(  fTrackCand->SetVtxDirCosU\(FilteredData[VtxPlane][0].x_k2/dsdz\);) S
LHL
(  fTrackCand->SetVtxDirCosV\(FilteredData[VtxPlane][0].x_k3/dsdz\);) S
LHL
(  fTrackCand->SetVtxDirCosZ\(1./dsdz\);) S
LHL
(  if \(FilteredData[VtxPlane][0].x_k4!=0\) {) S
LHL
(    fTrackCand->SetMomentumCurve\(1./FilteredData[VtxPlane][0].x_k4\);) S
LHL
(  } else {) S
LHL
(    fTrackCand->SetMomentumCurve\(-1000.\);) S
LHL
(  }) S
PHL
PHL
8 W
LHL
(  fTrackCand->SetDirCosU\(FilteredData[VtxPlane][0].x_k2/dsdz\);) S
LHL
(  fTrackCand->SetDirCosV\(FilteredData[VtxPlane][0].x_k3/dsdz\);) S
LHL
(  fTrackCand->SetDirCosZ\(1./dsdz\);) S
PHL
LHL
(  // Fit information in the end plane) S
LHL
(  fTrackCand->SetEndU\(EndState[0]\);) S
LHL
(  fTrackCand->SetEndV\(EndState[1]\);) S
LHL
(  fTrackCand->SetEndDirCosU\(EndState[2]\);) S
LHL
(  fTrackCand->SetEndDirCosV\(EndState[3]\);) S
PHL
(  ) S
LHL
(  dsdz=sqrt\(1.0 + EndState[2]*EndState[2] + EndState[3]*EndState[3]\);) S
LHL
(  if\(ZIncreasesWithTime==false\) {dsdz=-dsdz;}) S
LHL
(  fTrackCand->SetEndDirCosZ\(1./dsdz\);) S
LHL
(  fTrackCand->SetEndMomentumCurve\(1./EndState[4]\);) S
LHL
(  fTrackCand->SetEndQP\(EndState[4]\);) S
PHL
(  ) S
LHL
(  // Errors on end positions, angles and q/p) S
LHL
(  fTrackCand->SetEndUError\(pow\(EndCov[0],0.5\)\);) S
LHL
(  fTrackCand->SetEndVError\(pow\(EndCov[1],0.5\)\);) S
LHL
(  fTrackCand->SetEnddUError\(pow\(EndCov[2],0.5\)\);) S
LHL
(  fTrackCand->SetEnddVError\(pow\(EndCov[3],0.5\)\);) S
LHL
(  fTrackCand->SetEndQPError\(pow\(EndCov[4],0.5\)\);) S
LHL
(  // -----------------------------------------------------------------) S
LHL
(  // -----------------------------------------------------------------) S
LHL
(  fTrackCand->SetChi2\(ChiSquare/\(2*nHit-5\)\);) S
LHL
(  fTrackCand->SetMomentumdS\(GPL\);) S
LHL
(  fTrackCand->SetMomentumRange\(RNG\);) S
LHL
(  // -----------------------------------------------------------------) S
LHL
(  // -----------------------------------------------------------------) S
PHL
(  ) S
LHL
(  // More variables to be set, in order to ensure compatibility) S
LHL
(  fTrackCand->SetNTrackStrip\(fFinderTrack->ClustsInTrack.size\(\)\);) S
LHL
(  fTrackCand->SetNIterate\(NIter\);) S
LHL
(  fTrackCand->SetNSwimFail\(TotalNSwimFail\);) S
PHL
LHL
8 W
(fTrackCand->SetExtPara\(y_yk\);) S
PHL
PHL
8 W
LHL
(  // Obtain "fitting data" for the final track strips) S
LHL
(  // for \(unsigned ij=0; ij<nLayer; ++ij\) {TrkClustsData[ij].clear\(\);}) S
LHL
(  // GetFitData\(MinPlane,MaxPlane\);) S
PHL
(  ) S
LHL
(  // Set tpos error and Calculate chi2, NDOF) S
LHL
(  double Chi2=0; double Chi2Contrib=0; int NDOF=0; double FilteredXPos=0; double FilteredYPos=) S
SL
(0;) S
LHL
(  double momdS=0; double momRange=0;) S
PHL
(  ) S
LHL
(  double sxy=0; // y \(distance\) = c t + shift) S
EndPage
EndDSCPage
EndSheet

%%Page: 35 35
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 2461 def
/PageNumber 35 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
2652 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  double sx=0;  // y = distance) S
LHL
(  double sy=0;  // x = time) S
LHL
(  double sn=0;) S
LHL
(  double sx2=0;) S
LHL
(  for \(unsigned ijk=0; ijk<fTrackCand->GetClusterEntries\(\); ijk++\) {) S
LHL
(    int ij = fTrackCand->ClustsInTrack[ijk]->GetZPlane\(\);) S
LHL
(    // for\(int ij=MinPlane; ij<=MaxPlane; ++ij\) {) S
LHL
(    if \(ij <=int\(nLayer\)\)  {) S
LHL
(      if\(TrkClustsData[ij].size\(\)>0\) {) S
LHL
(        if\(TrkClustsData[ij][0].XPosErrSq>0. || TrkClustsData[ij][0].YPosErrSq>0.\) {) S
LHL
(          fTrackCand->SetTrackPointXError\(ij,pow\(TrkClustsData[ij][0].XPosErrSq,0.5\)\);) S
LHL
(          fTrackCand->SetTrackPointYError\(ij,pow\(TrkClustsData[ij][0].YPosErrSq,0.5\)\);) S
LHL
(          momdS += max\(0., double\(fTrackCand->GetdS\(ij\)\)\);) S
LHL
(          momRange += max\(0.,double\(fTrackCand->GetRange\(ij\)\)\);) S
PHL
(          ) S
LHL
(          // if \(\(!ZIncreasesWithTime && ijk>0\) || \(ZIncreasesWithTime && ijk <fTrackCand->Get) S
SL
(Entries\(\)-1\)\) {) S
LHL
(          sn +=1;) S
LHL
(          sx += TrkClustsData[ij][0].cltime; //Look again for return track) S
LHL
(          sy += momdS;) S
LHL
(          sxy = momdS*TrkClustsData[ij][0].cltime;) S
LHL
(          sx2 = \(TrkClustsData[ij][0].cltime\)*\(TrkClustsData[ij][0].cltime\);) S
PHL
(          ) S
LHL
(          //) S
6 W
(}) S
PHL
(          ) S
LHL
(          Chi2Contrib = 0;) S
PHL
(          ) S
LHL
(          for \(unsigned jk=0; jk<TrkClustsData[ij].size\(\) ;jk++\) {) S
LHL
(            if\(TrkClustsData[ij][jk].PlaneView%2==0\) {) S
LHL
(              FilteredXPos=FilteredData[ij][jk].x_k0;) S
LHL
(              Chi2Contrib += pow\(\(TrkClustsData[ij][jk].XPos-FilteredXPos\),2\)/TrkClustsData[ij) S
SL
(][jk].XPosErrSq;) S
LHL
(              NDOF++;) S
LHL
(            }) S
LHL
(            if \(TrkClustsData[ij][jk].PlaneView >=1\) {) S
LHL
(              FilteredYPos=FilteredData[ij][jk].x_k1;) S
LHL
(              Chi2Contrib += pow\(\(TrkClustsData[ij][jk].YPos-FilteredYPos\),2\)/TrkClustsData[ij) S
SL
(][jk].YPosErrSq;) S
LHL
(              NDOF++;) S
LHL
(            }) S
LHL
(          }) S
LHL
(          fTrackCand->SetPlaneChi2\(ij,Chi2Contrib\);) S
LHL
(          Chi2+=Chi2Contrib;) S
LHL
(          //     NDOF++;) S
LHL
(        }) S
LHL
(      }) S
LHL
(    } else {) S
LHL
(      if \(TrkClustsData[ij+shiftLa].size\(\)>0\) {) S
LHL
(        momdS += fTrackCand->Get2dS\(ij+shiftLa\);) S
LHL
(        momRange += fTrackCand->Get2Range\(ij+shiftLa\);) S
LHL
(        sn +=1;) S
LHL
(        sx += TrkClustsData[ij+shiftLa][0].cltime; //Look again for return track) S
LHL
(        sy += momdS;) S
LHL
(        sxy += momdS*TrkClustsData[ij+shiftLa][0].cltime;) S
LHL
(        sx2 += \(TrkClustsData[ij][0+shiftLa].cltime\)*\(TrkClustsData[ij][0].cltime\);) S
LHL
(        if\(pAnalysis->isXtermOut==1\) {) S
LHL
(          //cout <<"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX "<<endl;) S
LHL
(          //cout <<"ijk "<<ijk<<" "<<ij<<" "<<momdS<<" "<<momRange<<" "<<endl;) S
LHL
(          //cout <<"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX "<<endl;) S
LHL
(        }) S
LHL
(        //isXterm) S
LHL
(      }) S
LHL
(    }) S
LHL
(  }) S
PHL
(  ) S
LHL
(  double velocity = 0;) S
LHL
(  if \(sn >0 && \(sx2*sn - sx*sx\) !=0\) {) S
LHL
(    velocity = 10*\(sxy*sn - sx*sy\)/\(sx2*sn - sx*sx\); // x 10^8m/s) S
LHL
(  }) S
PHL
(  ) S
LHL
(  if\(pAnalysis->isXtermOut==1\) {) S
LHL
(    cout<<endl;) S
LHL
(    //cout <<"chisq : Chi2 NDOF momdS momRange  velocity"<<endl;) S
LHL
(    //cout <<"chisq "<<Chi2 <<" "<<NDOF<<" "<<momdS<<" "<<momRange<<" "<<velocity<< endl;) S
LHL
(    //cout<<"---------------------------------------------------------------------------"<<end) S
SL
(l;) S
LHL
(  }) S
LHL
(  //isXterm) S
EndPage
EndDSCPage
EndSheet

%%Page: 36 36
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 2535 def
/PageNumber 36 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
2730 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  ) S
LHL
(  fTrackCand->Setcval\(velocity\);) S
LHL
(  fTrackCand->SetNDOF\(NDOF-5\); // Number of constraints set to 5) S
LHL
(  // fTrackCand->SetMomentum\(momRange\);) S
LHL
(  // Assign U, V and q/p values) S
LHL
(  for\(int ij=MinPlane; ij<=MaxPlane;++ij\) {) S
LHL
(    //asm_170311) S
LHL
(    if\(FilteredData[ij].size\(\)>0\) {) S
LHL
(      fTrackCand->SetU\(ij,FilteredData[ij][0].x_k0\);) S
LHL
(      fTrackCand->SetV\(ij,FilteredData[ij][0].x_k1\);) S
LHL
(      fTrackCand->SetPlaneQP\(ij,FilteredData[ij][0].x_k4\);) S
LHL
(    }) S
LHL
(  }) S
PHL
(  ) S
LHL
(  // cout<<"-------------------------------------------------------------------------"<<endl;) S
LHL
(  // cout<<"Reconstructed P = "<<fTrackCand->GetMomentum\(\)<<"  |  "<<"theta "<<fTrackCand->Get) S
SL
(Theta\(\)<<endl;) S
LHL
(  // //"  |  L "<<FinderPathLength<<"  |  MaxPlane "<<MaxPlane<<"  |  MinPlane "<<MinPlane<<" ) S
SL
( |  #hits "<<n<<"  |  chisq/dof "<<ChiSquare/\(2*n-5\)<<endl;) S
LHL
(  // cout<<"-------------------------------------------------------------------------"<<endl;) S
PHL
(  ) S
LHL
(  SetT\(\);) S
LHL
(  TimingFit\(\);) S
LHL
(}) S
PHL
LHL
(void InoTrackFitAlg::TimingFit\(\) { //\( CandFitTrackCamHandle &cth\)) S
LHL
(  if\(debug_fit\) { cout <<" InoTrackFitAlg : TimingFit" << endl;}) S
PHL
(  ) S
LHL
(  // Initialisations) S
LHL
(  double ss; ) S
LHL
(  double ts; double qr;  int nc=0; ) S
LHL
(  double MinUncertainty = 0.; double MinCT=-3000.;) S
PHL
(  ) S
LHL
(  // Time of first strip in track) S
LHL
(  StripListTime=9.e10;) S
PHL
(  ) S
LHL
(  // Create an offset such that dS=0 at the MinPlane) S
LHL
(  double dSOffset=0.; double Sign=-1.; double dS[doubleLa]; // GMA need to put from db) S
LHL
(  if\(ZIncreasesWithTime==true\) {) S
LHL
(    dSOffset=fTrackCand->GetdS\(MinPlane\);) S
LHL
(    Sign=1.;) S
LHL
(  }) S
LHL
(  //asm_170311) S
PHL
(  ) S
LHL
(  // Store data needed in arrays. Pulse is in PEs.) S
LHL
(  double Qp[doubleLa];  double Qm[doubleLa];) S
LHL
(  double CTp[doubleLa]; double CTm[doubleLa];) S
LHL
(  int Skipp[doubleLa];  int Skipm[doubleLa];) S
LHL
(  double C=3.e8;) S
PHL
(  ) S
LHL
(  double ErrorParam[3];) S
LHL
(  ErrorParam[0]=0.; ErrorParam[1]=0.; ErrorParam[2]=0.;) S
PHL
(  ) S
LHL
(  // Zero the arrays) S
LHL
(  for\(unsigned int ij=0; ij<nLayer; ++ij\) {) S
LHL
(    dS[ij]=0.; Qp[ij]=0.; Qm[ij]=0.; CTp[ij]=0.;) S
LHL
(    CTm[ij]=0.; Skipp[ij]=0; Skipm[ij]=0;) S
LHL
(  }) S
PHL
(  ) S
LHL
(  // Organise timing for the Far Detector) S
PHL
(  ) S
LHL
(  // Parameters for PE vs time fit residual) S
LHL
(  //GMA all these number need to be updated for INO) S
LHL
(  MinUncertainty=0.56;) S
LHL
(  ErrorParam[0]=0.56; ErrorParam[1]=0.50; ErrorParam[2]=-0.34;) S
PHL
(  ) S
LHL
(  // cout <<" fInoTrackFitAlg : TimingFit" << endl;) S
LHL
(  // Loop over all planes) S
LHL
(  for\(int ij=MinPlane; ij<=MaxPlane; ++ij\) {) S
LHL
(    if\(InitTrkClustData[ij].size\(\)>0\) {) S
LHL
(      dS[ij]=Sign*\(dSOffset-fTrackCand->GetdS\(ij\)\);) S
LHL
(      CTp[ij]=C*fTrackCand->GetT\(ij\); //,StripEnd::kPositive\);) S
LHL
(      // CTm[ij]=C*fTrackCand->GetT\(ij,StripEnd::kNegative\);) S
PHL
(      ) S
LHL
(      if\(CTp[ij]>MinCT && CTp[ij]<StripListTime\) {StripListTime=CTp[ij];}) S
LHL
(      // if\(CTm[ij]>MinCT && CTm[ij]<StripListTime\) {StripListTime=CTm[ij];}) S
LHL
(      for\(unsigned int jk=0; jk<InitTrkClustData[ij].size\(\); ++jk\) {) S
LHL
(        Qp[ij]+=InitTrkClustData[ij][jk].csh->GetPulse\(\); //StripEnd::kPositive\);) S
EndPage
EndDSCPage
EndSheet

%%Page: 37 37
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 2611 def
/PageNumber 37 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
2808 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(        // Qm[ij]+=InitTrkClustData[ij][jk].csh->GetPulse\(StripEnd::kNegative\);) S
LHL
(      }) S
LHL
(    }) S
LHL
(  }) S
LHL
(  // Subtract StripList time) S
LHL
(  if\(StripListTime<8.e30\) {) S
LHL
(    for\(int ij=MinPlane; ij<=MaxPlane; ++ij\) {) S
LHL
(      if\(InitTrkClustData[ij].size\(\)>0\) {) S
LHL
(        CTp[ij]-=StripListTime;) S
LHL
(        // CTm[ij]-=StripListTime;) S
LHL
(      }) S
LHL
(    }) S
LHL
(  } else {) S
LHL
(    StripListTime=0.;) S
LHL
(  }) S
LHL
(  // cout <<" eInoTrackFitAlg : TimingFit" << endl;) S
LHL
(  // Carry out a simple straight line fit for T vs dS) S
LHL
(  // Sqt: sum of charge*time, Sqss: sum of charge*dS*dS, etc.) S
LHL
(  double Sqs=0; double Sqt=0; double Sqss=0; double Sqst=0; double Sqtt=0; double Sq=0;) S
LHL
(  double TimeSlope=-999; double TimeOffset=-999; double RMS=-999;) S
LHL
(  double CTCut = 0.; bool CalculateChi2=true;) S
PHL
(  ) S
LHL
(  // On first iteration, carry out simple fit. Remove outlying points on subsequent passes.) S
LHL
(  for\(int itr=0; itr<3; ++itr\) {) S
LHL
(    for\(int ij=MinPlane; ij<=MaxPlane; ++ij\) {) S
LHL
(      // Only consider planes where we found our final strips) S
LHL
(      if\(InitTrkClustData[ij].size\(\)>0\) {) S
LHL
(        // For positive strip ends) S
LHL
(        ss=dS[ij]; qr=Qp[ij]; ts=CTp[ij];) S
PHL
(        ) S
LHL
(        if\(qr>0. && ts>MinCT && Skipp[ij]==0\) {) S
LHL
(          if\(itr==0\) {) S
LHL
(            Sq+=qr; Sqs+=qr*ss; Sqt+=qr*ts; Sqss+=qr*ss*ss; Sqst+=qr*ss*ts; Sqtt+=qr*ts*ts; nc) S
SL
(++;) S
LHL
(          } else if\(fabs\(ts-TimeOffset-\(ss*TimeSlope\)\) > CTCut\) {) S
LHL
(            Sqs-=qr*ss; Sqt-=qr*ts; Sqss-=qr*ss*ss; Sqst-=qr*ss*ts; Sqtt-=qr*ts*ts; Sq-=qr; nc) S
SL
(--; Skipp[ij]=1;) S
LHL
(          }) S
LHL
(        }) S
LHL
(      }) S
LHL
(    }) S
PHL
(    ) S
LHL
(    // Calculate parameters) S
LHL
(    if\( \(Sq*Sqss-Sqs*Sqs\)!=0. && Sq!=0.\) {) S
LHL
(      TimeSlope  = \(Sq*Sqst-Sqs*Sqt\)/\(Sq*Sqss-Sqs*Sqs\);) S
LHL
(      TimeOffset = \(Sqt*Sqss-Sqs*Sqst\)/\(Sq*Sqss-Sqs*Sqs\);) S
LHL
(      if\( \(\(Sqtt/Sq\)-\(\(Sqt/Sq\)*\(Sqt/Sq\)\)\)>0.\) {) S
LHL
(        RMS = pow\(\(Sqtt/Sq\)-\(\(Sqt/Sq\)*\(Sqt/Sq\)\),0.5\);) S
LHL
(        CTCut = 3.+RMS;) S
LHL
(      } else {) S
LHL
(        CTCut = 3.5;) S
LHL
(      }) S
LHL
(    } else {) S
LHL
(      CalculateChi2=false;) S
LHL
(      break;) S
LHL
(    }) S
LHL
(  }) S
PHL
(  ) S
LHL
(  // cout <<" dInoTrackFitAlg : TimingFit" << endl;) S
PHL
(  ) S
LHL
(  // Set timing properties for the fitted track) S
LHL
(  if\(nc!=0 && CalculateChi2==true\) {) S
LHL
(    // Offset, slope and vtx/end times) S
LHL
(    fTrackCand->SetTimeOffset\(\(TimeOffset+StripListTime\)/C\);) S
LHL
(    fTrackCand->SetTimeSlope\(TimeSlope/C\);) S
PHL
(    ) S
LHL
(    if\(ZIncreasesWithTime==true\) {) S
LHL
(      fTrackCand->SetVtxT\(\(TimeOffset+StripListTime\)/C\);) S
LHL
(      fTrackCand->SetEndT\(\(TimeOffset+StripListTime\)/C+\(dS[MaxPlane]*TimeSlope/C\)\);) S
LHL
(    } else {) S
LHL
(      fTrackCand->SetEndT\(\(TimeOffset+StripListTime\)/C\);) S
LHL
(      fTrackCand->SetVtxT\(\(TimeOffset+StripListTime\)/C+\(dS[MaxPlane]*TimeSlope/C\)\);) S
LHL
(    }) S
LHL
(    // cout <<" cInoTrackFitAlg : TimingFit" << endl;) S
LHL
(    // Chi2) S
LHL
(    double Uncertainty; double Residual2; double Chi2=0;) S
PHL
(    ) S
LHL
(    for\(int ij=MinPlane; ij<=MaxPlane; ++ij\) {) S
EndPage
EndDSCPage
EndSheet

%%Page: 38 38
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 2687 def
/PageNumber 38 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
2886 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(      if\(InitTrkClustData[ij].size\(\)>0\) {) S
LHL
8 W
(// For positive strip ends) S
LHL
(        ss=dS[ij]; qr=Qp[ij]; ts=CTp[ij];) S
LHL
(        if\(qr>0. && ts>MinCT && Skipp[ij]==0\) {) S
LHL
(          Residual2=pow\(ts-TimeOffset-\(ss*TimeSlope\),2\);) S
LHL
(          // From a rough parameterisation of uncertainty \(in CT\) vs number of PEs) S
LHL
(          if \(qr<20\) {) S
LHL
(            Uncertainty = ErrorParam[0]+exp\(ErrorParam[1]+ErrorParam[2]*qr\);) S
LHL
(          } else {) S
LHL
(            Uncertainty=MinUncertainty;) S
LHL
(          }) S
LHL
(          if\(Uncertainty!=0.\) {) S
LHL
(            Chi2+=Residual2/pow\(Uncertainty,2\);) S
LHL
(          }) S
LHL
(        }) S
LHL
(      }) S
LHL
(    }) S
LHL
(    // Set these properties) S
LHL
(    fTrackCand->SetTimeFitChi2\(Chi2\);) S
LHL
(    fTrackCand->SetNTimeFitDigit\(nc\);) S
LHL
(  }) S
PHL
(  ) S
LHL
(  // Now carry out fits with gradients constrained to be +/- c) S
LHL
(  double CTIntercept[2]; double Csigma[2]; double Ctrunc[2];) S
LHL
(  double ChiSqPositive=-999; double ChiSqNegative=-999;) S
LHL
(  int ChiSqNdfPos=-999; int ChiSqNdfNeg=-999;) S
LHL
(  double Swtt[2]; double Swt[2]; double Sw[2]; int npts[2]={0,0};) S
LHL
(  // cout <<" bInoTrackFitAlg : TimingFit" << endl;) S
LHL
(  if\(Sq!=0.\){) S
LHL
(    CTIntercept[0]=Sqt/Sq; Csigma[0]=-99999.9; Ctrunc[0]=-99999.9;) S
LHL
(    CTIntercept[1]=Sqt/Sq; Csigma[1]=-99999.9; Ctrunc[1]=-99999.9;) S
PHL
(    ) S
LHL
(    for\(int itr=0; itr<2; ++itr\) {) S
LHL
(      Swtt[0]=0.; Swt[0]=0.; Sw[0]=0.; npts[0]=0;) S
LHL
(      Swtt[1]=0.; Swt[1]=0.; Sw[1]=0.; npts[1]=0;) S
PHL
(      ) S
LHL
(      for\(unsigned int ij=0; ij<nLayer; ++ij\) {) S
LHL
(        // For positive strip ends) S
LHL
(        if\(Qp[ij]>0. && CTp[ij]>MinCT\) {) S
LHL
(          qr=Qp[ij];) S
LHL
(          ts=CTp[ij]-dS[ij]+CTIntercept[0];) S
LHL
(          if\(Ctrunc[0]<0. || fabs\(ts\)<Ctrunc[0]\) {Swtt[0]+=qr*ts*ts; Swt[0]+=qr*ts; Sw[0]+=qr;) S
SL
( ++npts[0];}) S
PHL
(          ) S
LHL
(          ts=CTp[ij]+dS[ij]+CTIntercept[1];) S
LHL
(          if\(Ctrunc[1]<0. || fabs\(ts\)<Ctrunc[1]\) {Swtt[1]+=qr*ts*ts; Swt[1]+=qr*ts; Sw[1]+=qr;) S
SL
( ++npts[1];}) S
LHL
(        }) S
LHL
(      }) S
PHL
(      ) S
LHL
(      // Results for fit with gradient +C) S
LHL
(      if\(npts[0]>1 && Sw[0]!=0.\) {) S
LHL
(        CTIntercept[0]=CTIntercept[0]-Swt[0]/Sw[0]; Csigma[0]=0.;) S
LHL
(        if\(\(Swtt[0]/Sw[0]\)-\(Swt[0]/Sw[0]\)*\(Swt[0]/Sw[0]\)>0.\) {Csigma[0]=pow\(\(Swtt[0]/Sw[0]\)-\(S) S
SL
(wt[0]/Sw[0]\)*\(Swt[0]/Sw[0]\),0.5\);}) S
LHL
(        ChiSqPositive=Csigma[0]; ChiSqNdfPos=npts[0]-1;) S
LHL
(        Ctrunc[0]=Csigma[0]+3.;) S
LHL
(      }) S
PHL
(      ) S
LHL
(      // Results for fit with gradient -C) S
LHL
(      if\(npts[1]>1 && Sw[1]!=0.\) {) S
LHL
(        CTIntercept[1]=CTIntercept[1]-Swt[1]/Sw[1]; Csigma[1]=0.;) S
LHL
(        if\(\(Swtt[1]/Sw[1]\)-\(Swt[1]/Sw[1]\)*\(Swt[1]/Sw[1]\)>0.\) {Csigma[1]=pow\(\(Swtt[1]/Sw[1]\)-\(S) S
SL
(wt[1]/Sw[1]\)*\(Swt[1]/Sw[1]\),0.5\);}) S
LHL
(        ChiSqNegative=Csigma[1]; ChiSqNdfNeg=npts[1]-1;) S
LHL
(        Ctrunc[1]=Csigma[1]+3.;) S
LHL
(      }) S
LHL
(    }) S
LHL
(  }) S
LHL
(  // Set these properties) S
LHL
(  fTrackCand->SetTimeForwardFitRMS\(ChiSqPositive\);) S
LHL
(  fTrackCand->SetTimeForwardFitNDOF\(ChiSqNdfPos\);) S
LHL
(  fTrackCand->SetTimeBackwardFitRMS\(ChiSqNegative\);) S
LHL
(  fTrackCand->SetTimeBackwardFitNDOF\(ChiSqNdfNeg\);) S
PHL
(  ) S
LHL
(  // cout <<" aInoTrackFitAlg : TimingFit" << ChiSqPositive <<" "<<ChiSqNdfPos<<" "<<ChiSqNega) S
SL
(tive<<" "<<ChiSqNdfNeg<< endl;) S
LHL
(}) S
EndPage
EndDSCPage
EndSheet

%%Page: 39 39
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 2760 def
/PageNumber 39 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
2964 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
LHL
(/*) S
LHL
(  void InoTrackFitAlg::SetRangeAnddS\( \) //CandFitTrackCamHandle& cth\)) S
LHL
(  {) S
LHL
(  // Set range and dS as calculated by the swimmer) S
LHL
(  // cout <<" InoTrackFitAlg : SetRangeAnddS from swimmer values " << endl;) S
PHL
LHL
(  // int ZDir; ) S
LHL
(  // int VtxPlane=5000; int EndPlane=-20; int Increment=1;) S
LHL
(  int VtxPlane=5000; int EndPlane=0; int Increment=1;) S
LHL
(  double dS; double dRange; double dP;) S
PHL
LHL
(  // Start at the end of the track and calculate the required additions to range) S
PHL
LHL
(  // find ending Z position \(defined as Z position where muon has 100 MeV of residual energy. ) S
SL
( This corresponds to 1/2 inch of Fe.) S
PHL
LHL
(  // NOTE: Average dP for 1" iron is 95 MeV.) S
PHL
8 W
LHL
(  //if\(ZIncreasesWithTime==true\) {ZDir=1; EndPlane=MaxPlane; VtxPlane=MinPlane; Increment=-1;}) S
LHL
(  //else {ZDir=-1; EndPlane=MinPlane; VtxPlane=MaxPlane; Increment=1;}) S
PHL
LHL
(  //PlexPlaneId plnid\(detector,EndPlane,false\);) S
LHL
(  //PlexPlaneId endplnid\(detector,EndPlane,false\);) S
PHL
LHL
(  //double Zscint = ZPosLayer[EndPlane]; //SlcClustData[EndPlane][0].csh->GetZPos\(\);) S
LHL
(  //double Znextscint = Zscint;) S
PHL
LHL
(  //UgliScintPlnHandle scintpln = ugh.GetScintPlnHandle\(plnid\); ) S
LHL
(  //double Zend = Zscint + double\(ZDir\)*scintpln.GetHalfThickness\(\);) S
PHL
LHL
(  //PlexPlaneId nextscint =  endplnid.GetAdjoinScint\(ZDir\);) S
LHL
(  //UgliScintPlnHandle nextscintpln = ugh.GetScintPlnHandle\(nextscint\);) S
LHL
(  //if\(nextscintpln.IsValid\(\) && nextscint.GetPlaneView\(\)!=PlaneView::kUnknown\){) S
LHL
(  //Znextscint = nextscintpln.GetZ0\(\);) S
LHL
(  //}) S
LHL
(  //else) S
LHL
(  //{) S
LHL
(  //nextscint = endplnid;) S
LHL
(  //}) S
PHL
LHL
(  //plnid = plnid.GetAdjoinSteel\(ZDir\);) S
LHL
(  //if\(plnid.IsValid\(\)\){) S
LHL
(  //UgliSteelPlnHandle steelpln = ugh.GetSteelPlnHandle\(plnid\);) S
LHL
(  //Zend = steelpln.GetZ0\(\) - double\(ZDir\)*steelpln.GetHalfThickness\(\);) S
LHL
(  //}) S
PHL
LHL
(  // add two planes of steel for the ND spectrometer) S
LHL
(  //if\(detector==Detector::kNear && EndPlane>=121\) {) S
LHL
(  //for\(int i=0;i<2;i++\){) S
LHL
(  //if\(plnid.GetAdjoinSteel\(ZDir\).IsValid\(\)\){) S
LHL
(  //    PlexPlaneId plnid_after = plnid.GetAdjoinSteel\(ZDir\);) S
LHL
(  //    if\(plnid_after.IsValid\(\)\) {) S
LHL
(  //    plnid = plnid_after;) S
LHL
(  //    UgliSteelPlnHandle steelpln = ugh.GetSteelPlnHandle\(plnid\);) S
LHL
(  //    Zend = steelpln.GetZ0\(\) - double\(ZDir\)*steelpln.GetHalfThickness\(\);) S
LHL
(  //    }) S
LHL
(  //  ) S
2 W
(}) S
LHL
(  //) S
4 W
(}) S
LHL
(  //}) S
PHL
(  ) S
6 W
PHL
LHL
(  // GMA This is to arbitray value just to have compilation) S
LHL
(  // Need to put the RPC/IRON postion properly) S
LHL
(  double Zend = LayerThickness*\(EndPlane-1\);) S
PHL
LHL
(  //  double angle = 0;) S
LHL
(  //  double ct = cos\(angle\);) S
LHL
(  //  double st = sin\(angle\);) S
LHL
(  // Determine whether track stops in coil) S
LHL
(  //  float u_end = FilteredData[EndPlane][0].x_k0;) S
LHL
(  //  float v_end = FilteredData[EndPlane][0].x_k1;) S
LHL
(  //  float du_end = FilteredData[EndPlane][0].x_k2;) S
LHL
(  //  float dv_end = FilteredData[EndPlane][0].x_k3;) S
LHL
(  //  float delz = 0.0852; // Znextscint-Zscint;) S
LHL
(  //  float u_extrap = u_end +delz*du_end;) S
LHL
(  //  float v_extrap = v_end +delz*dv_end;) S
LHL
(  //  float x_extrap = \(ct*u_extrap-st*v_extrap\);) S
EndPage
EndDSCPage
EndSheet

%%Page: 40 40
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 2837 def
/PageNumber 40 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
3042 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  //  float y_extrap = \(st*u_extrap+ct*v_extrap\);) S
PHL
PHL
8 W
LHL
(  //PlaneCoverage::PlaneCoverage_t kPC = PlaneCoverage::kComplete;) S
LHL
(  //if\(detector==Detector::kNear\) kPC=PlaneCoverage::kNearFull;) S
PHL
LHL
(  //bool isInOutline = fPL.IsInside\(x_extrap,y_extrap,nextscint.GetPlaneView\(\),kPC,false\);) S
LHL
(  //bool isInCoil = isInOutline && !fPL.IsInside\(x_extrap,y_extrap,nextscint.GetPlaneView\(\),kP) S
SL
(C,true\);) S
PHL
8 W
PHL
LHL
(  double S = 0; double Range = 0; double Prange = 0.0;) S
LHL
(  double StateVector[6]; double Output[6];) S
LHL
(  double chargesign = -1;) S
LHL
(  bool GoForward = true; bool done=true; bool swimOK=true;) S
PHL
LHL
(  // if in coil find midpoint and swim towards last clust from there) S
PHL
8 W
LHL
(  //) S
4 W
(if\(isInCoil\){) S
LHL
(  //) S
4 W
(float zCoil = Znextscint;) S
LHL
(  //) S
4 W
(float u_extrapC = u_extrap;) S
LHL
(  //) S
4 W
(float v_extrapC = v_extrap;) S
LHL
(  //) S
4 W
(float x_extrapC = x_extrap;) S
LHL
(  //) S
4 W
(float y_extrapC = y_extrap;) S
LHL
(  //) S
4 W
(while\(isInCoil\){) S
LHL
(  //) S
4 W
(zCoil -= 1.0*Munits::cm*ZDir;) S
LHL
(  //) S
4 W
(float delzC = zCoil - Zscint;) S
LHL
(  //) S
4 W
(u_extrapC = u_end +delzC*du_end;) S
LHL
(  //) S
4 W
(v_extrapC = v_end +delzC*dv_end;) S
LHL
(  //) S
4 W
(x_extrapC = \(ct*u_extrapC-st*v_extrapC\);) S
LHL
(  //) S
4 W
(y_extrapC = \(st*u_extrapC+ct*v_extrapC\);) S
LHL
(  //) S
4 W
(// isInCoil = !fPL.IsInside\(x_extrapC,y_extrapC,nextscint.GetPlaneView\(\),kPC,true\);   ) S
SL
(     ) S
LHL
(  //) S
4 W
(}) S
LHL
(  //) S
4 W
(float zMinCoil = zCoil;) S
LHL
(  //) S
4 W
(if\(zMinCoil<Zscint && ZDir==1\)  zMinCoil=Zscint;) S
LHL
(  //) S
4 W
(if\(zMinCoil>Zscint && ZDir==-1\) zMinCoil=Zscint;) S
PHL
LHL
(  //) S
4 W
(zCoil = Znextscint;) S
PHL
LHL
(  //) S
4 W
(isInCoil = true;) S
LHL
(  //) S
4 W
(while\(isInCoil\){) S
LHL
(  //) S
4 W
(zCoil += 1.0*Munits::cm*ZDir;) S
LHL
(  //) S
4 W
(float delzC = zCoil - Zscint;) S
LHL
(  //) S
4 W
(u_extrapC = u_end +delzC*du_end;) S
LHL
(  //) S
4 W
(v_extrapC = v_end +delzC*dv_end;) S
LHL
(  //) S
4 W
(x_extrapC = \(ct*u_extrapC-st*v_extrapC\);) S
LHL
(  //) S
4 W
(y_extrapC = \(st*u_extrapC+ct*v_extrapC\);) S
LHL
(  //) S
4 W
(isInCoil = !fPL.IsInside\(x_extrapC,y_extrapC,nextscint.GetPlaneView\(\),kPC,true\);      ) S
SL
(  ) S
LHL
(  //) S
4 W
(}) S
PHL
PHL
LHL
(  // float zMaxCoil = zCoil;) S
LHL
(  // float zmin; float zmax;) S
LHL
(  // ugh.GetZExtent\(zmin,zmax\);) S
LHL
(  // if\(zMaxCoil>zmax && ZDir==1\)  zMaxCoil=zmax;) S
LHL
(  // if\(zMaxCoil<zmin && ZDir==-1\) zMaxCoil=zmin;) S
PHL
LHL
(  // now swim from mid-coil back to endplane) S
LHL
(  // float zMidCoil = 0.5*\(zMinCoil + zMaxCoil\);) S
LHL
(  // float delzC  = zMidCoil -Zscint;) S
LHL
(  // u_extrapC = u_end +delzC*du_end;) S
LHL
(  // v_extrapC = v_end +delzC*dv_end;) S
LHL
(  // x_extrapC = 0.707*\(u_extrapC-v_extrapC\);) S
LHL
(  // y_extrapC = 0.707*\(u_extrapC+v_extrapC\);) S
PHL
(    ) S
LHL
(  // StateVector[0] = u_extrapC; Output[0]=StateVector[0];) S
LHL
(  // StateVector[1] = v_extrapC; Output[1]=StateVector[1];) S
LHL
(  // StateVector[2] = FilteredData[EndPlane][0].x_k2; Output[2]=StateVector[2];) S
LHL
(  // StateVector[3] = FilteredData[EndPlane][0].x_k3; Output[3]=StateVector[3];) S
LHL
(  // chargesign = -1;) S
LHL
(  // if\(FilteredData[EndPlane][0].x_k4!=0.\) {chargesign =  FilteredData[EndPlane][0].x_k4/fabs) S
SL
(\(FilteredData[EndPlane][0].x_k4\);}) S
PHL
(    ) S
LHL
(  // GoForward = !ZIncreasesWithTime;) S
LHL
(  // StateVector[4] = 10.*chargesign; Output[4]=StateVector[4]; ) S
LHL
(  // StateVector[5] = FilteredData[EndPlane][0].x_k5; Output[5]=StateVector[5];) S
EndPage
EndDSCPage
EndSheet

%%Page: 41 41
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 2911 def
/PageNumber 41 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
3120 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
LHL
(  // double dsdz = pow\(\(1. + pow\(StateVector[2],2\) + pow\(StateVector[3],2\)\),0.5\);    ) S
LHL
(  // set fallback to nominal energy loss in case coil swim fails) S
LHL
(  // Prange = 0.095*dsdz;) S
LHL
(  // if\(detector==Detector::kNear && EndPlane>121\) Prange = 0.2*dsdz;  ) S
LHL
(  // Prange += 0.5*dsdz*0.1*fabs\(zMaxCoil-zMinCoil\)*2.357*1.97;) S
PHL
LHL
(  // swimOK = Swim\(StateVector, Output, zMidCoil, EndPlane , GoForward, &dS, &dRange, &dP\);) S
PHL
(   ) S
LHL
(  // if\(swimOK \){) S
LHL
(  // S = dS; Range = dRange; Prange = fabs\(dP\);) S
LHL
(  // fTrackCand->SetdS\(EndPlane,S\); ) S
LHL
(  // fTrackCand->SetRange\(EndPlane,Range\);) S
LHL
(  // }) S
LHL
(  // if\(!swimOK\) {Output[4] = chargesign/Prange;}) S
LHL
(  // } else) S
PHL
(    ) S
PHL
LHL
(  {) S
LHL
(  // // normal case - track does not end in coil) S
LHL
(  //    if\(\(Zend<Zscint && ZDir==1\) || \(Zend>Zscint && ZDir==-1\)\) {) S
LHL
(  //      cout <<" InoTrackFitAlg :  Zend on wrong side of last scint! " << endl;) S
LHL
(  //      Zend=Zscint;) S
LHL
(  //    }) S
PHL
(    ) S
LHL
(  // now swim to Zend) S
LHL
(  StateVector[0]=FilteredData[EndPlane][0].x_k0; Output[0]=StateVector[0];) S
LHL
(  StateVector[1]=FilteredData[EndPlane][0].x_k1; Output[1]=StateVector[1];) S
LHL
(  StateVector[2]=FilteredData[EndPlane][0].x_k2; Output[2]=StateVector[2];) S
LHL
(  StateVector[3]=FilteredData[EndPlane][0].x_k3; Output[3]=StateVector[3];) S
LHL
(  StateVector[4]=FilteredData[EndPlane][0].x_k4; Output[4]=StateVector[4];) S
LHL
(  StateVector[5]=FilteredData[EndPlane][0].x_k5; Output[5]=StateVector[5];) S
PHL
LHL
(  chargesign = -1;) S
LHL
(  if\(StateVector[4]!=0.\) {chargesign = StateVector[4]/fabs\(StateVector[4]\);}) S
PHL
(    ) S
LHL
(  GoForward = ZIncreasesWithTime;) S
LHL
(  done = Swim\(StateVector, Output, EndPlane, Zend, GoForward,  &dS, &dRange, &dP\);) S
PHL
(    ) S
LHL
(  GoForward = !ZIncreasesWithTime;) S
LHL
(  double dsdz = pow\(\(1. + pow\(StateVector[2],2\) + pow\(StateVector[3],2\)\),0.5\); ) S
LHL
(  S = 0; Range = 10.0*dsdz; Prange = 0.095*dsdz;) S
LHL
(  swimOK = false;) S
LHL
(  if\(done\){) S
LHL
(  for\(int j=0;j<6;j++\) {StateVector[j]=Output[j];}) S
PHL
(      ) S
LHL
(  // now swim from Zend to EndPlane) S
LHL
(  StateVector[4] = chargesign * 10.52;  // start @ P = 100 MeV \(Eloss in 1/2 " Iron\)) S
LHL
(  swimOK = Swim\(StateVector, Output, Zend, EndPlane , GoForward, &dS, &dRange, &dP\);) S
LHL
(  if\(swimOK\){) S
LHL
(  S += dS; Range += dRange; Prange += fabs\(dP\);) S
LHL
(  fTrackCand->SetdS\(EndPlane,S\); ) S
LHL
(  fTrackCand->SetRange\(EndPlane,Range\);) S
LHL
(  }) S
LHL
(  }) S
LHL
(  if\(!swimOK\) {Output[4] = chargesign/Prange;}) S
LHL
(  }) S
PHL
(  ) S
LHL
(  int thisplane = EndPlane;) S
LHL
(  // now swim back to vertex) S
LHL
(  bool firstplane=true;) S
LHL
(  for\(int i=EndPlane+Increment; Increment*i<=Increment*VtxPlane; i+=Increment\) {) S
LHL
(  if\(FilteredData[i].size\(\)>0\) {) S
LHL
(  double delU = FilteredData[i][0].x_k0 - StateVector[0] ;) S
LHL
(  double delV = FilteredData[i][0].x_k1 - StateVector[1] ;) S
LHL
(  double dSperPlane=0.;) S
LHL
(  if\(thisplane!=i\) {dSperPlane = pow\(delU*delU + delV*delV,0.5\)/double\(abs\(thisplane-i\)\);}) S
PHL
(      ) S
LHL
(  // only update state vector if change in U/V is reasonable.) S
LHL
(  if\(dSperPlane < 1.5\) { // *TMinuit::m\) {) S
LHL
(  StateVector[0]=FilteredData[i][0].x_k0;) S
LHL
(  StateVector[1]=FilteredData[i][0].x_k1;) S
LHL
(  StateVector[2]=FilteredData[i][0].x_k2;) S
LHL
(  StateVector[3]=FilteredData[i][0].x_k3;) S
PHL
8 W
LHL
(  chargesign=-1;) S
LHL
(  if\(FilteredData[i][0].x_k4!=0.\) {chargesign = FilteredData[i][0].x_k4/fabs\(FilteredData[i][0) S
SL
(].x_k4\);}) S
EndPage
EndDSCPage
EndSheet

%%Page: 42 42
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 2988 def
/PageNumber 42 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
3198 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
8 W
LHL
(  StateVector[5]=FilteredData[i][0].x_k5;) S
LHL
(  }) S
PHL
(      ) S
LHL
(  StateVector[4] = chargesign * fabs\(Output[4]\);) S
LHL
(  done = Swim\(StateVector, Output, thisplane, i , GoForward, &dS, &dRange, &dP\);) S
LHL
(  if\(done\){) S
LHL
(  S+=dS; Range+=dRange; Prange+=fabs\(dP\);) S
LHL
(  fTrackCand->SetdS\(i,S\); fTrackCand->SetRange\(i,Range\);) S
LHL
(  firstplane=false;) S
LHL
(  }) S
LHL
(  else {) S
LHL
(  cout <<" InoTrackFitAlg :  swim fail " << endl;) S
LHL
(  }) S
LHL
(  thisplane=i;) S
LHL
(  }) S
LHL
(  }) S
PHL
PHL
(  ) S
LHL
(  //  PlexPlaneId vtxplnid\(detector,VtxPlane,false\);) S
LHL
(  //  PlexPlaneId plnid_before = vtxplnid.GetAdjoinSteel\(-ZDir\);) S
PHL
(  ) S
LHL
(  //if\(plnid_before.IsValid\(\)\) {) S
LHL
(  //  plnid = plnid_before;) S
LHL
(  //  UgliSteelPlnHandle steelpln = ugh.GetSteelPlnHandle\(plnid\);) S
LHL
(  //  double Zstart = steelpln.GetZ0\(\);) S
LHL
(  //  StateVector[0]=FilteredData[VtxPlane][0].x_k0;) S
LHL
(  //  StateVector[1]=FilteredData[VtxPlane][0].x_k1;) S
LHL
(  //  StateVector[2]=FilteredData[VtxPlane][0].x_k2;) S
LHL
(  //  StateVector[3]=FilteredData[VtxPlane][0].x_k3;) S
LHL
(  //  StateVector[4]=Output[4];) S
LHL
(  //  StateVector[5]=FilteredData[VtxPlane][0].x_k5;) S
PHL
LHL
(  //  Swim\(StateVector, Output, VtxPlane, Zstart, GoForward, &dS,&dRange,&dP\);) S
LHL
(  //  S+=dS; Range+=dRange; Prange+=fabs\(dP\);) S
PHL
LHL
(  //  track->SetRange\(VtxPlane,Range\);) S
LHL
(  //  track->SetdS\(VtxPlane,S\);) S
LHL
(  //}) S
PHL
(  ) S
PHL
(  ) S
LHL
(  // if Prange < 21 GeV, use this value.  Otherwise, use finder track energy, which is somewha) S
SL
(t less prone to gross errors.) S
PHL
(  ) S
LHL
(  // apply fudge factor for nominal steel thickness in ND geometry.) S
PHL
(  ) S
LHL
(  //  track->SetMomentumRange\(Prange*ecorr\);) S
LHL
(  //  CandTrackHandle* findertrack = track->GetFinderTrack\(\);) S
LHL
(  //  if\(\(\(detector==Detector::kFar && Prange>21.\) || \(detector==Detector::kNear && Prange>12.) S
SL
(\)\) && findertrack\) {track->SetMomentumRange\(findertrack->GetMomentum\(\)\);}) S
PHL
(  ) S
LHL
(  }) S
LHL
(*/) S
PHL
LHL
(/*) S
LHL
(  void InoTrackFitAlg::SetPropertiesFromFinderTrack\(CandFitTrackCamHandle &cthx\)) S
LHL
(  {) S
LHL
(  // This method is only called if the fit fails. We set properties from finder track.) S
LHL
(  // This clearly does not include fitted properties such as q/p or QPVtxError.) S
LHL
(  cout <<" InoTrackFitAlg : SetPropertiesFromFinderTrack" << endl;) S
LHL
(  cthx.SetDirCosU\(track->GetDirCosU\(\)\);) S
LHL
(  cthx.SetDirCosV\(track->GetDirCosV\(\)\);) S
LHL
(  cthx.SetDirCosZ\(track->GetDirCosZ\(\)\);) S
LHL
(  cthx.SetVtxU\(track->GetVtxU\(\)\);) S
LHL
(  cthx.SetVtxV\(track->GetVtxV\(\)\);) S
LHL
(  cthx.SetVtxZ\(track->GetVtxZ\(\)\);) S
LHL
(  cthx.SetVtxT\(track->GetVtxT\(\)\);) S
LHL
(  cthx.SetVtxPlane\(track->GetVtxPlane\(\)\);) S
PHL
LHL
(  cthx.SetEndDirCosU\(track->GetEndDirCosU\(\)\);) S
LHL
(  cthx.SetEndDirCosV\(track->GetEndDirCosV\(\)\);) S
LHL
(  cthx.SetEndDirCosZ\(track->GetEndDirCosZ\(\)\);) S
LHL
(  cthx.SetEndU\(track->GetEndU\(\)\);) S
LHL
(  cthx.SetEndV\(track->GetEndV\(\)\);) S
LHL
(  cthx.SetEndZ\(track->GetEndZ\(\)\);) S
LHL
(  cthx.SetEndT\(track->GetEndT\(\)\);) S
LHL
(  cthx.SetEndPlane\(track->GetEndPlane\(\)\);) S
PHL
EndPage
EndDSCPage
EndSheet

%%Page: 43 43
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 3064 def
/PageNumber 43 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
3276 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  cthx.SetMomentumRange\(track->GetMomentum\(\)\);) S
LHL
(  cthx.SetMomentum\(track->GetMomentum\(\)\);) S
PHL
LHL
(  cthx.SetTimeSlope\(track->GetTimeSlope\(\)\);) S
LHL
(  cthx.SetTimeOffset\(track->GetTimeOffset\(\)\);) S
LHL
(  cthx.SetTimeFitChi2\(track->GetTimeFitChi2\(\)\);) S
LHL
(  cthx.SetNTimeFitDigit\(track->GetNTimeFitDigit\(\)\);) S
LHL
(  cthx.SetTimeForwardFitRMS\(track->GetTimeForwardFitRMS\(\)\);) S
LHL
(  cthx.SetTimeForwardFitNDOF\(track->GetTimeForwardFitNDOF\(\)\);) S
LHL
(  cthx.SetTimeBackwardFitRMS\(track->GetTimeBackwardFitRMS\(\)\);) S
LHL
(  cthx.SetTimeBackwardFitNDOF\(track->GetTimeBackwardFitNDOF\(\)\);) S
PHL
PHL
LHL
(  // Set quantities required at each plane in finder track) S
LHL
(  int direction=1;) S
LHL
(  if\(ZIncreasesWithTime==false\) {direction=-1;}) S
PHL
LHL
(  for\(int i=cthx.GetVtxPlane\(\); i*direction<=cthx.GetEndPlane\(\)*direction; i+=direction\){) S
LHL
(  if\(track->IsTPosValid\(i\)\) {) S
LHL
(  cthx.SetTrackPointError\(i,track->GetTrackPointError\(i\)\);) S
LHL
(  cthx.SetdS\(i,track->GetdS\(i\)\);) S
LHL
(  cthx.SetRange\(i,track->GetRange\(i\)\);) S
LHL
(  cthx.SetU\(i,track->GetU\(i\)\);) S
LHL
(  cthx.SetV\(i,track->GetV\(i\)\);) S
LHL
(  }) S
LHL
(  }) S
PHL
LHL
(  CalculateTrace\(\); //cthx\);  ) S
LHL
(  SetT\(\); //&cthx\);) S
PHL
LHL
(  Calibrate\(\); //&cthx\);) S
PHL
LHL
(  }) S
LHL
(*/) S
PHL
LHL
(void InoTrackFitAlg::Trace\(const char * /* c */\) const) S
LHL
({;) S
LHL
(}) S
LHL
(void InoTrackFitAlg::SetT\(\) {) S
LHL
(  // we take a weighted average of clusts in the same) S
LHL
(  // plane.  the proper way to do this would be to consider clusts coming) S
LHL
(  // from the same PMT and use the earliest time.) S
PHL
(  ) S
LHL
(  //cout <<" inoTrackFitAlg : starting SetT" << endl;) S
LHL
(  //for \(unsigned ij=0; ij<fFinderTrack->ClustsInTrack.size\(\); ij++\)) S
LHL
(  //{) S
LHL
(  //}  ) S
LHL
(}) S
LHL
(void InoTrackFitAlg::GoForwards\(bool first\) {) S
LHL
(  // The bool variable 'first' denotes first iteration; for 1st half of the 1st iteration, ) S
LHL
(  // when KF pocesses hits along increasing z, first = 0. For the 1st half of subsequent) S
LHL
(  // iterations, first = 1. This is true for up going ?. For downgoing ?, it is always set to 0.) S
LHL
8 W
(//  cout<<"GoForwards_new : "<<"first = "<<first<<endl;) S
LHL
(  double x__minus[5]={0.0};) S
LHL
(  bool GoForward = true;) S
LHL
8 W
(//  cout<<"GoForward "<< GoForward<<endl;) S
PHL
(  ) S
LHL
8 W
(//  cout<<"MaxPlane "<< MaxPlane<<endl;) S
LHL
8 W
(//  cout<<"MinPlane "<< MinPlane<<endl;) S
LHL
(  Int_t StartPlane = MinPlane;) S
LHL
8 W
(//  cout<<"StartPlane "<< StartPlane<<endl;) S
LHL
8 W
(//  cout<<"EndofRangePlane "<< EndofRangePlane<<endl;) S
LHL
(  if\(!ZIncreasesWithTime\) {) S
LHL
16 W
(//    cout<<"ZIncreasesWithTime "<< ZIncreasesWithTime<<endl;) S
LHL
(    StartPlane = EndofRangePlane;) S
LHL
16 W
(//    cout<<"StartPlane "<< StartPlane<<endl;) S
LHL
(  } else { ) S
LHL
(    EndofRangePlane = MaxPlane;) S
LHL
(  }) S
PHL
(  ) S
LHL
(  unsigned ntrk = fTrackCand->GetClusterEntries\(\);) S
6 W
(// number of hits in a track\(let\)) S
LHL
8 W
(//  cout<<"ntrk "<< ntrk<<" first "<< first<<endl;) S
PHL
8 W
LHL
(  int iend = \(first\) ? 0 : 1;) S
35 W
(// when first = 0, iend = 1 an) S
SL
(d vice versa) S
PHL
(  ) S
LHL
8 W
(//  cout <<"GoForwards_new : "<<"ntrksize = "<<ntrk<<"   "<<"ntrk-iend = "<<ntrk-iend<) S
SL
(<endl;) S
EndPage
EndDSCPage
EndSheet

%%Page: 44 44
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 3140 def
/PageNumber 44 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
3354 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  for \(unsigned ijk=0; ijk<ntrk-iend; ijk++\) {) S
LHL
(    // ijk runs over the \(available number of hits - \(0 or 1\)\) in a track\(let\)) S
LHL
(    if \(!fTrackCand->ClustsInTrack[ijk]->GetStraight\(\)\) {) S
LHL
(      continue;) S
LHL
(    }) S
LHL
(    int ij = fTrackCand->ClustsInTrack[ijk]->GetZPlane\(\);) S
LHL
16 W
(//) S
14 W
(cout <<"Goforwards "<<int\(first\) <<" "<<ijk<<" "<< ij<<" "<<fT) S
SL
(rackCand->ClustsInTrack[ijk]->GetXPos\(\)<<" "<<fTrackCand->ClustsInTrack[ijk]->GetYPos\(\)<<" "<<) S
SL
(fTrackCand->ClustsInTrack[ijk]->GetZPos\(\)<<endl;) S
LHL
(    // This gives that latest plane where we have experimental data and/or filtered data) S
PHL
(    ) S
LHL
(    EndofRange = false;) S
LHL
(    // Next we find the next plane and other stuff used in the previous algorithm) S
LHL
(    if \(TrkClustsData[ij].size\(\)>0\) {) S
LHL
(      if \(PassTrack\) {) S
LHL
(        // Find Next Plane) S
LHL
(        int NewPlane=-99;) S
PHL
(        ) S
LHL
(        //if \(!first && ijk !=ntrk-1 && fTrackCand->ClustsInTrack[ijk+1]->GetStraight\(\)\)) S
LHL
(        if \(\(ijk !=ntrk-1\) && \(fTrackCand->ClustsInTrack[ijk+1]->GetStraight\(\)\)\) {) S
LHL
(          // this is done in the first half of the first iteration) S
LHL
(          NewPlane=fTrackCand->ClustsInTrack[ijk+1]->GetZPlane\(\);) S
LHL
(        }) S
PHL
(        ) S
LHL
(        if \(NewPlane!=-99\) {) S
LHL
(          // Define measurement function) S
LHL
(          int PlaneView = TrkClustsData[NewPlane][0].PlaneView;) S
LHL
(          // GMA for Clusts this condition is fine, but for cluster, this is not correct) S
LHL
(          for \(int jk=0; jk<2; jk++\) {) S
LHL
(            for \(int kl=0; kl<5; kl++\) {) S
LHL
(              H_k[jk][kl]=0;) S
LHL
(            }) S
LHL
(          }) S
LHL
(          if \(PlaneView%2==0\) {H_k[0][0]=1;}) S
LHL
(          if \(PlaneView   >0\) {H_k[1][1]=1;}) S
PHL
(          ) S
LHL
(          ds=0;) S
LHL
(          drange=0;) S
LHL
(          PredictedStateCov\(x_k_minus, ij, NewPlane, GoForward, x__minus, 0, &ds, &drange\);) S
LHL
(          CalcKalmanGain\(x__minus, NewPlane\);) S
LHL
(          KalmanFilterStateVector\(x__minus, NewPlane, GoForward,x_k\);) S
LHL
(          UpdateCovMatrix\(NewPlane\);) S
LHL
(          MoveArrays\(NewPlane,GoForward\);) S
LHL
(          if\(SaveData\) {StoreFilteredData\(NewPlane\);}) S
LHL
(          //if \(ZIncreasesWithTime && LastIteration && \(NewPlane==MaxPlane\)\)) S
LHL
(          //cout<<"reached end: P = "<<1./x_k[4]<<endl;) S
LHL
(        }) S
LHL
(        // bracket controlling legitimacy of NewPlane) S
LHL
(      }) S
LHL
(      // bracket checking if PassTrack is true) S
LHL
(    }) S
LHL
(    // bracket checking if no. of clusters > 0. // \(TrackClusterDataSize >0 ends\)) S
PHL
(    ) S
LHL
(    // JAM end of range found) S
LHL
(    if\(EndofRange && LastIteration && ZIncreasesWithTime\) {) S
LHL
(      cout<<"This is redundant - never used"<<endl;) S
LHL
(      EndofRangePlane=ij;) S
LHL
(      break;) S
LHL
(    }) S
LHL
(  }) S
LHL
(  // end of 'for' loop over available hits) S
PHL
(  ) S
LHL
(  // Store entries from covariance matrix for use in setting track properties.) S
LHL
(  if\(LastIteration\) {) S
LHL
(    if\(ZIncreasesWithTime==true\) {) S
LHL
(      //cout<<"? GF error@End"<<endl;) S
LHL
(      EndCov[0]=C_k[0][0]; EndCov[1]=C_k[1][1];) S
LHL
(      EndCov[2]=C_k[2][2]; EndCov[3]=C_k[3][3];) S
LHL
(      EndCov[4]=C_k[4][4];) S
PHL
(      ) S
LHL
(      EndState[0]=x_k[0];) S
15 W
(EndState[1]=x_k[1];) S
LHL
(      EndState[2]=x_k[2];) S
15 W
(EndState[3]=x_k[3];) S
LHL
(      EndState[4]=x_k[4];) S
LHL
(    } else {) S
LHL
(      //cout<<"? GF error@Vtx"<<endl;) S
LHL
(      VtxCov[0]=C_k[0][0]; VtxCov[1]=C_k[1][1];) S
LHL
(      VtxCov[2]=C_k[2][2]; VtxCov[3]=C_k[3][3];) S
LHL
(      VtxCov[4]=C_k[4][4];) S
EndPage
EndDSCPage
EndSheet

%%Page: 45 45
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 3216 def
/PageNumber 45 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
3432 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(    }) S
LHL
(  }) S
LHL
(}) S
PHL
LHL
(void InoTrackFitAlg::GoBackwards\(bool first\) {) S
LHL
8 W
(//  cout<<"GoBackwards_new : "<<"first = "<<first<<endl;) S
PHL
(  ) S
LHL
8 W
(// Carry out the Kalman fit along the track in the direction of decreasing z) S
LHL
8 W
(//  cout <<" InoTrackFitAlg : GoBackwards_new, carry out fit in negative z direction" ) S
SL
(<< endl;) S
PHL
(  ) S
LHL
(  double x__minus[5] = {0.0};) S
LHL
(  bool GoBackward = false;) S
PHL
(  ) S
LHL
(  Int_t StartPlane = MaxPlane;// Int_t EndPlane=MinPlane;) S
PHL
(  ) S
PHL
(  ) S
LHL
8 W
(//  cout<<"GoBackwards_new : "<<"MinPlane = "<<MinPlane<<"    "<<"EndofRangePlane = "<) S
SL
(<EndofRangePlane<<"     "<<"MaxPlane = "<<MaxPlane<<"StartPlane "<<StartPlane<<" EndofRange "<) S
SL
(<EndofRangePlane<<endl;) S
PHL
(  ) S
LHL
(  if\(ZIncreasesWithTime\) {) S
LHL
(    StartPlane = EndofRangePlane;) S
LHL
(  } else { ) S
LHL
(    EndofRangePlane = MinPlane;) S
LHL
(  }) S
LHL
8 W
(//  cout<<"GoBackwards_new : "<<"MinPlane = "<<MinPlane<<"    "<<"EndofRangePlane = "<) S
SL
(<EndofRangePlane<<"     "<<"MaxPlane = "<<MaxPlane<<"StartPlane "<<StartPlane<<" EndofRange "<) S
SL
(<EndofRangePlane<<endl;) S
PHL
(  ) S
LHL
(  int ntrk = fTrackCand->GetClusterEntries\(\);) S
LHL
(  int iend = \(first\) ? 0 : 1;) S
LHL
8 W
(//  cout<<"GoBackwards_new : "<<"ntrksize = "<<ntrk<<"      "<<"iend = "<<iend<<endl;) S
PHL
LHL
8 W
(int endNewPlane=-99;) S
LHL
(  for \(int ijk=ntrk-1; ijk>=iend; ijk--\) {) S
LHL
16 W
(//    cout<<"ijk "<<ijk<<endl;) S
LHL
(    if \(!fTrackCand->ClustsInTrack[ijk]->GetStraight\(\)\) {) S
LHL
(      cout<<"ijk "<<ijk<<endl;) S
LHL
(      continue;) S
LHL
(    }) S
LHL
(    int ij = fTrackCand->ClustsInTrack[ijk]->GetZPlane\(\);) S
LHL
(    if \(TrkClustsData[ij].size\(\)>0\) {) S
LHL
24 W
(//) S
22 W
(cout <<"Gobackwards "<<int\(first\) <<" "<<ijk<<) S
SL
(" "<< ij<<" "<<fTrackCand->ClustsInTrack[ijk]->GetXPos\(\)<<" "<<fTrackCand->ClustsInTrack[ijk]-) S
SL
(>GetYPos\(\)<<" "<<fTrackCand->ClustsInTrack[ijk]->GetZPos\(\)<<" "<<PassTrack<<endl;) S
LHL
24 W
(//      cout<<"GoBackwards_new : "<<"PassTrack = "<<PassTrack<<endl;) S
PHL
(      ) S
LHL
(      if \(PassTrack\) {) S
LHL
(        //Find Prev Plane) S
LHL
(        int NewPlane=-99;) S
11 W
(// int jk=\(ij-1\);) S
LHL
32 W
(//        cout<<"NewPlane_ "<<NewPlane<<endl;) S
LHL
(        //for \(int jk=0; jk<6; jk++\) {x_k_old[jk] = x_k_minus[jk];}) S
PHL
(        ) S
LHL
(        //a) S
5 W
(cout <<"backfirst "<<int\(first\)<<" "<<ijk<<" "<<ntrk-1<<endl;) S
LHL
(        //if \(!first && ijk !=0 && fTrackCand->ClustsInTrack[ijk-1]->GetStraight\(\)\)) S
LHL
(        if \(ijk !=0 && fTrackCand->ClustsInTrack[ijk-1]->GetStraight\(\)\) {) S
LHL
(          NewPlane=fTrackCand->ClustsInTrack[ijk-1]->GetZPlane\(\);) S
LHL
40 W
(//          cout<<"NewPlane "<<NewPlane<<endl;) S
LHL
(        }) S
LHL
(        //*****************************************************) S
LHL
(        /*) S
LHL
(          else {) S
LHL
(          if \(fTrackCand->GetEntries\(\)>=MINLAYER\) {) S
LHL
(          int plane = ij;) S
LHL
(          // int loopmx = \(\(ijk<ntrk-1\) && \(ijk>0\)\) ? ij - MinPlane : 3;) S
LHL
(          int loopmx = \(\(ijk>0\)\) ? max\(ij-MinPlane, 5\) : 4;) S
LHL
(          double dsBefore=0;) S
LHL
(          double drangeBefore=0;) S
LHL
(          /////////////////////////////////////////////////) S
LHL
(          for \(int nloop=0; nloop <loopmx; nloop++\) {) S
LHL
(          // nloop : deals with cases with considerable gap between successive hits; i.e. the ) S
SL
(hits are) S
LHL
(          // not in the consecutive planes.) S
LHL
(          if \(nloop==0\) {) S
LHL
(          //) S
60 W
(cout<<"nloop = 0 here;) S
SL
( so x_k_minus is fed to StateVector"<<endl;) S
LHL
(          for\(int kl=0; kl<6; ++kl\) {) S
EndPage
EndDSCPage
EndSheet

%%Page: 46 46
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 3285 def
/PageNumber 46 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
3510 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(          StateVector[kl]=x_k_minus[kl];) S
LHL
(          }) S
LHL
(          } else {) S
LHL
(          //) S
60 W
(cout<<"nloop != 0 here) S
SL
(; Prediction is fed to StateVector"<<endl;) S
LHL
(          for\(int kl=0; kl<6; ++kl\) {) S
LHL
(          StateVector[kl]= x__minus[kl];) S
LHL
(          }) S
LHL
(          }) S
LHL
(          double ds=0;) S
LHL
(          double drange=0;) S
LHL
(          int nextplane = -99;) S
PHL
(          ) S
LHL
(          bool GetPrediction=PredictedStateCov\(StateVector, plane, nextplane, false, Predictio) S
SL
(n, 0\); //, &ds, &drange\);) S
PHL
(          ) S
LHL
(          if \(!GetPrediction || nextplane<0 || nextplane>=int\(nLayer\)\) break;) S
PHL
(          ) S
LHL
(          if \(GetPrediction\) {) S
LHL
(          if \(nextplane > plane\) {) S
LHL
(          if \(TrkClustsData[nextplane+shiftLa].size\(\)>0\) {) S
LHL
(          StoreFilteredData_sr\(nextplane+shiftLa, x__minus, false\);) S
LHL
(          fTrackCand->f2dS[nextplane+shiftLa] =ds+dsBefore;) S
LHL
(          fTrackCand->f2Range[nextplane+shiftLa] =drange+drangeBefore;) S
LHL
(          dsBefore = drangeBefore = 0;) S
LHL
(          //) S
76 W
(cout<<) S
SL
("GB"<<"    "<<"HiHi"<<endl;) S
LHL
(          } else {) S
LHL
(          StoreFilteredData_sr\(nextplane+shiftLa, x__minus, false\);) S
LHL
(          dsBefore +=ds;) S
LHL
(          drangeBefore +=drange;) S
LHL
(          //) S
76 W
(cout<<) S
SL
("GB"<<"    "<<"HaHa"<<endl;) S
LHL
(          }) S
LHL
(          } else {) S
LHL
(          plane = nextplane;) S
LHL
(          if \(TrkClustsData[plane].size\(\) >0\) {) S
LHL
(          //) S
76 W
(cout<<) S
SL
("plane= "<<plane<<endl;) S
LHL
(          NewPlane= plane;) S
LHL
(          break;) S
LHL
(          }) S
LHL
(          //StoreFilteredData_sr\(nextplane, Prediction, true\);) S
LHL
(          StoreFilteredData_sr\(nextplane, x__minus, true\);) S
LHL
(          //) S
68 W
(cout<<"GB"<<" ) S
SL
(   "<<"HoHo"<<endl;) S
LHL
(          }) S
LHL
(          }) S
PHL
(          ) S
LHL
(          }) S
LHL
(          /////////////////////////////////////) S
LHL
(          }) S
LHL
(          }) S
LHL
(        */) S
PHL
(        ) S
LHL
(        if \(NewPlane!=-99\) {) S
LHL
(          //) S
36 W
(cout<<"GB: so new plane value has been obtaine) S
SL
(d; NewPlane = "<<NewPlane<<endl;) S
LHL
(          // Define measurement function) S
LHL
(          int PlaneView = TrkClustsData[NewPlane][0].PlaneView;) S
PHL
(          ) S
LHL
(          //GMA for Clusts this condition is fine, but for cluster, this is not correct) S
LHL
(          // Carry out the Kalman fit) S
LHL
(          for \(int jk=0; jk<2; jk++\) {) S
LHL
(            for \(int kl=0; kl<5; kl++\) {) S
LHL
(              H_k[jk][kl]=0;) S
LHL
(            }) S
LHL
(          }) S
LHL
(          if \(PlaneView%2==0\) {H_k[0][0]=1;}) S
LHL
(          if \(PlaneView   >0\) {H_k[1][1]=1;}) S
LHL
(          ds = 0.0;) S
LHL
(          drange = 0.0;) S
LHL
(          PredictedStateCov\(x_k_minus, ij ,NewPlane, GoBackward, x__minus, 0, &ds, &drange\);) S
LHL
(          CalcKalmanGain\(x__minus, NewPlane\);) S
LHL
(          KalmanFilterStateVector\(x__minus, NewPlane, GoBackward,x_k\);) S
LHL
(          UpdateCovMatrix\(NewPlane\);) S
LHL
(          MoveArrays\(NewPlane,GoBackward\);) S
LHL
40 W
(endNewPlane = NewPlane;) S
EndPage
EndDSCPage
EndSheet

%%Page: 47 47
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 3356 def
/PageNumber 47 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
3588 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(          if\(LastIteration\) {) S
LHL
(            GPL += ds;) S
LHL
(            RNG += drange;) S
LHL
(          }) S
LHL
(          if\(SaveData\) {StoreFilteredData\(NewPlane\);}) S
LHL
(          //if \(!ZIncreasesWithTime && LastIteration && \(NewPlane==MinPlane\)\)) S
LHL
(          //cout<<"reached end: P = "<<1./x_k[4]<<endl;) S
LHL
(        }) S
LHL
(      }) S
LHL
(      //else {cout <<" InoTrackFitAlg : GoBackwards, Outside detector - track failed" << endl;) S
SL
(}) S
LHL
(    }) S
PHL
16 W
PHL
PHL
PHL
16 W
LHL
(    //JAM end of range found) S
LHL
(    if\(EndofRange && LastIteration && !ZIncreasesWithTime\) {) S
LHL
(      EndofRangePlane = ij;) S
LHL
(      cout<<"ij "<<ij<<endl;) S
LHL
(      break;) S
LHL
(    }) S
LHL
(  }) S
PHL
(  ) S
LHL
(  // Store entries from covariance matrix for use in setting track properties) S
LHL
(  if\(LastIteration\) {) S
LHL
(    if\(ZIncreasesWithTime==true\) {) S
LHL
(      //cout<<"? GB error@Vtx"<<endl;) S
LHL
(      VtxCov[0]=C_k[0][0]; VtxCov[1]=C_k[1][1];) S
LHL
(      VtxCov[2]=C_k[2][2]; VtxCov[3]=C_k[3][3];) S
LHL
(      VtxCov[4]=C_k[4][4];) S
LHL
(    } else {) S
LHL
(      //cout<<"? GB error@End"<<endl;) S
LHL
(      EndCov[0]=C_k[0][0]; EndCov[1]=C_k[1][1];) S
LHL
(      EndCov[2]=C_k[2][2]; EndCov[3]=C_k[3][3];) S
LHL
(      EndCov[4]=C_k[4][4];) S
PHL
(      ) S
LHL
(      EndState[0]=x_k[0];) S
15 W
(EndState[1]=x_k[1];) S
LHL
(      EndState[2]=x_k[2];) S
15 W
(EndState[3]=x_k[3];) S
LHL
(      EndState[4]=x_k[4];) S
LHL
(    }) S
LHL
(  }) S
LHL
(}) S
PHL
PHL
LHL
(bool InoTrackFitAlg::DirectionFromFinderHitsOldFunc\(InoTrack *trk,  double& FinderPathLength, ) S
SL
(double& FinderDistance\) {) S
LHL
(  unsigned int nhits = trk->GetEntries\(\);) S
PHL
(  ) S
LHL
(  //  double ti) S
9 W
(= 0.0;) S
LHL
(  double sum_iT) S
1 W
(= 0.0;) S
LHL
(  double sum_iZ) S
1 W
(= 0.0;) S
LHL
(  double sum_iTZ) S
8 W
(= 0.0;) S
LHL
(  double sum_i2T) S
8 W
(= 0.0;) S
PHL
LHL
(  unsigned Nhit = nhits-1;) S
PHL
(  ) S
LHL
(  for\(unsigned ij = 0; ij < Nhit; ij++\) {) S
LHL
(    sum_iT) S
6 W
(+= trk->ClustsInTrack[ij]->GetTime\(\);) S
LHL
(    sum_iZ) S
6 W
(+= trk->ClustsInTrack[ij]->GetZPos\(\);) S
LHL
(    sum_iTZ) S
5 W
(+= trk->ClustsInTrack[ij]->GetTime\(\)*trk->ClustsInTrack[ij]->GetZPos\(\);) S
LHL
(    sum_i2T += trk->ClustsInTrack[ij]->GetTime\(\)*trk->ClustsInTrack[ij]->GetTime\(\);) S
LHL
(  }) S
LHL
(  double dZdT = 0.0;) S
LHL
(  dZdT = \(sum_iTZ - \(sum_iT * sum_iZ\)/Nhit\)/\(sum_i2T-\(sum_iT*sum_iT\)/Nhit\);) S
PHL
(  ) S
LHL
(  for\(unsigned jk = 0; jk < nhits; jk++\) {) S
LHL
(    if \(jk>0\) {) S
LHL
(      FinderPathLength +=pow\(pow\(trk->ClustsInTrack[jk]->GetXPos\(\) - trk->ClustsInTrack[jk-1]-) S
SL
(>GetXPos\(\), 2.\) +) S
LHL
29 W
(pow\(trk->ClustsInTrack[jk]->GetYPos\(\) - trk->ClustsInTrack[jk-1]-) S
SL
(>GetYPos\(\), 2.\) +) S
LHL
(                             pow\(trk->ClustsInTrack[jk]->GetZPos\(\) - trk->ClustsInTrack[jk-1]-) S
SL
(>GetZPos\(\), 2.\), 0.5\);) S
LHL
(    }) S
LHL
(  }) S
LHL
(  FinderDistance = sqrt\(\(trk->ClustsInTrack[nhits-1]->GetXPos\(\) - trk->ClustsInTrack[0]->GetXP) S
SL
(os\(\)\)*\(trk->ClustsInTrack[nhits-1]->GetXPos\(\) - trk->ClustsInTrack[0]->GetXPos\(\)\) + \(trk->Clus) S
EndPage
EndDSCPage
EndSheet

%%Page: 48 48
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 3427 def
/PageNumber 48 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
3666 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(tsInTrack[nhits-1]->GetYPos\(\) - trk->ClustsInTrack[0]->GetYPos\(\)\)*\(trk->ClustsInTrack[nhits-1]) S
SL
(->GetYPos\(\) - trk->ClustsInTrack[0]->GetYPos\(\)\) + \(trk->ClustsInTrack[nhits-1]->GetZPos\(\) - tr) S
SL
(k->ClustsInTrack[0]->GetZPos\(\)\)*\(trk->ClustsInTrack[nhits-1]->GetZPos\(\) - trk->ClustsInTrack[0) S
SL
(]->GetZPos\(\)\)\);) S
PHL
(  ) S
LHL
(  return \(dZdT>0.0\) ? true : false;) S
PHL
(  ) S
LHL
(}) S
PHL
LHL
(bool InoTrackFitAlg::DirectionFromFinderHits\(InoTrack *trk,  double& FinderPathLength, double&) S
SL
( FinderDistance\) {) S
LHL
8 W
(//  cout<< "  InoTrackFitAlg::DirectionFromFinderHits " <<endl;) S
LHL
(  int nhits = trk->GetEntries\(\);) S
PHL
(  ) S
LHL
(  double szxy=0, sz=0, sxy=0, sn=0, sz2=0;) S
LHL
(  //  int nused = 0;) S
LHL
(  double errsq=TimeError*TimeError;) S
LHL
(  for\(int ij = 0; ij < nhits; ij++\) {) S
LHL
(    // cout<<"ZPos = "<<trk->ClustsInTrack[ij]->GetZPos\(\)<<", Time = "<<trk->ClustsInTrack[ij]) S
SL
(->GetTime\(\)<<endl;) S
LHL
(    // for \(unsigned int ix=0; ix<trk->ClustsInTrack[ij]->HitsInCluster.size\(\); ix++\) {) S
LHL
(    //   cout<<" ix "<<ij<<" "<< ix<<" ") S
LHL
(    // ) S
3 W
(<<setw\(6\)<<trk->ClustsInTrack[ij]->GetZPos\(\)<<" ") S
LHL
(    // ) S
3 W
(<<setw\(6\)<<trk->ClustsInTrack[ij]->GetTime\(\)<<" ") S
LHL
(    // ) S
3 W
(<<setw\(6\)<<trk->ClustsInTrack[ij]->HitsInCluster[ix]->GetTime\(\)<<" ") S
LHL
(    // ) S
1 W
(//      <<setw\(6\)<<trk->ClustsInTrack[ij]->HitsInCluster[ix]->GetTrueTime\(\)<<" ") S
LHL
(    // ) S
3 W
(<<setw\(6\)<<trk->ClustsInTrack[ij]->HitsInCluster[ix]->GetXTime\(\)<<" ") S
LHL
(    // ) S
3 W
(<<setw\(6\)<<trk->ClustsInTrack[ij]->HitsInCluster[ix]->GetXTimeCorr\(\)<<" ") S
LHL
(    // ) S
3 W
(<<setw\(6\)<<trk->ClustsInTrack[ij]->HitsInCluster[ix]->GetXTrueTime\(\)<<" ") S
PHL
8 W
LHL
(    // ) S
3 W
(<<setw\(6\)<<trk->ClustsInTrack[ij]->HitsInCluster[ix]->GetYTime\(\)<<" ") S
LHL
(    // ) S
3 W
(<<setw\(6\)<<trk->ClustsInTrack[ij]->HitsInCluster[ix]->GetYTimeCorr\(\)<<" ") S
LHL
(    // ) S
3 W
(<<setw\(6\)<<trk->ClustsInTrack[ij]->HitsInCluster[ix]->GetYTrueTime\(\)<<" ") S
PHL
8 W
LHL
(    // ) S
3 W
(<<setw\(6\)<<trk->ClustsInTrack[ij]->HitsInCluster[ix]->GetXStripNum\(\)<<" ") S
LHL
(    // ) S
3 W
(<<setw\(6\)<<trk->ClustsInTrack[ij]->HitsInCluster[ix]->GetYStripNum\(\)<<" ") S
LHL
(    // ) S
3 W
(<<endl;) S
LHL
(    // }) S
LHL
(    szxy +=trk->ClustsInTrack[ij]->GetZPos\(\)*trk->ClustsInTrack[ij]->GetTime\(\)/errsq;) S
LHL
(    sz +=trk->ClustsInTrack[ij]->GetZPos\(\)/errsq;) S
LHL
(    sz2 +=trk->ClustsInTrack[ij]->GetZPos\(\)*trk->ClustsInTrack[ij]->GetZPos\(\)/errsq;) S
LHL
(    sxy +=trk->ClustsInTrack[ij]->GetTime\(\)/errsq;) S
LHL
(    sn +=1/errsq;) S
LHL
(    //    nused++;) S
6 W
LHL
(  }) S
LHL
(  double dZdT = 0.0;) S
LHL
(  if \(\(sz2*sn - sz*sz\) !=0\) { ) S
LHL
(    dZdT = \(szxy*sn - sz*sxy\)/\(sz2*sn - sz*sz\); //\(sum_iTZ - \(sum_iT * sum_iZ\)/nhits\)/\(sum_i2T) S
SL
(-\(sum_iT*sum_iT\)/nhits\);) S
LHL
(  }) S
PHL
(  ) S
LHL
(  for\(int jk = 1; jk < nhits; jk++\) {) S
LHL
(    FinderPathLength +=pow\(pow\(trk->ClustsInTrack[jk]->GetXPos\(\) - trk->ClustsInTrack[jk-1]->G) S
SL
(etXPos\(\), 2.\) +) S
LHL
(                           pow\(trk->ClustsInTrack[jk]->GetYPos\(\) - trk->ClustsInTrack[jk-1]->G) S
SL
(etYPos\(\), 2.\) +) S
LHL
(                           pow\(trk->ClustsInTrack[jk]->GetZPos\(\) - trk->ClustsInTrack[jk-1]->G) S
SL
(etZPos\(\), 2.\), 0.5\);) S
LHL
(  }) S
PHL
(  ) S
LHL
(  FinderDistance = sqrt\() S
LHL
(                        \(trk->ClustsInTrack[nhits-1]->GetXPos\(\) - trk->ClustsInTrack[0]->GetXP) S
SL
(os\(\)\)*) S
LHL
(                        \(trk->ClustsInTrack[nhits-1]->GetXPos\(\) - trk->ClustsInTrack[0]->GetXP) S
SL
(os\(\)\) + ) S
LHL
(                        \(trk->ClustsInTrack[nhits-1]->GetYPos\(\) - trk->ClustsInTrack[0]->GetYP) S
SL
(os\(\)\)*) S
LHL
(                        \(trk->ClustsInTrack[nhits-1]->GetYPos\(\) - trk->ClustsInTrack[0]->GetYP) S
SL
(os\(\)\) + ) S
LHL
(                        \(trk->ClustsInTrack[nhits-1]->GetZPos\(\) - trk->ClustsInTrack[0]->GetZP) S
SL
(os\(\)\)*) S
LHL
(                        \(trk->ClustsInTrack[nhits-1]->GetZPos\(\) - trk->ClustsInTrack[0]->GetZP) S
SL
(os\(\)\)\);) S
PHL
(  ) S
LHL
(  return \(dZdT>0.0\) ? true : false;) S
LHL
(}) S
PHL
LHL
(void InoTrackFitAlg::GetPropagator\(double *istate, double Bx, double By, double dBxdx, double ) S
EndPage
EndDSCPage
EndSheet

%%Page: 49 49
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 3489 def
/PageNumber 49 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
3744 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(dBydx, double dBxdy, double dBydy, double dz, TGeoMaterial* material\) {) S
LHL
(  for \(int ij=0; ij<5; ++ij\) {) S
LHL
(    for \(int jk=0; jk<5; ++jk\) {) S
LHL
(      F_k_minus[ij][jk]=0;  ) S
LHL
(    }) S
LHL
(  }) S
PHL
(  ) S
LHL
(  double x=0;) S
3 W
(double y = 0;) S
3 W
(double tx = 0;) S
10 W
(double ty = 0;) S
10 W
(double qbyP = ) S
SL
(0;) S
LHL
(  x=istate[0];) S
2 W
(y=istate[1];) S
4 W
(tx) S
6 W
(=istate[2];) S
13 W
(ty) S
6 W
(=istate[3];) S
11 W
SL
2 W
(qbyP=istate[4];) S
PHL
(  ) S
LHL
(  double) S
8 W
(P = 0.0;) S
LHL
(  double E = 0.0;) S
LHL
(  double b = 0.0;) S
LHL
(  double dE= 0.0;) S
LHL
(  //  double q = 0.0;) S
LHL
(  double d = 0.0;) S
LHL
(  double f = 0.0;) S
LHL
(  double ag = 0.0;) S
LHL
(  double tB= 0.0;) S
PHL
(  ) S
LHL
(  P) S
5 W
(= fabs\(1/qbyP\);) S
LHL
(  if \(P >= 100.0000\) {) S
LHL
(    P = 100.0000000000;) S
25 W
(// This is to make sure that the calculation d) S
SL
(oes not blow up in the 1st step) S
LHL
(  }) S
LHL
(  E = sqrt\(P*P + 0.1056*0.1056\);) S
LHL
(  b = P/E;) S
PHL
(  ) S
LHL
(  double kappa) S
2 W
(= 0.299792458000000;) S
LHL
(  double T = sqrt\(1 + tx*tx + ty*ty\);) S
LHL
(  if\(ZIncreasesWithTime==false\) T=-T;) S
LHL
(  double B = sqrt\(Bx*Bx + By*By\);) S
LHL
(  double T2= \(1 + tx*tx + ty*ty\);) S
LHL
(  double h = kappa  *  qbyP  * T;) S
LHL
(  //  double RoC = 0.000000000000000;) S
LHL
(  if \(\(Bx != 0.0\) && \(By != 0.0\)\) {) S
LHL
(    tB) S
2 W
(= \(tx*Bx+ty*By\)/\(fabs\(T\)*B\);) S
LHL
(  }) S
LHL
(  d = material->GetDensity\(\);) S
LHL
8 W
(//  cout<<"density "<<d<<"     name "<<material->GetName\(\)<<endl;) S
PHL
(  ) S
LHL
(  double Z) S
6 W
(= material->GetZ\(\);) S
PHL
(  ) S
LHL
(  if \(ZIncreasesWithTime == true\) {) S
LHL
(    dE =-BetheBloch * d * 1.e-1*fabs\(T\)*dz;) S
LHL
(  } else {) S
LHL
(    dE = BetheBloch * d * 1.e-1*fabs\(T\)*dz;) S
LHL
(  }) S
LHL
(  f  = \(1.0 - 2.0*dE/\(b*P\)\);) S
LHL
(  ag  = \(1.0 - 1.0*dE/\(b*P\)\);) S
PHL
(  ) S
LHL
(  double F40 = 0.0;) S
LHL
(  double F41 = 0.0;) S
LHL
(  double F42 = 0.0;) S
LHL
(  double F43 = 0.0;) S
LHL
(  double F44 = 0.0;) S
PHL
(  ) S
LHL
(  double RangeZ = 0.0;) S
LHL
(  double d1fdr1 = 0.0;) S
LHL
(  double d2fdr2 = 0.0;) S
LHL
(  double d3fdr3 = 0.0;) S
LHL
(  double d4fdr4 = 0.0;) S
LHL
(  double Nepsln = 0.0;) S
PHL
8 W
LHL
(  if \(Z == 6.0 || Z == 10.8046 || Z == 13.0 || Z == 26.0 || Z == 29.0\) {) S
LHL
(    RangeZ = IcalRange->MaterialMuRange\(Z,P\);) S
LHL
(    d1fdr1 = IcalRange->FirstDerivative\(RangeZ,Z\);) S
LHL
(    d2fdr2 = IcalRange->SecndDerivative\(RangeZ,Z\);) S
LHL
(    d3fdr3 = IcalRange->ThirdDerivative\(RangeZ,Z\);) S
LHL
(    d4fdr4 = IcalRange->FourthDerivative\(RangeZ,Z\);) S
LHL
(  }) S
LHL
(  if \(Z == 6.0 || Z == 10.8046 || Z == 13.0 || Z == 26.0 || Z == 29.0\) {) S
LHL
(    //Nepsln = \(d2fdr2/d1fdr1\)*1.e2*d*dz;) S
LHL
(    Nepsln = \(d2fdr2/d1fdr1\)*1.e2*d*T*dz + \(d3fdr3/\(2.0*d1fdr1\)\)*pow\(1.e2*d*T*dz,2.0\) + \(d4fdr) S
SL
(4/\(6.0*d1fdr1\)\)*pow\(1.e2*d*T*dz,3.0\);) S
LHL
(  }) S
EndPage
EndDSCPage
EndSheet

%%Page: 50 50
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 3563 def
/PageNumber 50 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
3822 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  ) S
LHL
(  F40 = d1fdr1 * kappa * qbyP *T* 1.e2 *d* dz * Bx;) S
LHL
(  F41 = d1fdr1 * kappa * qbyP *T* 1.e2 *d* dz * By;) S
LHL
(  F42 = d1fdr1 * \(tx/T\) * 1.e2 *d* dz;) S
LHL
(  F43 = d1fdr1 * \(ty/T\) * 1.e2 *d* dz;) S
PHL
(  ) S
LHL
(  if \(Z == 6.0 || Z == 10.8046 || Z == 13.0 || Z == 26.0 || Z == 29.0\) {) S
LHL
(    F44 = 1.0 + Nepsln;) S
LHL
(  } else {) S
LHL
(    F44 = 1.0;) S
LHL
(  }) S
PHL
(  ) S
LHL
(  double Rx= Bx * dz * h;) S
LHL
(  double Ry= By * dz * h;) S
LHL
(  double Sx= 0.5 * Bx * pow\(dz,2\) * h;) S
LHL
(  double Sy= 0.5 * By * pow\(dz,2\) * h;) S
PHL
(  ) S
LHL
(  double tx_ty = tx*ty;) S
LHL
(  double _1_3txsq_tysq = 1+3*pow\(tx,2\)+pow\(ty,2\);) S
LHL
(  double _1_txsq_3tysq = 1+pow\(tx,2\)+3*pow\(ty,2\);) S
LHL
(  double _1_3tysq = 1+3*pow\(ty,2\);) S
LHL
(  double _1_3txsq = 1+3*pow\(tx,2\);) S
LHL
(  double _1_txsq = 1+pow\(tx,2\);) S
LHL
(  double _1_tysq = 1+pow\(ty,2\);) S
LHL
(  double _4_6txsq_3tysq = 4+6*pow\(tx,2\)+3*pow\(ty,2\);) S
LHL
(  double _4_3txsq_6tysq = 4+3*pow\(tx,2\)+6*pow\(ty,2\);) S
LHL
(  double _1_6txsq_5tx4_tysq_3tx_tysq = 1+6*pow\(tx,2\)+5*pow\(tx,4\)+pow\(ty,2\)*3*pow\(\(tx_ty\),2\);) S
LHL
(  double _1_6tysq_5ty4_txsq_3tx_tysq = 1+6*pow\(ty,2\)+5*pow\(ty,4\)+pow\(tx,2\)+3*pow\(\(tx_ty\),2\);) S
LHL
(  double S_xx =\(1/6\)*Bx*Bx*pow\(dz,3\);) S
LHL
(  double S_xy =\(1/6\)*Bx*By*pow\(dz,3\);) S
LHL
(  double S_yx =\(1/6\)*By*Bx*pow\(dz,3\);) S
LHL
(  double S_yy =\(1/6\)*By*By*pow\(dz,3\);) S
LHL
(  double R_xx =\(1/2\)*Bx*Bx*pow\(dz,2\);) S
LHL
(  double R_xy =\(1/2\)*Bx*By*pow\(dz,2\);) S
LHL
(  double R_yx =\(1/2\)*By*Bx*pow\(dz,2\);) S
LHL
(  double R_yy =\(1/2\)*By*By*pow\(dz,2\);) S
PHL
(  ) S
LHL
(  //------------------------------------------------------------------) S
LHL
(  //cout<<"material "<<material->GetName\(\)<<"    Z "<<material->GetZ\(\)<<"    dz "<<dz<<"    T ) S
SL
("<<T<<"    tx "<<tx<<"    ty "<<ty<<"    qp "<<qbyP<<endl;) S
LHL
(  //--------------------Beginning of first row:-----------------------) S
PHL
(  ) S
LHL
(  F_k_minus[0][0] = 1.0 + \(h/2.0\)*\(T*dz*dz\)*\(tx*ty*dBxdx-\(1.0+tx*tx\)*dBydx\);) S
PHL
(  ) S
LHL
(  F_k_minus[0][1] = \(h/2.0\)*\(T*dz*dz\)*\(tx*ty*dBxdy-\(1+tx*tx\)*dBydy\);) S
PHL
(  ) S
LHL
(  F_k_minus[0][2] = dz+Sx*\(\(\(ty*pow\(tx,2\)\)/T2\)+ty\)-Sy*\(\(\(tx*\(pow\(tx,2\)+1\)\)/T2\)+2*tx\)+) S
LHL
(    pow\(h,2\) * \( \(\(_1_3txsq_tysq * _1_3tysq\)/T2\) * S_xx - 2*tx_ty*\(_4_6txsq_3tysq/T2\) * S_xy -) S
SL
( 2*tx_ty*\(_4_6txsq_3tysq/T2\) * S_yx + 3*\(_1_6txsq_5tx4_tysq_3tx_tysq/T2\)* S_yy\);) S
PHL
(  ) S
LHL
(  F_k_minus[0][3] = Sx*\(\(\(tx*pow\(ty,2\)\)/T2\)+tx\)-Sy*\(\(ty*\(pow\(tx,2\)+1\)\)/T2\)+) S
LHL
(    pow\(h,2\) * \( 2*tx_ty*\(_4_3txsq_6tysq/T2\)* S_xx - \(\(_1_3txsq*_1_txsq_3tysq\)/T2\) * S_xy - \(\() S
SL
(_1_3txsq*_1_txsq_3tysq\)/T2\) * S_yx + 6*tx_ty*\(_1_txsq/T2\)* S_yy\);) S
PHL
(  ) S
LHL
(  /*F_k_minus[0][4] = f*kappa*T*\(\(0.5*Bx*pow\(dz,2\)\)*tx*ty-\(0.5*By*pow\(dz,2\)\)*\(pow\(tx,2\)+1\)\) + ) S
SL
(2*f*ag*h*kappa*T*\( tx * _1_3tysq * S_xx - ty* _1_3txsq * S_xy - ty* _1_3txsq * S_yx + 3 * tx *) S
SL
(_1_txsq * S_yy\);*/) S
LHL
(  F_k_minus[0][4] = kappa*T*\(\(0.5*Bx*pow\(dz,2\)\)*tx*ty-\(0.5*By*pow\(dz,2\)\)*\(pow\(tx,2\)+1\)\)+) S
LHL
(    2 * qbyP * pow\(kappa,2\) * T2 * \( tx * _1_3tysq * S_xx - ty* _1_3txsq * S_xy - ty* _1_3txsq) S
SL
( * S_yx + 3 * tx *_1_txsq * S_yy\);) S
PHL
(  ) S
LHL
(  //-----------------------End of first row-----------------------) S
LHL
(  //**************************************************************) S
LHL
(  //-------------------Beginning of second row:-------------------) S
LHL
(  F_k_minus[1][0] = \(h/2.0\)*\(T*dz*dz\)*\(\(1.0+ty*ty\)*dBxdx-tx*ty*dBydx\);) S
PHL
8 W
LHL
(  F_k_minus[1][1] = 1.0 + \(h/2.0\)*\(T*dz*dz\)*\(\(1+ty*ty\)*dBxdy-tx*ty*dBydy\);) S
PHL
(  ) S
LHL
(  F_k_minus[1][2] = Sx*\(\(tx*\(pow\(ty,2\)+1\)\)/T2\)-Sy*\(\(\(ty*pow\(tx,2\)\)/T2\)+ty\)+) S
LHL
(    pow\(h,2\) * \( 6 *tx_ty*\(_1_tysq/T2\)* S_xx - \(\(_1_3txsq_tysq*_1_3tysq\)/T2\)* S_xy - \(\(_1_3txs) S
SL
(q_tysq*_1_3tysq\)/T2\)* S_yx + \(_4_6txsq_3tysq/T2\)* S_yy\);) S
PHL
(  ) S
LHL
(  F_k_minus[1][3] = dz+Sx*\(\(\(ty*\(pow\(ty,2\)+1\)\)/T2\)+2*ty\)-Sy*\(\(\(tx*pow\(ty,2\)\)/T2\)+tx\)+) S
LHL
(    pow\(h,2\) * \( 3 * \(_1_6tysq_5ty4_txsq_3tx_tysq/T2\) * S_xx - 2 * tx_ty * \(_4_3txsq_6tysq/T2\)) S
SL
( * S_xy - 2 * tx_ty * \(_4_3txsq_6tysq/T2\) * S_yx + \(\(_1_3txsq_tysq*_1_txsq_3tysq\)/T2\) * S_yy\);) S
PHL
(  ) S
LHL
(  /*F_k_minus[1][4] = f*kappa*T*\(\(0.5*Bx*pow\(dz,2\)\)*\(pow\(ty,2\)+1\)-\(0.5*By*pow\(dz,2\)\)*\(tx*ty\)\) ) S
SL
(+ 2*f*ag*h*kappa*T*\( 3*ty*\(_1_tysq/T2\)* S_xx - tx * \(_1_3tysq/T2\) * S_xy - tx * \(_1_3tysq/T2\) ) S
EndPage
EndDSCPage
EndSheet

%%Page: 51 51
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 3631 def
/PageNumber 51 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
3900 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(* S_yx + ty *\(_1_3txsq/T2\) * S_yy\);*/) S
LHL
(  F_k_minus[1][4] = kappa*T*\(\(0.5*Bx*pow\(dz,2\)\)*\(pow\(ty,2\)+1\)-\(0.5*By*pow\(dz,2\)\)*\(tx*ty\)\)+) S
LHL
(    2 * qbyP * pow\(kappa,2\) * T2 * \( 3*ty*\(_1_tysq/T2\)* S_xx - tx * \(_1_3tysq/T2\) * S_xy - tx ) S
SL
(* \(_1_3tysq/T2\) * S_yx + ty *\(_1_3txsq/T2\) * S_yy\);) S
PHL
(  ) S
LHL
(  //----------------------End of second row-----------------------) S
LHL
(  //**************************************************************) S
LHL
(  //-------------------Beginning of third row:--------------------) S
LHL
(  F_k_minus[2][0] = T*h*dz*\(tx*ty*dBxdx-\(1.0+tx*tx\)*dBydx\);) S
PHL
(  ) S
LHL
(  F_k_minus[2][1] = T*h*dz*\(tx*ty*dBxdy-\(1.0+tx*tx\)*dBydy\);) S
PHL
(  ) S
LHL
(  F_k_minus[2][2] = \(1+Rx*\(ty+\(\(ty*pow\(tx,2\)\)/T2\)\)-Ry*\(2*tx+\(\(tx*\(pow\(tx,2\)+1\)\)/T2\)\)+) S
LHL
21 W
(pow\(h,2\) * \( \(\(_1_3txsq_tysq * _1_3tysq\)/T2\) * R_xx - 2*tx_ty*\(_4_6txsq_3) S
SL
(tysq/T2\) * R_xy - 2*tx_ty*\(_4_6txsq_3tysq/T2\) * R_yx + 3*\(_1_6txsq_5tx4_tysq_3tx_tysq/T2\)* R_y) S
SL
(y\)\);) S
PHL
(  ) S
LHL
(  F_k_minus[2][3] = Rx*\(tx+\(\(tx*pow\(ty,2\)\)/T2\)\)-Ry*\(\(ty*\(pow\(tx,2\)+1\)\)/T2\)+) S
LHL
(    pow\(h,2\) * \( 2*tx_ty*\(_4_3txsq_6tysq/T2\)* R_xx - \(\(_1_3txsq*_1_txsq_3tysq\)/T2\) * R_xy - \(\() S
SL
(_1_3txsq*_1_txsq_3tysq\)/T2\) * R_yx + 6*tx_ty*\(_1_txsq/T2\)* R_yy\);) S
PHL
(  ) S
LHL
(  /*F_k_minus[2][4] = f*kappa*T*\(\(Bx*dz\)*tx*ty-\(By*dz\)*\(pow\(tx,2\)+1\)\) + 2*f*ag*h*kappa*T*\( tx ) S
SL
(* _1_3tysq * R_xx - ty* _1_3txsq * R_xy - ty* _1_3txsq * R_yx + 3 * tx *_1_txsq * R_yy\);*/) S
LHL
(  F_k_minus[2][4] = kappa*T*\(\(Bx*dz\)*tx*ty-\(By*dz\)*\(pow\(tx,2\)+1\)\)+) S
LHL
(    2 * qbyP * pow\(kappa,2\) * T2 * \( tx * _1_3tysq * R_xx - ty* _1_3txsq * R_xy - ty* _1_3txsq) S
SL
( * R_yx + 3 * tx *_1_txsq * R_yy\);) S
PHL
(  ) S
LHL
(  //-----------------------End of third row-----------------------) S
LHL
(  //**************************************************************) S
LHL
(  //------------------Beginning of fourth row:--------------------) S
LHL
(  F_k_minus[3][0] = T*h*dz*\(\(1.0+ty*ty\)*dBxdx-tx*ty*dBydx\);) S
PHL
(  ) S
LHL
(  F_k_minus[3][1] = T*h*dz*\(\(1.0+ty*ty\)*dBxdy-tx*ty*dBydy\);) S
PHL
(  ) S
LHL
(  F_k_minus[3][2] = Rx*\(\(tx*\(pow\(ty,2\)+1\)\)/T2\)-Ry*\(ty+\(\(ty*pow\(tx,2\)\)/T2\)\)+) S
LHL
(    pow\(h,2\) * \( 6 *tx_ty*\(_1_tysq/T2\)* R_xx - \(\(_1_3txsq_tysq*_1_3tysq\)/T2\)* R_xy - \(\(_1_3txs) S
SL
(q_tysq*_1_3tysq\)/T2\)* R_yx + \(_4_6txsq_3tysq/T2\)* R_yy\);) S
PHL
(  ) S
LHL
(  F_k_minus[3][3] = \(1+Rx*\(2*ty+\(\(ty*\(pow\(ty,2\)+1\)\)/T2\)\)-Ry*\(tx+\(\(tx*pow\(ty,2\)\)/T2\)\)+) S
LHL
21 W
(pow\(h,2\) * \( 3 * \(_1_6tysq_5ty4_txsq_3tx_tysq/T2\) * R_xx - 2 * tx_ty * \(_) S
SL
(4_3txsq_6tysq/T2\) * R_xy - 2 * tx_ty * \(_4_3txsq_6tysq/T2\) * R_yx + \(\(_1_3txsq_tysq*_1_txsq_3t) S
SL
(ysq\)/T2\) * R_yy\)\);) S
PHL
(  ) S
LHL
(  /*F_k_minus[3][4] = f*kappa*T*\(\(Bx*dz\)*\(pow\(ty,2\)+1\)-\(By*dz\)*\(tx*ty\)\) + 2*f*ag*h*kappa*T*\( 3) S
SL
(*ty*\(_1_tysq/T2\)* R_xx - tx * \(_1_3tysq/T2\) * R_xy - tx * \(_1_3tysq/T2\) * R_yx + ty *\(_1_3txsq) S
SL
(/T2\) * R_yy\);*/) S
LHL
(  F_k_minus[3][4] = kappa*T*\(\(Bx*dz\)*\(pow\(ty,2\)+1\)-\(By*dz\)*\(tx*ty\)\)+) S
LHL
(    2 * qbyP * pow\(kappa,2\) * T2 * \( 3*ty*\(_1_tysq/T2\)* R_xx - tx * \(_1_3tysq/T2\) * R_xy - tx ) S
SL
(* \(_1_3tysq/T2\) * R_yx + ty *\(_1_3txsq/T2\) * R_yy\);) S
PHL
(  ) S
LHL
(  //----------------------End of fourth row-----------------------) S
LHL
(  //**************************************************************) S
LHL
(  //-------------------Beginning of fifth row:--------------------) S
14 W
PHL
(      ) S
LHL
(  F_k_minus[4][0] = F40;) S
LHL
(  F_k_minus[4][1] = F41;) S
LHL
(  F_k_minus[4][2] = F42;) S
LHL
(  F_k_minus[4][3] = F43;) S
LHL
(  F_k_minus[4][4] = F44;) S
LHL
(  for\(int ij=0; ij<5; ij++\) {) S
LHL
(    for\(int jk = 0; jk<5; jk++\) {) S
LHL
(      bool za; za=std::isnan\(F_k_minus[ij][jk]\); ) S
LHL
(      if\(za==true\) { cout<<"F["<<ij<<"]["<<jk<<"]"<<endl;) S
LHL
(      }) S
LHL
(    }) S
LHL
(  }) S
LHL
(}) S
PHL
LHL
(bool InoTrackFitAlg::PredictedStateCov\(double *StateVector, const int Plane, int &NewPlane, co) S
SL
(nst bool GoForward, double* x__minus, int isHalf, double* dS, double* Range\) { //, double* dE\)) S
SL
( {) S
LHL
8 W
(//  cout<<"=============== Entered InoTrackFitAlg::PredictedStateCov ==============="<) S
SL
(<endl;) S
PHL
LHL
(  int projPlane= NewPlane;) S
PHL
(  ) S
LHL
(  int) S
11 W
(DiffPlane;) S
46 W
(DiffPlane = \(NewPlane>) S
SL
(0 && \(!isHalf\)\) ? abs\(NewPlane - Plane\) : 1;) S
EndPage
EndDSCPage
EndSheet

%%Page: 52 52
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 3693 def
/PageNumber 52 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
3978 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  cout<<"PredictedStateCov :isHalf "<<isHalf<<" NewPlane "<<NewPlane<<" Plane "<<Plane<<" GoFo) S
SL
(rward "<<GoForward<<" DiffPlane "<<DiffPlane<<endl;) S
LHL
(  double epsilon=1.e-6;) S
33 W
(//1micron shift in extrapolation) S
PHL
(  ) S
LHL
(  //  double GPos[3]={0.0};) S
LHL
(  double UxPos[3]={0.0};) S
LHL
(  double UyPos[3]={0.0};) S
LHL
(  double UxxPos[3]={0.0};) S
LHL
(  double UyyPos[3]={0.0};) S
LHL
(  double MPos[3]={0.0};) S
LHL
(  double DxPos[3]={0.0};) S
LHL
(  double DyPos[3]={0.0};) S
LHL
(  double DxxPos[3]={0.0};) S
LHL
(  double DyyPos[3]={0.0};) S
LHL
(  double dBxdx = 0.0;) S
LHL
(  double dBxdy = 0.0;) S
LHL
(  double dBydx = 0.0;) S
LHL
(  double dBydy = 0.0;) S
PHL
(  ) S
LHL
(  //Mpos denote the starting \(x,y,z\) of the particle right at the RPC \(mm\)) S
LHL
(  MPos[0]=StateVector[0] * 1000;) S
LHL
(  MPos[1]=StateVector[1] * 1000;) S
LHL
(  MPos[2]=ZPosLayer[Plane]*1.e3;) S
PHL
(  ) S
LHL
8 W
(//  cout<<"...........................................................................) S
SL
(......."<<endl;) S
LHL
8 W
(//  cout<<"X "<<1.e-3*MPos[0]<<" Y "<<1.e-3*MPos[1]<<" Z "<<1.e-3*MPos[2]<<"     NIter) S
SL
( "<<NIter<<endl;) S
LHL
8 W
(//  cout<<"Plane number "<<Plane<<" to "<<NewPlane<<" "<<ZPosLayer[Plane]<<" with inpu) S
SL
(t P "<<1./max\(1.e-6,StateVector[4]\)<<"     N "<<NIter<<endl;) S
LHL
16 W
(cout <<"StateVector";  for\(int ij = 0; ij<5; ij++\){cout<<" "<<ij<<" "<<StateVe) S
SL
(ctor[ij];} cout<<endl;) S
PHL
8 W
LHL
8 W
(//) S
6 W
(if\(StateVector[ij]==0.0\) {cout<<"something wrong"<<"     "<<NIter<<"     "<<Go) S
SL
(Forward<<"     "<<Plane<<"     "<<NewPlane<<"     "<<MinPlane<<"     "<<MaxPlane<<endl;}) S
PHL
8 W
LHL
(  Double_t posTrack[3]={0.0};) S
LHL
(  Double_t dirTrack[3]={0.0};) S
LHL
8 W
(//) S
6 W
(cout<<"ZIncreasesWithTime "<<ZIncreasesWithTime<<endl;) S
LHL
(  int initsign=\(ZIncreasesWithTime != GoForward\) ? -1 : 1;) S
LHL
(  int) S
3 W
(nstep) S
3 W
(= 0;) S
44 W
LHL
(  //Do not go to infinite loop) S
LHL
(  int) S
3 W
(nstepmx) S
1 W
(= 100000000;) S
LHL
(  double dzFe = 0;) S
LHL
(  double dznF = 0;) S
LHL
8 W
(//) S
6 W
(cout<<"DiffPlane "<<DiffPlane<<endl;) S
LHL
(  for \(int ij = 1; ij <= DiffPlane; ij++\) {) S
LHL
16 W
(//) S
8 W
(cout<<"DiffPlane "<<DiffPlane<<endl;) S
LHL
(    double i1state[5];double i2state[5]; double i3state[5]={0.0};) S
LHL
(    // i1state is the vector that InoTrackFitAlg\(\) has just crossed RPC layer) S
LHL
(    for \(int jk=0; jk<5; jk++\) {) S
LHL
(      i1state[jk]= i2state[jk] =0;) S
LHL
(    }) S
PHL
(    ) S
LHL
(    // Feed the elements of the state vector \(initially from TFinder) S
LHL
(    // and from the next layer, coming from KFAlg\) into i1state) S
PHL
(    ) S
LHL
(    if \(ij == 1\) {) S
LHL
(      for \(int jk=0; jk<5; jk++\) {) S
LHL
(        i1state[jk] = StateVector[jk];) S
2 W
(// i1state \(here\) is the vector just about to enter gl) S
SL
(ass layer) S
PHL
(        ) S
LHL
32 W
(//        cout<<"i1state "<<jk<<" "<<i1state[jk]<<endl;) S
PHL
(        ) S
LHL
(      }) S
57 W
(// normal case: filtered state) S
LHL
(    } else if \(ij > 1\) {) S
LHL
24 W
(//      cout<<".....................................................Di) S
SL
(ffPlane "<<DiffPlane<<" & n = "<<ij<<endl;) S
LHL
(      for \(int jk=0; jk<5; jk++\) {) S
LHL
(        i1state[jk] = x__minus[jk]; ) S
4 W
(// i1state \(here\) is the vector just about to enter gl) S
SL
(ass layer) S
LHL
(      }) S
65 W
(// RPC hit missed in t) S
SL
(he previous step) S
LHL
(      for\(int jk = 0; jk<5; jk++\) {) S
LHL
(        for\(int kl = 0; kl<5; kl++\) {) S
LHL
(          C_k_minus[jk][kl]=C_k_intermediate[jk][kl];) S
LHL
(        }) S
LHL
(      }) S
EndPage
EndDSCPage
EndSheet

%%Page: 53 53
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 3761 def
/PageNumber 53 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
4056 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(    }) S
PHL
(    ) S
LHL
(    for\(int jk = 0; jk<5; jk++\) {) S
LHL
(      i3state[jk]=i1state[jk];) S
PHL
(      ) S
LHL
24 W
(//      cout<<"i3state "<<jk<<" "<<i3state[jk]<<endl;) S
LHL
(    }) S
PHL
(    ) S
LHL
(    double dzgl = 0;) S
PHL
(    ) S
LHL
(    double UBx = 0.0;) S
3 W
(double DBx = 0.0;) S
15 W
(double UUBx = 0.0;) S
14 W
(double) S
SL
( DDBx = 0.0;) S
LHL
(    double UBy = 0.0;) S
3 W
(double DBy = 0.0;) S
15 W
(double UUBy = 0.0;) S
14 W
(double) S
SL
( DDBy = 0.0;) S
14 W
PHL
(    ) S
LHL
16 W
(//    cout<<"ZPosLayer[2]"<<ZPosLayer[2]<<endl;) S
LHL
16 W
(//    cout<<"ZPosLayer[1]"<<ZPosLayer[1]<<endl;) S
PHL
(    ) S
LHL
(    double totdist= \(isHalf\) ? 0.5*\(ZPosLayer[2]-ZPosLayer[1]\) : \(ZPosLayer[2]-ZPosLayer[1]\);) S
LHL
(    double f = 2.0;) S
LHL
(    while\(abs\(dzgl\)<totdist\) {) S
LHL
(      if \(fabs\(dzgl\)> LayerThickness - 0.005\) {) S
LHL
(        break;) S
LHL
(      }) S
LHL
24 W
(//      cout<<"MaxPlane"<<MaxPlane<<endl;) S
LHL
24 W
(//      cout<<"MinPlane"<<MinPlane<<endl;) S
LHL
(      if \(nHit<15 && abs\(abs\(MaxPlane-MinPlane\)-nHit\)<5 && \(MaxPlane<140 && MinPlane>0\)\) {f = ) S
SL
(4.0;}) S
PHL
(      ) S
LHL
24 W
(//      cout<<"i1state[2] "<<i1state[2]<<endl;) S
LHL
24 W
(//      cout<<"fabs\(i1state[2]\) "<<fabs\(i1state[2]\)<<endl;) S
LHL
24 W
(//      cout <<"ilstate "<< i1state[0]<<" "<<i1state[1]<<" "<<i1state[) S
SL
(2]<<" "<<i1state[3]<<" "<<i1state[4]<<" "<<f<<endl;) S
LHL
(      if \(fabs\(i1state[2]\)>7.5\) {) S
LHL
8 W
(//  cout<<"check 1"<<endl;) S
LHL
(        i1state[2] = 7.5*\(i1state[2]/fabs\(i1state[2]\)\);) S
LHL
(      }) S
LHL
(      if \(fabs\(i1state[3]\)>7.5\) {) S
LHL
8 W
(//  cout<<"check 2"<<endl;) S
LHL
(        i1state[3] = 7.5*\(i1state[3]/fabs\(i1state[3]\)\);) S
LHL
(      }) S
LHL
(      if \(fabs\(i1state[4]\)>f\) {) S
LHL
32 W
(//) S
30 W
(cout<<"checkx 3 "<< nHit<<" "<) S
SL
(<MaxPlane<<" "<<MinPlane<<" "<<f<<" "<< i1state[4]<<endl;) S
LHL
(        i1state[4] = f * \(i1state[4]/fabs\(i1state[4]\)\);) S
LHL
(      }) S
LHL
(      //GMAA temporary) S
LHL
(      nstep++;) S
LHL
24 W
(//      cout<<"pre dzgl "<<dzgl<<endl;) S
PHL
(      ) S
LHL
(      double dz=0;) S
LHL
(      double Bx=0;) S
LHL
(      double By=0;) S
LHL
(      double dx=0;) S
LHL
(      double dy=0;) S
LHL
(      double Z =0;) S
LHL
(      double Eloss = 0;) S
LHL
(      double snext = 0;) S
LHL
(      double density=0;) S
PHL
(      ) S
LHL
(      int signp = 0;) S
LHL
(      if \(ZIncreasesWithTime==true\) {) S
LHL
(        signp = \(ZIncreasesWithTime != GoForward\) ? -1 :+1;) S
LHL
(      } else {) S
LHL
(        signp = \(ZIncreasesWithTime != GoForward\) ? +1 :-1;) S
LHL
(      }) S
PHL
(      ) S
LHL
(      double dxdz = i1state[2];) S
LHL
(      double dydz = i1state[3];) S
LHL
(      double dsdz = pow\(\(1.+pow\(i1state[2],2\)+pow\(i1state[3],2\)\),0.5\);) S
PHL
(      ) S
LHL
(      dirTrack[0] = signp*\(dxdz/dsdz\);) S
LHL
(      dirTrack[1] = signp*\(dydz/dsdz\);) S
LHL
(      dirTrack[2] = signp/dsdz;) S
PHL
(      ) S
LHL
(      for \(int jk=0; jk<3; jk++\) {) S
LHL
(        posTrack[jk] = 0.1 * MPos[jk]+epsilon*dirTrack[jk];) S
13 W
(//convert mm to cm) S
LHL
(      }) S
EndPage
EndDSCPage
EndSheet

%%Page: 54 54
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 3834 def
/PageNumber 54 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
4134 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(    ) S
LHL
(      icalGeometry->InitTrack\(posTrack, dirTrack\);) S
PHL
(      ) S
LHL
(      Bx = By = 0.0;) S
LHL
(      pFieldMap->ElectroMagneticField\(MPos,Bx,By,1\);) S
LHL
(      Bx *= 1000;) S
LHL
(      By *= 1000;) S
PHL
(      ) S
LHL
(      localmat= icalGeometry->GetCurrentVolume\(\)->GetMaterial\(\);) S
LHL
(      icalGeometry->FindNextBoundary\(\);) S
LHL
(      snext) S
5 W
(= epsilon+gGeoManager->GetStep\(\);) S
LHL
(      Z) S
9 W
(= localmat->GetZ\(\);) S
LHL
24 W
(//    cout<<" material "<<localmat->GetName\(\)<<"     Z "<<Z<<"     A ") S
SL
(<<localmat->GetA\(\)<<endl;) S
LHL
(      if \(snext > 1.0\) snext=1.0;) S
PHL
LHL
(      //) S
8 W
(cout<<"Current Vol Name: "<<icalGeometry->GetCurrentVolume\(\)->GetName\(\)<<endl;) S
LHL
(      if\(icalGeometry->GetCurrentVolume\(\)->GetName\(\)=="MagnetLog" &&  projPlane==11 \){) S
LHL
8 W
(cout<<"return  Vol Name: "<<icalGeometry->GetCurrentVolume\(\)->GetName\(\)<<endl;) S
LHL
8 W
(for\(int ijk=0;ijk<5;ijk++\){) S
PHL
LHL
10 W
(x__minus[ijk]=i2state[ijk];) S
LHL
10 W
(return true;) S
LHL
8 W
(}) S
PHL
LHL
(      }) S
LHL
(      if \(strstr\(icalGeometry->GetCurrentVolume\(\)->GetName\(\),"IRLAYElog"\)\) {) S
LHL
(        dz = signp*min\(0.001, 0.01*snext*abs\(dirTrack[2]\)\);) S
LHL
(      ) S
2 W
(//        cout<<" material "<<localmat->GetName\(\)<<"     Z "<<Z<<"     A "<<localmat->) S
SL
(GetA\(\)<<endl;) S
LHL
(        double d = 1.0/sqrt\(1.0+i2state[2]*i2state[2]+i2state[3]*i2state[3]\);) S
PHL
(        ) S
LHL
(        UxPos[0] = MPos[0] + d;) S
9 W
(DxPos[0] = MPos[0] - d;) S
25 W
(UyPos[) S
SL
(0] = MPos[0];) S
21 W
(DyPos[0] = MPos[0];) S
LHL
(        UxPos[1] = MPos[1];) S
21 W
(DxPos[1] = MPos[1];) S
27 W
SL
10 W
(UyPos[1] = MPos[1] + d;) S
9 W
(DyPos[1] = MPos[1] - d;) S
LHL
(        UxPos[2] = MPos[2];) S
21 W
(DxPos[2] = MPos[2];) S
27 W
SL
10 W
(UyPos[2] = MPos[2];) S
21 W
(DyPos[2] = MPos[2];) S
PHL
(        ) S
LHL
(        UxxPos[0] = MPos[0] + 2*d;) S
6 W
(DxxPos[0] = MPos[0] - 2*d;) S
22 W
(UyyPos) S
SL
([0] = MPos[0];) S
12 W
(DyyPos[0] = MPos[0];) S
LHL
(        UxxPos[1] = MPos[1];) S
12 W
(DxxPos[1] = MPos[1];) S
28 W
(UyyPos) S
SL
([1] = MPos[1] + 2*d;) S
6 W
(DyyPos[1] = MPos[1] - 2*d;) S
LHL
(        UxxPos[2] = MPos[2];) S
12 W
(DxxPos[2] = MPos[2];) S
28 W
(UyyPos) S
SL
([2] = MPos[2];) S
12 W
(DyyPos[2] = MPos[2];) S
PHL
(        ) S
LHL
(        //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++) S
LHL
(        pFieldMap->ElectroMagneticField\(UxPos,UBx,UBy,1\);) S
LHL
(        pFieldMap->ElectroMagneticField\(DxPos,DBx,DBy,1\);) S
PHL
(        ) S
LHL
(        pFieldMap->ElectroMagneticField\(UxxPos,UUBx,UUBy,1\);) S
LHL
(        pFieldMap->ElectroMagneticField\(DxxPos,DDBx,DDBy,1\);) S
PHL
(        ) S
LHL
(        //O\(h^2\) order derivatives of B field) S
LHL
(        //dBxdx = 1.e3*\(UBx-DBx\)/\(2*d*1.e-3\);) S
LHL
(        //dBydx = 1.e3*\(UBy-DBy\)/\(2*d*1.e-3\);) S
PHL
(        ) S
LHL
(        //O\(h^4\) order derivatives of B field) S
LHL
(        dBxdx = \(1.e3*\(-UUBx + 8.0*UBx - 8.0*DBx + DDBx\)\)/\(1.e-3*\(12.0*d\)\);) S
LHL
(        dBydx = \(1.e3*\(-UUBy + 8.0*UBy - 8.0*DBy + DDBy\)\)/\(1.e-3*\(12.0*d\)\);) S
LHL
32 W
(//        cout<<"xxis this iron? "<<Z<<endl;) S
LHL
(        pFieldMap->ElectroMagneticField\(UyPos,UBx,UBy,1\);) S
LHL
(        pFieldMap->ElectroMagneticField\(DyPos,DBx,DBy,1\);) S
PHL
(        ) S
LHL
(        pFieldMap->ElectroMagneticField\(UyyPos,UUBx,UUBy,1\);) S
LHL
(        pFieldMap->ElectroMagneticField\(DyyPos,DDBx,DDBy,1\);) S
PHL
(        ) S
LHL
(        //O\(h^2\) order derivatives of B field) S
LHL
(        //dBxdy = 1.e3*\(UBx-DBx\)/\(2*d*1.e-3\);) S
LHL
(        //dBydy = 1.e3*\(UBy-DBy\)/\(2*d*1.e-3\);) S
PHL
(        ) S
LHL
(        //O\(h^4\) order derivatives of B field) S
LHL
(        dBxdy = \(1.e3*\(-UUBx + 8.0*UBx - 8.0*DBx + DDBx\)\)/\(1.e-3*\(12.0*d\)\);) S
LHL
(        dBydy = \(1.e3*\(-UUBy + 8.0*UBy - 8.0*DBy + DDBy\)\)/\(1.e-3*\(12.0*d\)\);) S
LHL
32 W
(//        cout<<"is this iron? "<<Z<<endl;) S
LHL
(      } else {) S
LHL
32 W
(//        cout <<"MPos "<< MPos[0]<<"     "<< MPos[1]<<"     ") S
SL
(<< MPos[2]<<"     "<<Bx<<"     "<<By<<"     "<<icalGeometry->GetCurrentVolume\(\)->GetName\(\)<<en) S
EndPage
EndDSCPage
EndSheet

%%Page: 55 55
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 3902 def
/PageNumber 55 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
4212 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(dl;) S
LHL
(        Bx = By = 0.0;) S
PHL
(        ) S
LHL
(        dBxdx = 0.0;) S
4 W
(dBxdy = 0.0;) S
LHL
(        dBydx = 0.0;) S
4 W
(dBydy = 0.0;) S
PHL
(        ) S
LHL
(        //if \(localmat->GetName\(\)=="G4_Air"\)) S
LHL
(        //dz = 0.01*signp;) S
LHL
(        //else) S
LHL
32 W
(//        cout<<"is this !iron? "<<Z<<endl;) S
LHL
(        dz = 0.01*signp*snext*abs\(dirTrack[2]\); // cm to meter) S
LHL
(        if\(strstr\(icalGeometry->GetCurrentVolume\(\)->GetName\(\),"GASRlog"\)\) {) S
LHL
(          dz = 0.001*signp;) S
LHL
(        }) S
LHL
32 W
(//        cout<<"is this !iron? "<<Z<<endl;) S
LHL
(      }) S
PHL
(      ) S
LHL
(      //if \(nstep>=nstepmx\) {dz= totdist - abs\(dzgl\);cout<<"000000000000000000000000000000"<<e) S
SL
(ndl;}) S
LHL
(      dzgl +=dz;) S
PHL
(      ) S
LHL
(      //DZ[nstep] = dz;) S
LHL
(      if \(Z == 26.0\) {) S
LHL
(        dzFe += dz;) S
LHL
(      }) S
LHL
(      if \(\(NIter == 1\) && \(GoForward==true\) && \(NewPlane-MinPlane\)==1\) {) S
LHL
(        B_in = sqrt\(Bx*Bx + By*By\);) S
LHL
(      }) S
LHL
(      if \(Z != 26.0\) {) S
LHL
(        dznF += dz;) S
LHL
(      }) S
17 W
LHL
(      density = localmat->GetDensity\(\);) S
LHL
24 W
(//      cout<<"dz "<<dz<<" dzgl "<<dzgl<<" snext "<<snext<<" material ) S
SL
("<<icalGeometry->GetCurrentVolume\(\)->GetName\(\)<<" density"<<density<<endl;) S
PHL
(      ) S
LHL
(      Eloss = GetEnergyLoss\(i1state, dz, xi, T_max, I, localmat\);) S
LHL
24 W
(//      cout <<"Elose "<<Eloss<<endl;) S
LHL
(      //if \(localmat->GetName\(\)=="G4_Air"\)) S
LHL
(      //if\(strstr\(icalGeometry->GetCurrentVolume\(\)->GetName\(\),"LAYElog"\)\)) S
LHL
(      //Eloss = 0.0;) S
PHL
(      ) S
LHL
(      /* ) S
LHL
(      // Find the propagator) S
LHL
(      GetPropagator\(i1state, Bx, By, dBxdx, dBydx, dBxdy, dBydy, dz, localmat\);) S
PHL
(      ) S
LHL
(      // Find the multiple scattering in the step, with given slope) S
LHL
(      bool uv;) S
LHL
(      for \(int jk = 0; jk< 5; jk++\) {) S
LHL
(      uv = std::isnan\(i1state[jk]\);) S
LHL
(      }) S
PHL
(      ) S
LHL
(      if \(NewPlane>=0 && uv==false\)) S
LHL
(      GetMultipleScattering\(i1state, Bx, By, dz, xi, T_max, I, localmat\);) S
LHL
(      */) S
LHL
(      //GMAA Use Fmatrix to propagate) S
LHL
(      // Get the state elements) S
LHL
(      double x; double y; double tx; double ty; double qbyP;) S
LHL
(      x) S
1 W
(=i1state[0];) S
LHL
(      y) S
1 W
(=i1state[1];) S
LHL
(      tx) S
8 W
(=i1state[2];) S
LHL
(      ty) S
8 W
(=i1state[3];) S
LHL
(      qbyP=i1state[4];) S
PHL
(      ) S
LHL
(      // Construction of variables needed for 3rd order extrapolation) S
LHL
(      double kappa) S
6 W
(= 0.299792458;) S
LHL
(      double T) S
10 W
(= sqrt\(1+pow\(tx,2\)+pow\(ty,2\)\);) S
10 W
(if \(ZIncreasesWithTime==false\)) S
SL
( T=-T;) S
LHL
(      double h) S
10 W
(= kappa*qbyP*T;) S
LHL
(      double Rx) S
9 W
(= Bx*dz*h;) S
LHL
(      double Ry) S
9 W
(= By*dz*h;) S
LHL
(      double Sx) S
9 W
(= 0.5*Bx*pow\(dz,2\)*h;) S
LHL
(      double Sy) S
9 W
(= 0.5*By*pow\(dz,2\)*h;) S
LHL
(      double Rxx = 0.5 * Bx * Bx * pow\(dz,2\);) S
3 W
(double Sxx = \(1/6\)*Bx*Bx*pow\(dz,3\);) S
LHL
(      double Rxy = 0.5 * Bx * By * pow\(dz,2\);) S
3 W
(double Sxy = \(1/6\)*Bx*By*pow\(dz,3\);) S
LHL
(      double Ryx = 0.5 * By * Bx * pow\(dz,2\);) S
3 W
(double Syx = \(1/6\)*By*Bx*pow\(dz,3\);) S
LHL
(      double Ryy = 0.5 * By * By * pow\(dz,2\);) S
3 W
(double Syy = \(1/6\)*By*By*pow\(dz,3\);) S
PHL
(      ) S
LHL
(      double Bi) S
1 W
(= sqrt\(Bx*Bx + By*By + pow\(\(tx*By-ty*Bx\)/T,2.0\)\);) S
EndPage
EndDSCPage
EndSheet

%%Page: 56 56
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 3977 def
/PageNumber 56 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
4290 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(      ) S
LHL
(      double P = 0;) S
5 W
(double P_ex = 0;) S
8 W
(double E = 0;) S
3 W
(double E_ex = 0;) S
8 W
(double) S
SL
( mumas = 0.1056589;) S
7 W
(double b = 0.0;) S
1 W
(double ddE = 0.0;) S
PHL
(      ) S
LHL
(      if \(qbyP == 0\) {) S
LHL
(        i2state[4] = qbyP;) S
LHL
(      } else if \(qbyP != 0\) {) S
LHL
(        P) S
7 W
(= fabs\(1.0/qbyP\);) S
7 W
(//cout<<"PSC\(iron\) P = "<<P<<endl;) S
LHL
(        E) S
7 W
(= sqrt\(pow\(P,2\) + pow\(mumas,2\)\);   //cout<<"PSC\(iron\) E = "<<E<<endl;) S
LHL
(        b) S
7 W
(= P/E;) S
PHL
(        ) S
LHL
(        if \(ZIncreasesWithTime == true\) {) S
LHL
(          ddE =-BetheBloch * density * 1.e-1*fabs\(T\)*dz;) S
LHL
(        } else {) S
LHL
(          ddE = BetheBloch * density * 1.e-1*fabs\(T\)*dz;) S
LHL
(        }) S
PHL
(        ) S
LHL
(        if \(ZIncreasesWithTime==true && dz > 0\) {) S
LHL
(          E_ex= E - Eloss;) S
6 W
(//cout<<"PSC\(going up in iron\) E_ex = "<<E_ex<<endl;) S
LHL
(        } else if \(ZIncreasesWithTime==true && dz < 0\) {) S
LHL
(          E_ex= E + Eloss;) S
6 W
(//cout<<"PSC\(going down in iron\) E_ex = "<<E_ex<<endl;) S
LHL
(        } else if \(ZIncreasesWithTime==false && dz < 0\)) S
1 W
({) S
LHL
(          E_ex= E - Eloss;) S
6 W
(//cout<<"a"<<endl;) S
LHL
(        } else if \(ZIncreasesWithTime==false && dz > 0\)) S
1 W
({) S
LHL
(          E_ex= E + Eloss;) S
6 W
(//cout<<"b"<<endl;) S
LHL
(        }) S
PHL
(        ) S
LHL
(        if \(\(E_ex-mumas\)>0\) {) S
LHL
(          P_ex= sqrt\(E_ex*E_ex - mumas*mumas\);) S
2 W
(//cout<<"PSC\(iron\) P_ex = "<<P_ex<<endl;) S
LHL
(        }) S
LHL
(        i2state[4] = qbyP * \(P/P_ex\);) S
PHL
(        ) S
LHL
(        //i2state[4] = qbyP - qbyP*\(ddE/\(b*P\)\);) S
LHL
(      }) S
LHL
24 W
(//      cout<<"P "<<P<<"     P_ex "<<P_ex<<"     dz "<<dz<<"     Eloss) S
SL
( "<<Eloss<<endl;) S
PHL
(      ) S
LHL
(      i2state[0] = x + tx * dz + tx * ty * Sx - \(pow\(tx,2\)+1\) * Sy + h*h * \(tx*\(3*ty*ty+1\)*Sxx) S
SL
( - ty*\(3*tx*tx+1\)*Sxy -ty*\(3*tx*tx+1\)*Syx + tx*\(3*tx*tx+3\)*Syy\);) S
LHL
(      i2state[1] = y + ty * dz + \(pow\(ty,2\)+1\) * Sx - tx * ty * Sy + h*h * \(ty*\(3*ty*ty+3\)*Sxx) S
SL
( - tx*\(3*ty*ty+1\)*Sxy -tx*\(3*ty*ty+1\)*Syx + ty*\(3*tx*tx+1\)*Syy\);) S
LHL
(      i2state[2] = tx + tx * ty * Rx - \(pow\(tx,2\)+1\) * Ry + h*h * \(tx*\(3*ty*ty+1\)*Rxx - ty*\(3*) S
SL
(tx*tx+1\)*Rxy -ty*\(3*tx*tx+1\)*Ryx + tx*\(3*tx*tx+3\)*Ryy\);) S
LHL
(      i2state[3] = ty + \(pow\(ty,2\)+1\) * Rx - tx * ty * Ry + h*h * \(ty*\(3*ty*ty+3\)*Rxx - tx*\(3*) S
SL
(ty*ty+1\)*Rxy -tx*\(3*ty*ty+1\)*Ryx + ty*\(3*tx*tx+1\)*Ryy\);) S
PHL
(      ) S
LHL
(      bool bull; bull = std::isnan\(P_ex\);) S
LHL
(      if \(bull == true\) {) S
LHL
(        cout<<"Not-A-Number occurring. Event must be stopped"<<endl;) S
LHL
(        break;) S
LHL
(      }) S
PHL
(      ) S
LHL
(      dx = \(i2state[0] - i1state[0]\);) S
LHL
(      dy = \(i2state[1] - i1state[1]\);) S
PHL
(      ) S
LHL
(      double length = sqrt\(dx*dx + dy*dy + dz*dz\);) S
PHL
(      ) S
LHL
24 W
(//      cout <<"ds "<<*dS<<endl;) S
LHL
(      *dS += length;) S
LHL
(      *Range += BetheBloch * density * \(1.e2*length\) * 1.e-3;) S
LHL
24 W
(//      cout <<"Range "<<*Range<<endl;     ) S
PHL
PHL
(      ) S
LHL
(      double Tx) S
1 W
(= i2state[2];) S
LHL
(      double Ty) S
1 W
(= i2state[3];) S
LHL
(      double TT) S
1 W
(= sqrt\(1.0 + Tx*Tx + Ty*Ty\);) S
PHL
(      ) S
LHL
(      double Ps[3]={0.0000000};) S
LHL
(      Ps[0]) S
5 W
(= 1.e3*i2state[0];) S
LHL
(      Ps[1]) S
5 W
(= 1.e3*i2state[1];) S
LHL
(      Ps[2]) S
5 W
(= 0.0000000000000;) S
LHL
(      double bX) S
1 W
(= 0.000000000;) S
LHL
(      double bY) S
1 W
(= 0.000000000;) S
LHL
(      pFieldMap->ElectroMagneticField\(Ps,bX,bY,1\);) S
LHL
(      bX = 1.e3*bX;bY = 1.e3*bY;) S
LHL
(      double Bf) S
1 W
(= sqrt\(bX*bX + bY*bY + pow\(\(Tx*bY-Ty*bX\)/TT,2.0\)\);) S
LHL
(      MagicRatio =0.000;) S
LHL
(      if \(Bx!= 0.0 && By != 0.0\) {) S
EndPage
EndDSCPage
EndSheet

%%Page: 57 57
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 4049 def
/PageNumber 57 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
4368 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(        MagicRatio = Bi/Bf;) S
LHL
(      }) S
LHL
(      //......................................................................................) S
SL
(...........................//) S
LHL
(      double dbxdx = 0.000000;) S
10 W
(double dbydx = 0.0000000000;) S
12 W
(double dbxdy =) S
SL
( 0.0000000000;) S
4 W
(double dbydy=0.;) S
LHL
(      //......................................................................................) S
SL
(...........................//) S
LHL
(      /*         x + dx         */) S
14 W
(/*            y           */) S
LHL
(      double exPos_x[3]={0.0};) S
10 W
(exPos_x[0] = 1.e3*i1state[0]+\(tx/fabs\(tx\)\)*50.0;) S
6 W
SL
10 W
(exPos_x[1] = 1.e3*i1state[1];) S
3 W
(exPos_x[2] = 0.0;) S
15 W
(//exPos_x[2] = MPos[) S
SL
(2]+1.e3*dz;) S
LHL
(      //......................................................................................) S
SL
(...........................//) S
LHL
(      /*           x            */) S
14 W
(/*          y + dy        */) S
LHL
(      double exPos_y[3]={0.0};) S
10 W
(exPos_y[0] = 1.e3*i1state[0];) S
11 W
(exPos_y[1] = 1) S
SL
(.e3*i1state[1]+\(ty/fabs\(ty\)\)*50.0;) S
8 W
(exPos_y[2] = 0.0;) S
15 W
(//exPos_y[2] = MPos[) S
SL
(2]+1.e3*dz;) S
LHL
(      //......................................................................................) S
SL
(...........................//) S
LHL
(      double bx = 0.0;) S
LHL
(      double by = 0.0;) S
PHL
(      ) S
LHL
(      if \(strstr\(icalGeometry->GetCurrentVolume\(\)->GetName\(\),"IRLAYElog"\)\) {//localmat->GetNam) S
SL
(e\(\)=="G4_Fe") S
LHL
(        pFieldMap->ElectroMagneticField\(exPos_x,bx,by,1\);) S
LHL
(        bx = 1.e3*bx;) S
LHL
(        by = 1.e3*by;) S
LHL
(        dbxdx = \(bx-Bx\)/\(\(tx/fabs\(tx\)\)*0.05\);) S
LHL
(        dbydx = \(by-By\)/\(\(tx/fabs\(tx\)\)*0.05\);) S
LHL
(        //cout<<"X: dbxdx "<<dbxdx<<"     dbxdy "<<dbxdy<<endl;) S
LHL
(        bx = 0.0;) S
LHL
(        by = 0.0;) S
PHL
(        ) S
LHL
(        pFieldMap->ElectroMagneticField\(exPos_y,bx,by,1\);) S
LHL
(        bx = 1.e3*bx;) S
LHL
(        by = 1.e3*by;) S
LHL
(        dbxdy = \(bx-Bx\)/\(\(ty/fabs\(ty\)\)*0.05\);) S
LHL
(        dbydy = \(by-By\)/\(\(ty/fabs\(ty\)\)*0.05\);) S
LHL
(        //cout<<"Y: dbydx "<<dbydx<<"     dbydy "<<dbydy<<endl;) S
LHL
(      }) S
PHL
(      ) S
LHL
24 W
(//      cout<<"dBx "<<dbxdx*dx + dbxdy*dy<<"     Bx "<<Bx<<"     dBy ") S
SL
(<<dbxdx*dx + dbxdy*dy<<"     By "<<By<<endl;) S
LHL
24 W
(//      cout<<".........................."<<endl;) S
PHL
(      ) S
LHL
(      // Find the propagator) S
LHL
(      GetPropagator\(i1state, Bx, By, dBxdx, dBydx, dBxdy, dBydy, dz, localmat\);) S
LHL
24 W
(//      cout<<"material "<<localmat->GetName\(\)<<"     Z "<<localmat->G) S
SL
(etZ\(\)<<"     dz "<<dz<<" inside PSC"<<endl;) S
LHL
(      /*) S
LHL
8 W
(cout<<"F00 "<<F_k_minus[0][0]<<"     F01 "<<F_k_minus[0][1]<<"     F02 "<<F_k_minus[0]) S
SL
([2]<<"     F03 "<<F_k_minus[0][3]<<"     F04 "<<F_k_minus[0][4]<<"\\n") S
LHL
8 W
(<<"F10 "<<F_k_minus[1][0]<<"     F11 "<<F_k_minus[1][1]<<"     F12 "<<F_k_minus[1][2]<) S
SL
(<"     F13 "<<F_k_minus[1][3]<<"     F04 "<<F_k_minus[1][4]<<"\\n") S
LHL
8 W
(<<"F20 "<<F_k_minus[2][0]<<"     F21 "<<F_k_minus[2][1]<<"     F22 "<<F_k_minus[2][2]<) S
SL
(<"     F23 "<<F_k_minus[2][3]<<"     F04 "<<F_k_minus[2][4]<<"\\n") S
LHL
8 W
(<<"F30 "<<F_k_minus[3][0]<<"     F31 "<<F_k_minus[3][1]<<"     F32 "<<F_k_minus[3][2]<) S
SL
(<"     F33 "<<F_k_minus[3][3]<<"     F04 "<<F_k_minus[3][4]<<"\\n") S
LHL
8 W
(<<"F40 "<<F_k_minus[4][0]<<"     F41 "<<F_k_minus[4][1]<<"     F42 "<<F_k_minus[4][2]<) S
SL
(<"     F43 "<<F_k_minus[4][3]<<"     F04 "<<F_k_minus[4][4]<<"\\n") S
LHL
8 W
(<<endl;) S
LHL
8 W
(cout<<".........................."<<endl;) S
LHL
(      */) S
LHL
(      // Find the multiple scattering in the step, with given slope) S
LHL
(      bool uv;) S
LHL
(      for \(int jk = 0; jk< 5; jk++\) {) S
LHL
(        uv = std::isnan\(i1state[jk]\);) S
LHL
(      }) S
PHL
(      ) S
LHL
(      if \(NewPlane>=0 && uv==false\) { ) S
LHL
(        GetMultipleScattering\(i1state, Bx, By, dz,/* xi,*/ T_max, I, localmat\);) S
LHL
(      }) S
9 W
LHL
(      // Extrapolation of the covariance matrix: [C^\(k-1\)]_k = F_k * C_\(k-1\) * \(F_k\)^T + Q_\(k-) S
SL
(1\)) S
LHL
(      if \(NewPlane >=0\)) S
LHL
(        ExtrapCovMatrix\(\);) S
PHL
(      ) S
EndPage
EndDSCPage
EndSheet

%%Page: 58 58
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 4109 def
/PageNumber 58 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
4446 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(      for \(int jk = 0; jk < 5; jk++\) {) S
LHL
(        for \(int kl = 0; kl < 5; kl++\) {) S
LHL
(          C_k_minus[jk][kl]) S
5 W
(= C_k_intermediate[jk][kl];) S
LHL
(          if \(Z == 6.0 || Z == 10.8046 || Z == 13.0 || Z == 26.0 || Z == 29.0\) {) S
LHL
(            if \(!fMT\) { ) S
LHL
(              C_k_minus[jk][kl]+= 1.0*Q_k_minus[jk][kl];) S
LHL
(            } else {) S
LHL
(              C_k_minus[jk][kl]+= 1.0*Q_k_minus[jk][kl];) S
LHL
(            }) S
LHL
(          }) S
LHL
(        }) S
LHL
(      }) S
PHL
(      ) S
LHL
(      // Set the \(x,y,z\) of the extrapolated track, for calling the local magnetic field) S
LHL
(      MPos[0]=i2state[0]*1000;) S
26 W
(//MPos[0]=GPos[0];) S
LHL
(      MPos[1]=i2state[1]*1000;) S
26 W
(//MPos[1]=GPos[1];) S
LHL
(      MPos[2]=1.e3*\(1.e-3*MPos[2]+dz\);) S
10 W
(//MPos[2]=GPos[2]*1000;) S
PHL
(      ) S
LHL
(      for \(int jk=0; jk<5; jk++\) {) S
LHL
(        i1state[jk] = 0.0;) S
LHL
(        i1state[jk] = i2state[jk];) S
LHL
(      }) S
PHL
(      ) S
LHL
(      //if \(fabs\(dz\)>0.02\)) S
LHL
(      //cout<<"dz "<<dz<<" Z pos "<<MPos[2]<<"     snext "<<snext<<"     nstep "<<nstep<<"    ) S
SL
( material "<<localmat->GetName\(\)<<"     previous step size dz "<<DZ[nstep-1]<<"     Plane "<<P) S
SL
(lane<<"     NewPlane "<<NewPlane<<endl;) S
PHL
(      ) S
LHL
(      //cout<<"post dzgl "<<dzgl<<endl;) S
LHL
(    }) S
LHL
(    // while loop \(controlling dZ <= 0.096 m\) ends here) S
PHL
(    ) S
LHL
(    if \(NewPlane>=0\) {) S
LHL
(      //cout<<"............................................"<<endl;) S
LHL
(      for \(int jk=0; jk<5; jk++\) {) S
LHL
(        x__minus[jk] = i1state[jk];) S
LHL
(      }) S
LHL
(    }) S
LHL
(    for \(int jk = 0; jk < 5; jk++\)) S
6 W
({) S
LHL
(      for \(int kl = 0; kl < 5; kl++\) {) S
LHL
(        C_k_intermediate[jk][kl] = 0;) S
LHL
(        C_k_intermediate[jk][kl] = C_k_minus[jk][kl];) S
LHL
(      }) S
LHL
(    }) S
LHL
(  }// for loop ends here) S
LHL
(  //cout<<dzFe<<"     "<<dznF<<endl;) S
LHL
8 W
(//  cout<<"NewPlane "<<NewPlane<<" ZIncreasesWithTime "<<ZIncreasesWithTime<<" nstep ") S
SL
(<<nstep<<" "<<MPos[0]<<" "<<MPos[1]<<" "<<MPos[2]<<" "<<1/x__minus[4]<<endl;) S
LHL
(  if \(NewPlane<0 && nstep<nstepmx\){) S
LHL
(    if \(ZIncreasesWithTime==true\) {) S
LHL
(      NewPlane = Plane + initsign;) S
LHL
(    } else {) S
LHL
(      NewPlane = Plane - initsign;) S
LHL
(      cout<<"NewPlane_ "<<NewPlane<<"ZIncreasesWithTime "<<ZIncreasesWithTime<<"nstep "<<nstep) S
SL
(<<endl;) S
LHL
(    }) S
LHL
(  }) S
LHL
8 W
(//  cout<<"yyy "<<GPL<<" "<<RNG<<" "<<endl;) S
LHL
(  /*) S
LHL
(   *dS = GPL;   //GMA14 Put all these three properly) S
LHL
(   *Range = RNG;) S
LHL
(   *dE = 0;) S
LHL
(   cout<<"xxx "<<endl;) S
LHL
(  */) S
PHL
PHL
( ) S
PHL
(   ) S
LHL
(  return true;) S
LHL
(}) S
PHL
LHL
(void InoTrackFitAlg::ExtrapCovMatrix\(\) {) S
LHL
(  // C_k_intermediate = \(F_k_minus * C_k_minus * F_k_minus^T\) + Q_k_minus) S
LHL
8 W
(//  if\(debug_fit\) {cout <<" ----------------------InoTrackFitAlg : ExtrapCovMatrix----) S
SL
(------------------" << endl;}) S
PHL
(  ) S
LHL
(  for \(int ij=0; ij<5; ++ij\) {) S
LHL
(    for \(int jk=0; jk<5; ++jk\) {) S
LHL
(      C_k_intermediate[ij][jk]=0;) S
EndPage
EndDSCPage
EndSheet

%%Page: 59 59
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 4182 def
/PageNumber 59 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
4524 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(      for \(int kl=0; kl<5; ++kl\) {) S
LHL
(        for \(int lm=0; lm<5; ++lm\) {) S
LHL
(          C_k_intermediate[ij][jk]+=F_k_minus[ij][lm]*C_k_minus[lm][kl]*F_k_minus[jk][kl];) S
LHL
(        }) S
LHL
(      }) S
LHL
(    }) S
LHL
(  }) S
PHL
(  ) S
LHL
(  //for\(int ij=0; ij<5; ij++\){for\(int jk = 0; jk<5; jk++\) {bool z; z=std::isnan\(F_k_minus[ij][) S
SL
(jk]\); if\(z==true\) cout<<"F"<<endl;}}) S
LHL
(  //for\(int ij=0; ij<5; ij++\){for\(int jk = 0; jk<5; jk++\) {bool z; z=std::isnan\(C_k_minus[ij][) S
SL
(jk]\); if\(z==true\) cout<<"C"<<endl;}}) S
LHL
(  //for\(int ij=0; ij<5; ij++\){for\(int jk = 0; jk<5; jk++\) {bool z; z=std::isnan\(C_k_intermedia) S
SL
(te[ij][jk]\); if\(z==true\) cout<<"FCF^"<<endl;}}) S
4 W
LHL
(  /*) S
LHL
(  // Diagonal elements should be positive) S
LHL
(  double covlim = 1.e-8;) S
PHL
(  ) S
LHL
(  for\(int ij=0; ij<5; ++ij\) {) S
LHL
(  if\(C_k_intermediate[ij][ij]<covlim\){) S
LHL
(  // GMA reopen this      cout <<" InoTrackFitAlg : Negative diagonal element in C_k_intermedi) S
SL
(ate" << endl;) S
LHL
(  // C_k_intermediate[ij][ij]=covlim;) S
LHL
(  }) S
LHL
(  }) S
PHL
( ) S
LHL
(  // Display) S
LHL
(  if\(debug_fit\) {) S
LHL
(    cout<<"------------------------------------------------------------"<<endl;) S
LHL
(    cout << "C_k_intermediate" << endl;) S
LHL
(    for\(int ij=0; ij<5; ++ij\) {) S
LHL
(      for\(int jk=0; jk<5; ++jk\) {) S
LHL
(        cout << C_k_intermediate[ij][jk] << " ";) S
LHL
(      }) S
LHL
(      cout << endl;) S
LHL
(    }) S
LHL
(    cout<<"------------------------------------------------------------"<<endl;) S
LHL
(  }) S
LHL
(  for \(int ij=0; ij<5; ij++\) {) S
LHL
(    for \(int jk =0; jk<5; jk++\)  {) S
LHL
(      C_k_minus[ij][jk]) S
1 W
(= C_k_intermediate[ij][jk];) S
LHL
(    }) S
LHL
(  }) S
LHL
(  */) S
LHL
(}) S
PHL
LHL
(void InoTrackFitAlg::ExtrapCovMatrixall\(\) {) S
LHL
(  // C_k_intermediate = \(F_k_minus * C_k_minus * F_k_minus^T\) + Q_k_minus) S
LHL
(  if\(debug_fit\) {cout <<" ----------------------InoTrackFitAlg : ExtrapCovMatrix--------------) S
SL
(--------" << endl;}) S
PHL
(  ) S
LHL
(  for \(int ij=0; ij<5; ++ij\) {) S
LHL
(    for \(int jk=0; jk<5; ++jk\) {) S
LHL
(      C_k_intermediate[ij][jk]=0;) S
LHL
(      for \(int kl=0; kl<5; ++kl\) {) S
LHL
(        for \(int lm=0; lm<5; ++lm\) {) S
LHL
(          C_k_intermediate[ij][jk]+=F_k_minus[ij][lm]*C_k_minus[lm][kl]*F_k_minus[jk][kl];) S
LHL
(        }) S
LHL
(      }) S
LHL
(    }) S
LHL
(  }) S
PHL
(  ) S
LHL
(  for \(int ij=0; ij<5; ij++\) {) S
LHL
(    for \(int jk =0; jk<5; jk++\)  {) S
LHL
(      C_k_minus[ij][jk]) S
1 W
(= C_k_intermediate[ij][jk];) S
LHL
(    }) S
LHL
(  }) S
LHL
(}) S
PHL
LHL
(/*) S
LHL
(  void InoTrackFitAlg::CovarianceMatrixExtrapolation\(\) {) S
LHL
(  for \(int ij=0; ij<5; ++ij\) {) S
LHL
(  for \(int jk=0; jk<5; ++jk\) {  ) S
LHL
(  C_k_intermediate[i][jk]=0;) S
LHL
(  for \(int kl=0; kl<5; ++kl\) {) S
LHL
(  for \(int lm=0; lm<5; ++lm\) {) S
LHL
(  // intermediate C_k is calculated at each step from intermediate F_k_minus) S
LHL
(  C_k_intermediate[ij][jk]+=F_k_minus[ij][lm]*C_k_minus[lm][kl]*F_k_minus[jk][kl];) S
EndPage
EndDSCPage
EndSheet

%%Page: 60 60
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 4255 def
/PageNumber 60 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
4602 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  }) S
LHL
(  }) S
LHL
(  }) S
LHL
(  }) S
LHL
(  }) S
LHL
(*/) S
LHL
(double InoTrackFitAlg::GetEnergyLoss\(double *istate, double dz, double &axi, double &aT_max, d) S
SL
(ouble &aI, TGeoMaterial* material\) {) S
LHL
(  // cout<<"*****Energy Loss Function*****"<<endl;) S
LHL
(  // Initialize the relevant elements of the state vector so that fresh values may fed to appr) S
SL
(opriate variables.) S
LHL
(  double tx = 0; double ty = 0; double qbyP = 0; double P = 0;) S
PHL
(  ) S
LHL
(  tx=istate[2];) S
LHL
(  ty=istate[3];) S
LHL
(  qbyP=istate[4];) S
PHL
(  ) S
LHL
(  double T =sqrt\(1+pow\(tx,2\)+pow\(ty,2\)\);) S
PHL
(  ) S
LHL
(  //////////////////////////////////////////////////////////////////////////) S
LHL
(  // The following part will produce the Bethe Bloch energy loss at momentum P) S
LHL
(  //////////////////////////////////////////////////////////////////////////) S
LHL
(  // Setting Momentum and Energy of the muon currently) S
PHL
(  ) S
LHL
(  if \(fabs\(qbyP\) < 0.01\) {) S
LHL
(    P = 100.0;) S
2 W
(// GeV) S
LHL
(  } else if \(fabs\(qbyP\) >= 0.01 && fabs\(qbyP\) <= 4.0\) {) S
LHL
(    P = fabs\(1/qbyP\);  // GeV) S
LHL
(  } else {) S
LHL
(    P = 0.25;) S
LHL
(  }) S
LHL
(  // Here P is found in GeV/c) S
PHL
(  ) S
LHL
(  double em) S
5 W
(= 0.5110;) S
15 W
(// MeV/c^2) S
LHL
(  double uam) S
4 W
(= 105.65839;) S
4 W
(// Mev/c^2) S
PHL
(  ) S
LHL
(  double a) S
6 W
(= 0.0;) S
LHL
(  double am) S
5 W
(= 0.0;) S
LHL
(  double X0) S
5 W
(= 0.0;) S
LHL
(  double X1) S
5 W
(= 0.0;) S
LHL
(  double Cbar= 0.0;) S
LHL
(  double dltO= 0.0;) S
LHL
(  aI) S
20 W
(= 0.0;) S
PHL
(  ) S
LHL
(  std::map<string, double> meanExEnergy;) S
LHL
(  meanExEnergy["G4_Fe"]              = 286.0E-6;) S
LHL
(  meanExEnergy["G4_Cu"]              = 322.0E-6;) S
LHL
(  meanExEnergy["G4_Al"]              = 166.0E-6;) S
LHL
(  meanExEnergy["G4_AIR"]             = 85.7E-6;) S
LHL
(  meanExEnergy["G4_POLYETHYLENE"]    = 57.4E-6;) S
LHL
(  meanExEnergy["G4_MYLAR"]           = 78.7E-6;) S
LHL
(  meanExEnergy["G4_SILICON_DIOXIDE"] = 139.2E-6;) S
LHL
(  meanExEnergy["G10"]                = 72.4E-6; //same as bakalite) S
LHL
(  meanExEnergy["G4_GRAPHITE"]        = 78.0E-6;) S
LHL
(  meanExEnergy["rpcgas"]             = 85.7E-6; //same as air) S
LHL
(  meanExEnergy["FRPCarbon"]        = 78.0E-6; // same as graphite) S
LHL
(  aI = meanExEnergy[material->GetName\(\)];) S
PHL
(  ) S
LHL
(  double Z) S
6 W
(= material->GetZ\(\);) S
LHL
(  double A) S
6 W
(= material->GetA\(\);) S
LHL
(  double rho) S
4 W
(= material->GetDensity\(\);) S
31 W
(// g/cm^3) S
PHL
(  ) S
LHL
(  // Sternheimer's coefficients:) S
LHL
(  if \(Z==6 && rho ==2.21\) {) S
LHL
(    a = 0.2614;) S
9 W
(am = 2.8697;) S
12 W
(X0 =-0.0178;) S
12 W
(X1 = 2.3415;) S
10 W
SL
2 W
(Cbar = 2.8680;) S
10 W
(dltO = 0.12;) S
LHL
(  } else if \(Z==13\) {) S
LHL
(    a = 0.0802;) S
9 W
(am = 3.6345;) S
12 W
(X0 = 0.1708;) S
12 W
(X1 = 3.0127;) S
10 W
SL
2 W
(Cbar = 4.2395;) S
10 W
(dltO = 0.12;) S
LHL
(  } else if \(Z==26\) {) S
LHL
(    a = 0.1468;) S
9 W
(am = 2.9600;) S
12 W
(X0 =-0.0012;) S
12 W
(X1 = 3.1531;) S
10 W
SL
2 W
(Cbar = 4.2911;) S
10 W
(dltO = 0.12;) S
LHL
(  } else if \(Z==29\) {) S
LHL
(    a = 0.1434;) S
9 W
(am = 2.9044;) S
12 W
(X0 =-0.0254;) S
12 W
(X1 = 3.2792;) S
10 W
SL
2 W
(Cbar = 4.4190;) S
10 W
(dltO = 0.08;) S
LHL
(  }) S
PHL
(  ) S
LHL
(  // Convert Momentum to MeV/c) S
EndPage
EndDSCPage
EndSheet

%%Page: 61 61
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 4327 def
/PageNumber 61 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
4680 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  P = 1.e3 * P;) S
PHL
(  ) S
LHL
(  double E = 0;) S
5 W
(// MeV) S
LHL
(  E = sqrt\(pow\(P,2\) + pow\(uam,2\)\); // MeV) S
PHL
(  ) S
LHL
(  double beta = 0;) S
LHL
(  beta = P/E;) S
PHL
(  ) S
LHL
(  double gamma = 0;) S
LHL
(  gamma = E/uam;) S
PHL
(  ) S
LHL
(  double eta = 0;) S
LHL
(  eta = beta * gamma;) S
PHL
(  ) S
LHL
(  double X = 0;) S
LHL
(  X = log10 \(eta\);) S
PHL
(  ) S
LHL
(  double delta = 0;) S
LHL
(  // Density Effect correction \(Using Sternheimer's parametrization\)) S
PHL
(  ) S
LHL
(  if \(Z==6.0 || Z == 26.0 || Z == 29.0 || Z == 13.0\) {) S
LHL
(    if \(log10\(eta\) >= X1\) {) S
LHL
(      delta) S
5 W
(= 2 * log\(10\) * log10\(eta\) - Cbar;) S
LHL
(    } else if \(log10\(eta\) > X0 && log10\(eta\) < X1\) {) S
LHL
(      delta) S
5 W
(= 2 * log\(10\) * log10\(eta\) - Cbar + a * pow\(\(X1-log10\(eta\)\),am\);) S
LHL
(    } else {) S
LHL
(      delta) S
5 W
(= dltO * pow\(10.0,2*\(X-X0\)\);) S
LHL
(    }) S
LHL
(    if \(Z==6 && log10\(eta\) < X0\) {) S
LHL
(      delta = 0.0;) S
LHL
(    }) S
LHL
(  } else {) S
LHL
(    delta = 0.0;) S
LHL
(  }) S
PHL
(  ) S
LHL
(  //double BetheBloch;) S
LHL
(  ////////////////////////////////////////////////////////////////////) S
LHL
(  // Bethe-Bloch: ionization loss) S
LHL
(  BetheBloch = 0.15353 * \(Z/A\) * \(1/pow\(beta,2\)\) * \(log\(\(4 * pow\(em,2\) * pow\(eta,4\)\)/\(pow\(aI,2) S
SL
(\)*\(1 + \(em/uam\)*sqrt\(1+pow\(eta,2\)\)\)\)\)-2*pow\(beta,2\)-delta\);) S
LHL
(  // found in MeV. cm^2/g) S
LHL
(  //cout<<"Material "<<Z<<"P "<<P<<"     "<<"BetheBloch = "<<BetheBloch<<endl;) S
LHL
(  ////////////////////////////////////////////////////////////////////) S
PHL
(  ) S
LHL
(  double dl) S
5 W
(= 0; // cm) S
LHL
(  double rds) S
4 W
(= 0; // g/cm^2) S
PHL
(  ) S
LHL
(  dz = 100 * dz;) S
16 W
(// z-step; dz expressed in cm) S
LHL
(  dl = fabs\(T*dz\);) S
6 W
(// total length; found in cm) S
LHL
(  rds = rho * dl;) S
15 W
(// rds is found in the units of g/cm^2) S
LHL
(  //cout<<"rds \(g/cm^2\) = "<<rds<<endl;) S
PHL
(  ) S
LHL
(  // [MeV]     BetheBloch        rds         ) S
LHL
(  // Eloss = \(MeV*cm^2 / g\) * \(g/cm^2\) * [T] = MeV = GeV/1000) S
PHL
(  ) S
LHL
(  double Eloss;) S
LHL
(  Eloss) S
1 W
(= 0.0;) S
LHL
(  axi) S
11 W
(= 0;) S
LHL
(  aT_max) S
8 W
(= 0;) S
PHL
(  ) S
LHL
(  // Eventually we will treat tracks going through a support structure) S
LHL
(  // in a function different from PredictedStateCov. Here we deal with) S
LHL
(  // those tracklets for which \(NewPlane - Plane\) = 1. For these track) S
LHL
(  // -lets, the following conition is fine to find out the mean energy) S
LHL
(  // loss:) S
PHL
(  ) S
LHL
(  Eloss) S
1 W
(= BetheBloch * rds; // this is found in MeV) S
LHL
(  Eloss) S
1 W
(= 1.e-3 * Eloss; // GeV) S
LHL
(  axi) S
11 W
(= 0.15353*\(Z/A\) * \(rds/pow\(beta,2\)\);) S
4 W
(// MeV) S
LHL
(  axi) S
11 W
(= 1.e-3 * axi;) S
LHL
(  aT_max) S
8 W
(= \(2 * em * pow\(eta,2\)\)/\(1 + 2 * \(em/uam\) * sqrt\(1 + pow\(eta,2\)\)\);) S
LHL
(  aT_max) S
8 W
(= 1.e-3 * aT_max;) S
PHL
(  ) S
LHL
(  return Eloss;) S
LHL
(}) S
PHL
LHL
(void InoTrackFitAlg::GetMultipleScattering\(double* i2state,double Bx, double By, double dz,/* ) S
SL
(double xi,*/ double aT_max, double aI, TGeoMaterial* material\) {) S
EndPage
EndDSCPage
EndSheet

%%Page: 62 62
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 4403 def
/PageNumber 62 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
4758 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  //cout<<"*****MS matrix*****"<<endl;) S
PHL
(  ) S
LHL
(  double tx = 0; double ty = 0; double qbyP = 0; // general elements of the state vector) S
PHL
(  ) S
LHL
(  tx=i2state[2];) S
LHL
(  ty=i2state[3];) S
LHL
(  qbyP=i2state[4];) S
PHL
(  ) S
LHL
(  double T=sqrt\(1+pow\(tx,2\)+pow\(ty,2\)\);) S
LHL
(  double kappa) S
2 W
(= 0.299792458;) S
LHL
(  double uam = 0.1056;   // GeV) S
LHL
(  double P = 0;) S
LHL
(  double E = 0;) S
LHL
(  double Z = material->GetZ\(\);) S
LHL
(  double dn= material->GetDensity\(\);) S
PHL
(  ) S
LHL
(  if \(fabs\(qbyP\) < 0.01\) {) S
LHL
(    P = 100.0;) S
2 W
(// GeV) S
LHL
(  } else if \(fabs\(qbyP\) >= 0.01 && fabs\(qbyP\) <= 4.0\) {) S
LHL
(    P = fabs\(1/qbyP\);) S
3 W
(// GeV) S
LHL
(  } else {) S
LHL
(    P = 0.25;) S
LHL
(  }) S
LHL
(  E = sqrt\(pow\(P,2\) + pow\(uam,2\)\); // GeV) S
PHL
(  ) S
LHL
(  double beta = 0;) S
LHL
(  beta = P/E;) S
PHL
(  ) S
LHL
(  double gamma = 0;) S
LHL
(  gamma = E/uam;) S
PHL
(  ) S
LHL
(  double eta = 0;) S
LHL
(  eta = beta * gamma;) S
PHL
(  ) S
LHL
(  double h = kappa * qbyP * T;) S
PHL
(  ) S
LHL
(  double Rx= Bx * dz * h;) S
LHL
(  double Ry= By * dz * h;) S
LHL
(  double Sx= 0.5 * Bx * pow\(dz,2\) * h;) S
LHL
(  double Sy= 0.5 * By * pow\(dz,2\) * h;) S
PHL
(  ) S
LHL
(  //  double Lkappa = xi/aT_max;) S
LHL
(  double Q55 = 0;) S
PHL
(  ) S
LHL
(  // Q55 = [?\(P\)]^2/P^4 = \(E^2/P^6\)*[?\(E\)]^2) S
PHL
(  ) S
LHL
(  // if \(Lkappa <= 0.05\)) S
LHL
(  // Q55 = \(\(pow\(E,2\)\)/\(pow\(P,6\)\)\) * pow\(\(100.0 * xi\),2\);) S
31 W
(// Lan) S
SL
(dau) S
LHL
(  // else) S
LHL
(  // Q55 = \(\(pow\(E,2\)\)/\(pow\(P,6\)\)\) * \(1 - pow\(beta,2\)/2\) * xi * aT_max;// Gaussian) S
PHL
(  ) S
LHL
(  //Q55 = \(0.25 * \(xi/\(P*P\)\) * T\)*\(0.25 * \(xi/\(P*P\)\) * T\);) S
22 W
(// MINOS \(John) S
SL
( Marshall\)) S
PHL
(  ) S
LHL
(  double f2) S
13 W
(= 2./Z;) S
LHL
(  double f1) S
13 W
(= 1-f2;) S
LHL
(  double e2) S
13 W
(= 10.0*\(Z*Z\);) S
51 W
(//eV) S
LHL
(  double e1) S
13 W
(= pow\(\(\(aI*1.e6\)/pow\(e2,f2\)\),\(1./f1\)\);) S
2 W
(//\(eV?\) mean excitation energy) S
SL
( "aI" converted to eV, then formula applied) S
LHL
(  double r) S
14 W
(= 0.4;) S
LHL
(  double dEds) S
3 W
(= BetheBloch * dn;) S
46 W
(//MeV/cm) S
LHL
(  aI) S
28 W
(= 1.e-3 *aI;) S
50 W
SL
10 W
(//GeV) S
PHL
(  ) S
LHL
(  double SIGMA_1) S
8 W
(= dEds * \(1-r\) * \(f1*\(log\(2*uam*eta*eta/\(1.e-9*e1\)\)-beta*beta\)\)/\(1.e-6) S
SL
(*e1*\(log\(2*uam*eta*eta/aI\)-beta*beta\)\);) S
LHL
(  double SIGMA_2) S
8 W
(= dEds * \(1-r\) * \(f2*\(log\(2*uam*eta*eta/\(1.e-9*e2\)\)-beta*beta\)\)/\(1.e-6) S
SL
(*e2*\(log\(2*uam*eta*eta/aI\)-beta*beta\)\);) S
LHL
(  double SIGMA_3) S
8 W
(= dEds * r * \(1.0/\(1.e3*aI*\(1+aI/aT_max\)\)\)*\(1.0/log\(1+aT_max/aI\)\);) S
PHL
(  ) S
LHL
(  double alpha) S
2 W
(= 0.0;) S
LHL
(  alpha = 0.997;) S
PHL
(  ) S
LHL
(  double Ealpha) S
1 W
(= \(aI*\(aI + aT_max\)\)/\(aI + \(1-alpha\)*aT_max\);) S
LHL
(  double E_bar) S
2 W
(= \(1 + aI/aT_max\) * aI * log\(Ealpha/aI\);) S
32 W
(//\(\(aI) S
SL
(*\(aI + aT_max\)\)/aT_max\)*log\(Ealpha/aI\);) S
LHL
(  double E_sq_bar= \(1 + aI/aT_max\) * aI * \(Ealpha - aI\);) S
EndPage
EndDSCPage
EndSheet

%%Page: 63 63
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 4474 def
/PageNumber 63 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
4836 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  double SgmAlpSq= E_sq_bar - E_bar*E_bar;) S
PHL
(  ) S
LHL
(  int n1 = PoissonRn->Poisson\(SIGMA_1\);) S
LHL
(  int n2 = PoissonRn->Poisson\(SIGMA_2\);) S
LHL
(  int n3 = PoissonRn->Poisson\(SIGMA_3\);) S
PHL
(  ) S
LHL
(  e1) S
28 W
(= 1.e-9*e1;) S
LHL
(  e2) S
28 W
(= 1.e-9*e2;) S
LHL
(  double SigmaSqE= n1 * e1*e1 + n2 * e2*e2 + n3 * E_bar*E_bar + n3 * SgmAlpSq * \(n3 + 1\);) S
PHL
(  ) S
LHL
(  Q55 = \(\(pow\(E,2\)\)/\(pow\(P,6\)\)\) * SigmaSqE;) S
LHL
(  //Q55 = \(\(pow\(E,2\)\)/\(pow\(P,6\)\)\) * pow\(\(75.0 * xi\),2\);) S
PHL
(  ) S
LHL
(  /*) S
4 W
(if \(Z==26.0\){cout<<"SigmaSqE "<<SigmaSqE<<endl;) S
LHL
8 W
(cout<<"n1 "<<n1<<"     SIGMA1 "<<SIGMA_1<<endl;) S
LHL
8 W
(cout<<"n2 "<<n2<<"     SIGMA2 "<<SIGMA_2<<endl;) S
LHL
8 W
(cout<<"n3 "<<n3<<"     SIGMA3 "<<SIGMA_3<<endl;) S
LHL
8 W
(cout<<"..............................."<<endl;}*/) S
PHL
(  ) S
LHL
(  double Rxx = 0.5 * Bx * Bx * pow\(dz,2\);) S
7 W
(double Sxx = \(1/6\)*Bx*Bx*pow\(dz,3\);) S
LHL
(  double Rxy = 0.5 * Bx * By * pow\(dz,2\);) S
7 W
(double Sxy = \(1/6\)*Bx*By*pow\(dz,3\);) S
LHL
(  double Ryx = 0.5 * By * Bx * pow\(dz,2\);) S
7 W
(double Syx = \(1/6\)*By*Bx*pow\(dz,3\);) S
LHL
(  double Ryy = 0.5 * By * By * pow\(dz,2\);) S
7 W
(double Syy = \(1/6\)*By*By*pow\(dz,3\);) S
PHL
(  ) S
LHL
(  double fx = 0.0; double fy = 0.0; double ftx = 0.0; double fty = 0.0;) S
LHL
(  fx = -qbyP*Q55*pow\(kappa*T,2\)*\(tx*\(3*ty*ty+1\)*Sxx - ty*\(3*tx*tx+1\)*Sxy -ty*\(3*tx*tx+1\)*Syx +) S
SL
( tx*\(3*tx*tx+3\)*Syy\);) S
LHL
(  fy = -qbyP*Q55*pow\(kappa*T,2\)*\(ty*\(3*ty*ty+3\)*Sxx - tx*\(3*ty*ty+1\)*Sxy -tx*\(3*ty*ty+1\)*Syx +) S
SL
( ty*\(3*tx*tx+1\)*Syy\);) S
LHL
(  ftx= -qbyP*Q55*pow\(kappa*T,2\)*\(tx*\(3*ty*ty+1\)*Rxx - ty*\(3*tx*tx+1\)*Rxy -ty*\(3*tx*tx+1\)*Ryx +) S
SL
( tx*\(3*tx*tx+3\)*Ryy\);) S
LHL
(  fty= -qbyP*Q55*pow\(kappa*T,2\)*\(ty*\(3*ty*ty+3\)*Rxx - tx*\(3*ty*ty+1\)*Rxy -tx*\(3*ty*ty+1\)*Ryx +) S
SL
( ty*\(3*tx*tx+1\)*Ryy\);) S
PHL
(  ) S
LHL
(  //  double Lo = 0.01757;) S
LHL
(  double dl = fabs\(T * dz\);) S
PHL
(  ) S
LHL
(  double RdL) S
4 W
(= material->GetRadLen\(\);) S
8 W
(// cm) S
LHL
(  double X0) S
5 W
(= 1.e-2 * RdL;) S
18 W
(// m) S
LHL
(  double Xs) S
5 W
(= X0 * \(1.0+1.0/Z\) * log\(287.0/sqrt\(Z\)\)/log\(159.0/cbrt\(Z\)\);) S
PHL
8 W
LHL
(  {) S
LHL
(    //double Cms) S
8 W
(= pow\(\(0.0136/\(beta * P\)\),2.0\) * \(T*fabs\(dz\)/Lo\) * pow\(1 + 0.038 * log) S
SL
(\(T*fabs\(dz\)/Lo\),2\);) S
LHL
(    double Cms) S
2 W
(= \(225.0 *\(1.0+10.0/\(\(double\)nHit\)\)* 1.e-6 * fabs\(T*dz\)\)/\(beta*beta*P*P*Xs\);) S
2 W
SL
2 W
(// Fontana-modified) S
LHL
(    //double Cms) S
8 W
(= \(225.0 * 1.e-6 * fabs\(T*dz\)\)/\(beta*beta*P*P*Xs\);) S
6 W
(// Fontana) S
LHL
(    double Ctxtx= \(1 + tx*tx\) * T*T * Cms; ) S
LHL
(    double Ctxty= tx * ty * T*T * Cms;) S
LHL
(    double Ctyty= \(1 + ty*ty\) * T*T * Cms;) S
LHL
(    double D;) S
PHL
(    ) S
LHL
(    if \(dz > 0.0\) {) S
LHL
(      D = + 1.0;) S
LHL
(    } else {) S
LHL
(      D = - 1.0;) S
LHL
(    }) S
LHL
(    Q_k_minus[0][0]= Ctxtx * pow\(dl,2.0\)/3.0;) S
LHL
(    Q_k_minus[0][1]= Ctxty * pow\(dl,2.0\)/3.0;) S
LHL
(    Q_k_minus[0][2]= Ctxtx * D * pow\(dl,1.0\)/2.0;) S
LHL
(    Q_k_minus[0][3]= Ctxty * D * pow\(dl,1.0\)/2.0;) S
LHL
(    Q_k_minus[0][4]= kappa * T * \(tx*ty*Sx - \(1.0+tx*tx\)*Sy\) * Q55 + fx;) S
PHL
(    ) S
LHL
(    Q_k_minus[1][0]= Ctxty * pow\(dl,2.0\)/3.0;) S
LHL
(    Q_k_minus[1][1]= Ctyty * pow\(dl,2.0\)/3.0;) S
LHL
(    Q_k_minus[1][2]= Ctxty * D * pow\(dl,1.0\)/2.0;) S
LHL
(    Q_k_minus[1][3]= Ctyty * D * pow\(dl,1.0\)/2.0;) S
LHL
(    Q_k_minus[1][4]= kappa * T * \(\(1.0+ty*ty\)*Sx - tx*ty*Sy\) * Q55 + fy;) S
PHL
(    ) S
LHL
(    Q_k_minus[2][0]= Ctxtx * D * pow\(dl,1.0\)/2.0;) S
LHL
(    Q_k_minus[2][1]= Ctxty * D * pow\(dl,1.0\)/2.0;) S
LHL
(    Q_k_minus[2][2]= Ctxtx;) S
LHL
(    Q_k_minus[2][3]= Ctxty;) S
LHL
(    Q_k_minus[2][4]= kappa * T * \(tx*ty*Rx - \(1.0+tx*tx\)*Ry\) * Q55 + ftx;) S
PHL
(    ) S
LHL
(    Q_k_minus[3][0]= Ctxty * D * pow\(dl,1.0\)/2.0;) S
LHL
(    Q_k_minus[3][1]= Ctyty * D * pow\(dl,1.0\)/2.0;) S
LHL
(    Q_k_minus[3][2]= Ctxty;) S
EndPage
EndDSCPage
EndSheet

%%Page: 64 64
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 4546 def
/PageNumber 64 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
4914 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(    Q_k_minus[3][3]= Ctyty;) S
LHL
(    Q_k_minus[3][4]= kappa * T * \(\(1.0+ty*ty\)*Rx - tx*ty*Ry\) * Q55 + fty;) S
PHL
(    ) S
LHL
(    Q_k_minus[4][0]=kappa * T * \(tx*ty*Sx - \(1.0+tx*tx\)*Sy\) * Q55 + fx;) S
LHL
(    Q_k_minus[4][1]=kappa * T * \(\(1.0+ty*ty\)*Sx - tx*ty*Sy\) * Q55 + fy;) S
LHL
(    Q_k_minus[4][2]=kappa * T * \(tx*ty*Rx - \(1.0+tx*tx\)*Ry\) * Q55 + ftx;) S
LHL
(    Q_k_minus[4][3]=kappa * T * \(\(1.0+ty*ty\)*Rx - tx*ty*Ry\) * Q55 + fty;) S
LHL
(    Q_k_minus[4][4]=Q55;) S
LHL
(  }) S
LHL
(  //) S
4 W
(cout<<"*****MS matrix ends*****"<<endl;) S
LHL
(}) S
LHL
(void InoTrackFitAlg::KalmanFilterStateVector\(double *x__minus, const int Plane, const bool GoF) S
SL
(orward, double x_kk[6]\) {) S
LHL
(  //cout<<"*****Compare predicted \(x,y\) with Experimental \(x,y\) *****"<<endl;) S
PHL
(  ) S
LHL
(  for \(int ij=0; ij<5; ij++\) {) S
LHL
(    //cout<<"x__minus = "<<x__minus[ij]<<endl;) S
LHL
(  }) S
PHL
(  ) S
LHL
(  //  double H_k[2][5];) S
LHL
(  double m_k[2]={0,0};) S
LHL
(  double M_k[2]={0,0};) S
LHL
(  double sigma_xx = 0;) S
LHL
(  double sigma_yy = 0;) S
LHL
(  //  double chisquare= 0;) S
PHL
(  ) S
LHL
(  int PlaneView = TrkClustsData[Plane][0].PlaneView;) S
LHL
(  for \(int ij=0; ij<2; ij++\) {) S
LHL
(    for \(int jk=0; jk<5; jk++\) {) S
LHL
(      H_k[ij][jk]=0;) S
LHL
(    }) S
LHL
(  }) S
LHL
(  if \(PlaneView%2==0\) {) S
LHL
(    H_k[0][0]=1;) S
LHL
(    m_k[0]) S
6 W
(= TrkClustsData[Plane][0].XPos;) S
LHL
(    M_k[0]) S
6 W
(= m_k[0];) S
LHL
(    sigma_xx= TrkClustsData[Plane][0].XPosErrSq;) S
LHL
(  }) S
LHL
(  if \(PlaneView>0\) {) S
LHL
(    H_k[1][1]=1;) S
LHL
(    m_k[1]) S
6 W
(= TrkClustsData[Plane][0].YPos;) S
LHL
(    M_k[1]) S
6 W
(= m_k[1];) S
LHL
(    sigma_yy= TrkClustsData[Plane][0].YPosErrSq;) S
16 W
LHL
(  }) S
PHL
(  ) S
LHL
(  for \(int ij=0; ij<2; ij++\) {) S
LHL
(    for \(int jk=0; jk<5; jk++\) {) S
LHL
(      m_k[ij] -= H_k[ij][jk]*x__minus[jk];) S
7 W
(//Kisel: m_k[] => [m_k - H_k * F_\(k-1\)*a_\(k-1) S
SL
(\)]) S
LHL
(    }) S
LHL
(  }) S
PHL
(  ) S
LHL
(  for \(int ij = 0; ij < 5; ij++\) {) S
LHL
(    x_kk[ij] = 0;) S
LHL
(  }) S
PHL
8 W
LHL
(  // Calculate x_kk) S
LHL
(  for \(int ij=0; ij<5; ++ij\) {) S
LHL
(    x_kk[ij]=x__minus[ij];) S
PHL
(    ) S
LHL
(    for \(int jk=0; jk<2; jk++\) {) S
LHL
(      x_kk[ij]+=K_k[ij][jk]*m_k[jk];) S
6 W
(//x_kk[] => [x_kk + K_k * m_k] // this is modefied m) S
SL
(_k) S
LHL
(    }) S
LHL
(  }) S
PHL
8 W
LHL
(  double M_MinusX_k[2]={0};) S
LHL
(  M_MinusX_k[0] = M_k[0]-x_kk[0];) S
LHL
(  M_MinusX_k[1] = M_k[1]-x_kk[1];) S
PHL
(  ) S
LHL
(  if\(fabs\(x_kk[0]\)<24.5 && fabs\(x_kk[1]\)<18.5\) { //GMA) S
LHL
(    PassTrack=true;) S
LHL
(  } else {) S
LHL
(    cout<<"================================================="<<endl;) S
LHL
(    cout <<M_k[0] <<"     "<<M_k[1] <<endl;) S
LHL
(    cout <<x__minus[0] <<"     "<<x__minus[1]<<endl;) S
LHL
(    cout <<x_kk[0] <<"     "<<x_kk[1] <<endl;) S
LHL
(    cout<<"................................................."<<endl;) S
EndPage
EndDSCPage
EndSheet

%%Page: 65 65
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 4621 def
/PageNumber 65 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
4992 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(    //cout<<"X "<<FilteredData[Plane-2][5].x_k0<<" and Y "<<FilteredData[Plane-2][5].x_k1<<end) S
SL
(l;) S
LHL
(    //cout<<"X \(Plane-2\) "<<TrkClustsData[Plane-2][0].XPos<<" and Y \(Plane-2\) "<<TrkClustsData) S
SL
([Plane-2][0].YPos<<endl;) S
PHL
(    ) S
LHL
(    cout<< " Passtrack 1 at NIter "<<NIter<<endl;) S
LHL
(    PassTrack=false;) S
LHL
(    cout<<"================================================="<<endl;) S
LHL
(  }) S
PHL
(  ) S
LHL
(  double GPos[3];) S
LHL
(  //GPos denotes the starting \(x,y,z\) of the particle right above the RPC expressed in \(mm\)) S
LHL
(  GPos[0]=x_kk[0] * 1000;) S
LHL
(  GPos[1]=x_kk[1] * 1000;) S
LHL
(  GPos[2]=ZPosLayer[Plane];) S
LHL
(  //cout<<"After KF, "<<"GPos[0] = "<<GPos[0]<<"     "<<"GPos[1] = "<<GPos[1]<<"     "<<"GPos[) S
SL
(2] = "<<GPos[2]<<" Plane="<<Plane<<endl;) S
LHL
(  if \(LastIteration && GoForward ==false && Plane == MinPlane\) {) S
LHL
(    MinPlaneData[0] = x_kk[0];) S
LHL
(    MinPlaneData[1] = x_kk[1];) S
LHL
(    MinPlaneData[2] = x_kk[2];) S
LHL
(    MinPlaneData[3] = x_kk[3];) S
LHL
(    MinPlaneData[4] = x_kk[4];) S
LHL
(    MinPlaneData[5] = GPos[2];) S
LHL
(  }) S
LHL
(  //cout<<"Save data @ MinPlane"<<endl;) S
LHL
(  if \(LastIteration && GoForward == true && Plane == MaxPlane\) {) S
LHL
(    MaxPlaneData[0] = x_kk[0];) S
LHL
(    MaxPlaneData[1] = x_kk[1];) S
LHL
(    MaxPlaneData[2] = x_kk[2];) S
LHL
(    MaxPlaneData[3] = x_kk[3];) S
LHL
(    MaxPlaneData[4] = x_kk[4];) S
LHL
(    MaxPlaneData[5] = GPos[2];) S
LHL
(  }) S
LHL
(  //cout<<"Save data @ MaxPlane"<<endl;) S
LHL
(}) S
PHL
LHL
(//Abhijit's Work. ADB 2015/05/06) S
LHL
(//>>) S
PHL
LHL
(int InoTrackFitAlg::CheckFCPCUpOrDn\(double *ax_k, bool DirExtraPol, int MaxMinPlane, bool GoDi) S
SL
(r\) {) S
PHL
LHL
(  //bit 1 : LocalPos[1];) S
LHL
(  //bit 2 : CheckMat[1]) S
LHL
(  //bit 3 : LocalPos[0]) S
LHL
(  //bit 4 : CheckMat[0]) S
LHL
(  //bit 5-10 : hadron cluster \(only for backward\)) S
LHL
(  //bit 11-12 : Fiducial volume \(top and bottom layer\)) S
LHL
(  //bit 13-16 : Fiducial volume \(X/Y side\)) S
PHL
PHL
LHL
(  const int nEmpyExtr=2;) S
LHL
(  const int nMxShowerlayer=6;) S
LHL
(  //  bool tmpFCPC[nEmpyExtr] =0;) S
LHL
(  int CheckMat[nEmpyExtr] = {0};) S
LHL
(  int LocalPos[nEmpyExtr] = {0};) S
LHL
(  int isHadCluster[2] = {0};) S
LHL
(  int FiducialZ = 3;) S
LHL
(  double FiducialX = 100.0;) S
LHL
(  double FiducialY = 100.0;) S
PHL
LHL
(  double dir[3]={0.0};) S
LHL
(  // int N2 = ptrackCollection2->InoTrack_list.size\(\);) S
LHL
(  int nextplane =0;) S
LHL
(  // double StateVector[6]) S
6 W
(= {0.0};) S
LHL
(  double Prediction[6]) S
2 W
(= {0.0};) S
PHL
LHL
(  double tmpax_k[5];) S
LHL
(  double tmpC_k_intermediate[5][5];) S
LHL
(  for \(int ij=0; ij<5; ij++\) {) S
LHL
(    tmpax_k[ij] = ax_k[ij];) S
LHL
(    for \(int jk=0; jk<5; jk++\) {) S
LHL
(      tmpC_k_intermediate[ij][jk] = C_k_intermediate[ij][jk];) S
LHL
(    }) S
LHL
(  }) S
PHL
LHL
(  //DirExtraPol = 1 for upward extrapolation) S
EndPage
EndDSCPage
EndSheet

%%Page: 66 66
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 4695 def
/PageNumber 66 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
5070 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  //DirExtraPol = 0 for downward extrapolation) S
PHL
LHL
(  int iext=0;) S
LHL
(  int iempty=0;) S
LHL
(  while\(iext<nMxShowerlayer && iempty<nEmpyExtr\) {) S
LHL
(    iext++;) S
LHL
(    // cout <<"iext "<<int\(DirExtraPol\)<<" "<<int\(GoDir\)<<" "<<iext<<endl;) S
LHL
(    double dsExt = 0.0;) S
LHL
(    double drangeExt = 0.0;) S
LHL
(    if\(DirExtraPol\) {) S
LHL
(      // cout<<"Extrapolating upwards ..."<<endl;) S
LHL
(      nextplane = MaxMinPlane + iext;) S
LHL
(      if \(nextplane >= int\(nLayer\)\) { break;} //{nextplane = nLayer-1;}) S
LHL
(    } else {) S
LHL
(      // cout<<"Extrapolating downwards ..."<<endl;) S
LHL
(      nextplane = MaxMinPlane - iext;) S
LHL
(      if \(nextplane <0\) { break;} // {nextplane = 0;}) S
LHL
(    }) S
PHL
(    ) S
LHL
(    bool GetPrediction= PredictedStateCov\(ax_k, MaxMinPlane, nextplane, GoDir, Prediction, 0, ) S
SL
(&dsExt, &drangeExt\);) S
PHL
(    ) S
LHL
(    if \(GetPrediction\) { ) S
LHL
(      double pos[3] = {100*Prediction[0],100*Prediction[1],100*ZPosLayer[nextplane]};) S
LHL
(      dir[0] = 0.0;) S
LHL
(      dir[1] = 0.0;) S
LHL
(      dir[2] = 1.0;) S
PHL
(      ) S
LHL
(      // cout<<"MaxMinPlane = "<<MaxMinPlane<<", nextplane = "<<nextplane<<", GoDir = "<<GoDir) S
SL
(<<", Prediction = "<<pos[0]<<" "<<pos[1]<<" "<<pos[2]<<", Initial Pos = "<<100*ax_k[0]<<", "<<) S
SL
(100*ax_k[1]<<", "<<100*ZPosLayer[MaxMinPlane]<<endl;) S
PHL
LHL
(      // cout <<"iext2 "<<iext<<endl;) S
LHL
(      icalGeometry->InitTrack\(pos, dir\);) S
PHL
LHL
(      double localpos[3];) S
LHL
(      icalGeometry->MasterToLocal\(pos, localpos\);) S
PHL
LHL
(      localmat= icalGeometry->GetCurrentVolume\(\)->GetMaterial\(\);) S
PHL
(      ) S
LHL
(      // Putting the conditions to check FC or PC) S
LHL
(      CheckMat[iempty] = 0;) S
LHL
(      iempty++;) S
LHL
(      if \(strstr\(localmat->GetName\(\),"rpcgas"\)\) {) S
LHL
8 W
(//cout <<"localpos "<<pos[0]<<" "<<pos[1]<<" "<<pos[2]<<" "<<localpos[0]<<" "<<localpo) S
SL
(s[1]<<" "<<localpos[2]<<" "<<localmat->GetName\(\)<<endl;) S
PHL
8 W
LHL
(        CheckMat[iempty-1] = 1;) S
LHL
(        LocalPos[iempty-1] = 1; // \(\(pargasxyz[0]-abs\(localpos[0]\)>2.0\) &&  \(pargasxyz[1]-abs\() S
SL
(localpos[1]\)>2.0\)\) ? 1 : 0;) S
LHL
(        // cout<<".............................................."<<endl;) S
LHL
(        // cout<<"Fully Contained..."<<DirExtraPol<<"..."<<GoDir<<"...NextPlane..."<<nextplane) S
SL
(<<endl;) S
LHL
(        // cout <<"pos "<<pos[0]<<" "<<pos[1]<<" "<<pos[2]<<endl;) S
LHL
(        // cout<<"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"<<endl;) S
LHL
(        int clusterid = \(DirExtraPol!=GoDir\) ? 0 : 1;) S
PHL
(        ) S
LHL
(        // for \(unsigned int iht=0; iht<inoHit_pointer->InoHit_list.size\(\); iht++\) {) S
LHL
(        int nhit=0;) S
LHL
(        InoCluster* Clust = 0;) S
LHL
(        for \(unsigned int iclust=0; iclust<InoCluster_pointer->InoCluster_list.size\(\); iclust+) S
SL
(+\) {) S
LHL
(          if \(InoCluster_pointer->InoCluster_list[iclust]->GetZPlane\(\)==nextplane\) { ) S
LHL
(            if \(abs\(InoCluster_pointer->InoCluster_list[iclust]->GetXPos\(\) - Prediction[0]\)<2*) S
SL
(StripXWidth && ) S
LHL
(                abs\(InoCluster_pointer->InoCluster_list[iclust]->GetYPos\(\) - Prediction[1]\)<2*) S
SL
(StripYWidth\) {) S
LHL
(              // cout <<"iclust "<<iclust<<endl;) S
LHL
(              for\(unsigned int iht=0; iht<InoCluster_pointer->InoCluster_list[iclust]->HitsInC) S
SL
(luster.size\(\); iht++\) {) S
LHL
(                if \(abs\(InoCluster_pointer->InoCluster_list[iclust]->HitsInCluster[iht]->GetXP) S
SL
(os\(\) - Prediction[0]\)<2*StripXWidth && ) S
LHL
(                    abs\(InoCluster_pointer->InoCluster_list[iclust]->HitsInCluster[iht]->GetYP) S
SL
(os\(\) - Prediction[1]\)<2*StripYWidth\) {) S
LHL
(                  InoCluster_pointer->InoCluster_list[iclust]->HitsInCluster[iht]->SetUID\(10+c) S
SL
(lusterid\);) S
LHL
(                  // InoCluster_pointer->InoCluster_list[iclust]->HitsInCluster[iht]->SetUID\(3) S
SL
(+clusterid\);) S
EndPage
EndDSCPage
EndSheet

%%Page: 67 67
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 4759 def
/PageNumber 67 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
5148 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(                  nhit++;) S
LHL
(                  if\(nhit==1\) {) S
LHL
(                    Clust = new InoCluster\(InoCluster_pointer->InoCluster_list[iclust]->HitsIn) S
SL
(Cluster[iht]\);) S
LHL
(                  } else if\(nhit>1\) {) S
LHL
(                    Clust->AddHit\(InoCluster_pointer->InoCluster_list[iclust]->HitsInCluster[i) S
SL
(ht]\);) S
LHL
(                  }) S
LHL
(                  // inoHit_pointer->InoHit_list[iht]->SetUID\(3+clusterid\);) S
LHL
(                  LocalPos[iempty-1] = 0;) S
LHL
(                  CheckMat[iempty-1] = 0;) S
LHL
(                  iempty = 0;) S
LHL
(                  // cout<<"Cluster Found....."<<endl;) S
LHL
(                  // cout<<"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"<<endl;) S
LHL
(                }) S
LHL
(              }) S
LHL
(            }) S
LHL
(          }) S
LHL
(        }) S
PHL
(        ) S
LHL
(        // cout <<"nhit "<<nhit<<endl;) S
LHL
(        if\(!GoDir\) {) S
LHL
(          if \(nhit>isHadCluster[1]\) { isHadCluster[1] =nhit;}) S
LHL
(          if \(nhit>isHadCluster[0]\) { isHadCluster[1] = isHadCluster[0]; isHadCluster[0]=nhit;) S
SL
(}) S
PHL
(          ) S
LHL
(          FiducialZ = min\( min\( FiducialZ, nextplane\), int\(nLayer-1-nextplane\)\);) S
LHL
(          FiducialX = min\(FiducialX, abs\(IcalX-abs\(Prediction[0]\)\)\); ) S
LHL
(          FiducialY = min\(FiducialY, abs\(IcalY-abs\(Prediction[1]\)\)\); ) S
PHL
(          ) S
LHL
(          for \(int ix=0; ix<5; ix++\) {) S
LHL
(            ax_k[ix] = Prediction[ix];) S
LHL
(          }) S
LHL
(          ExtrapCovMatrixall\(\); // Also propagate the error matrix) S
LHL
(          // cout <<"GPL "<<GPL<<endl;) S
LHL
(          if \(Clust\) {) S
LHL
(            fTrackCand->ClustsInTrack.push_back\(Clust\);) S
LHL
(            GPL += dsExt;) S
LHL
(            RNG += drangeExt;) S
LHL
(            if \(DirExtraPol\) {) S
LHL
(              MaxPlane = nextplane;) S
LHL
(            } else {) S
LHL
(              MinPlane = nextplane;) S
LHL
(            }) S
PHL
12 W
LHL
(            //Update track paramters in local variables) S
LHL
(            for \(int ij=0; ij<5; ij++\) {) S
LHL
(              tmpax_k[ij] = ax_k[ij];) S
PHL
(              ) S
LHL
(              FiltDataStruct temp;) S
PHL
(              ) S
LHL
(              temp.x_k0=ax_k[0]; temp.x_k1=ax_k[1];) S
LHL
(              temp.x_k2=ax_k[2]; temp.x_k3=ax_k[3];) S
LHL
(              temp.x_k4=ax_k[4];) S
PHL
(              ) S
LHL
(              temp.x_k5=1;) S
LHL
(              temp.x_k6=true;) S
LHL
(              FilteredData[nextplane].push_back\(temp\);) S
PHL
(              ) S
LHL
(              for \(int jk=0; jk<5; jk++\) {) S
LHL
(                tmpC_k_intermediate[ij][jk] = C_k_intermediate[ij][jk];) S
LHL
(              }) S
LHL
(            }) S
LHL
(          }) S
PHL
(          ) S
LHL
(        }) S
LHL
(        // cout <<"nhit2 "<<nhit<<endl;) S
LHL
(      } //  if \(strstr\(localmat->GetName\(\),"rpcgas"\)\)) S
LHL
(      //      tmpFCPC = CheckMat && LocalPos;) S
LHL
(      // cout<<"Dir "<<DirExtraPol<<", FCorPC "<<FiducialX<<" "<<FiducialY<<endl;) S
LHL
(    } //  for\(int r=iext;r<iext; iext++\) {) S
LHL
(    // cout<<"yyyyy "<<endl;) S
LHL
(  }) S
PHL
(  ) S
LHL
(  //return back in global track paramter) S
LHL
(  for \(int ij=0; ij<5; ij++\) {) S
LHL
(    ax_k[ij] = tmpax_k[ij];) S
LHL
(    for \(int jk=0; jk<5; jk++\) {) S
EndPage
EndDSCPage
EndSheet

%%Page: 68 68
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 4834 def
/PageNumber 68 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
5226 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(      C_k_intermediate[ij][jk] = tmpC_k_intermediate[ij][jk];) S
LHL
(    }) S
LHL
(  }) S
PHL
(  ) S
LHL
(  int alltags = 0;) S
LHL
(  if \(!GoDir\) {) S
LHL
(    int tmpx = min\(3, int\(FiducialX*10\)\); //FiducialX is in metre and want to have scale of 10) S
SL
(cm) S
LHL
(    int tmpy = min\(3, int\(FiducialY*10\)\);) S
LHL
(    alltags +=tmpx;) S
LHL
(    alltags<<=2;) S
LHL
(    alltags +=tmpy;) S
LHL
(    alltags<<=2;) S
LHL
(    alltags +=FiducialZ;) S
LHL
(    alltags<<=3;) S
LHL
(    alltags +=min\(7, isHadCluster[0]\);) S
LHL
(    alltags<<=3;) S
LHL
(    alltags +=min\(7, isHadCluster[1]\);) S
LHL
(    alltags<<=4;) S
LHL
(  }) S
LHL
(  alltags +=8*CheckMat[0]+4*LocalPos[0]+2*CheckMat[1]+LocalPos[1];) S
LHL
(  // cout <<"alltags "<<alltags<<endl;) S
LHL
(  return alltags;) S
PHL
LHL
(}) S
PHL
LHL
(bool InoTrackFitAlg::CheckFCPC\(double *ax_k, bool GoForward\) {) S
LHL
(  int ExtremePlane = 0;) S
LHL
(  ExtremePlane = \(GoForward == true\) ? MaxPlane:MinPlane;) S
PHL
(  ) S
LHL
(  double epsilon  = 1.e-6;) S
LHL
(  double dz) S
13 W
(= 0.000000000000000000000000000000000000000;) S
LHL
(  double signp) S
2 W
(= \(GoForward == true\) ? 1.0000 : -1.0000000;) S
LHL
(  double costhinv = sqrt\(1.0 + ax_k[2]*ax_k[2] + ax_k[3]*ax_k[3]\);) S
LHL
(  costhinv) S
14 W
(= \(GoForward == true\) ? costhinv :-costhinv;) S
PHL
(  ) S
LHL
(  double pos[3]={0.0};) S
2 W
(pos[0] = 1.e3*ax_k[0];) S
2 W
(pos[1] = 1.e3*ax_k[1];) S
2 W
(pos[2] = 1.e3*ZPosLaye) S
SL
(r[ExtremePlane];) S
LHL
(  double dir[3]={0.0};) S
2 W
(dir[0] = ax_k[2]/costhinv;) S
6 W
(dir[0] = ax_k[3]/costhinv;) S
6 W
(dir[0]) S
SL
( = 1.0/costhinv;) S
PHL
(  ) S
LHL
(  icalGeometry->InitTrack\(pos, dir\);) S
PHL
(  ) S
LHL
(  double bx = 0.0; double by = 0.0;) S
LHL
(  pFieldMap->ElectroMagneticField\(pos,bx,by,1\);) S
LHL
(  bx *= 1000;) S
LHL
(  by *= 1000;) S
PHL
(  ) S
LHL
(  //  TGeoMaterial *mat= icalGeometry->GetCurrentVolume\(\)->GetMaterial\(\);) S
LHL
(  icalGeometry->FindNextBoundary\(\);) S
LHL
(  double snext= epsilon+gGeoManager->GetStep\(\);) S
LHL
(  //  double atNum= mat->GetZ\(\);) S
PHL
(  ) S
LHL
(  if \(snext > 1.0\) snext=1.0;) S
PHL
(  ) S
LHL
(  if \(strstr\(icalGeometry->GetCurrentVolume\(\)->GetName\(\),"IRLAYElog"\)\) {) S
LHL
(    dz = signp*min\(0.001, 0.01*snext*abs\(dir[2]\)\);) S
LHL
(  } else {) S
LHL
(    bx = by = 0.0;) S
PHL
(    ) S
LHL
(    dz = 0.01*signp*snext*fabs\(dir[2]\); // cm to meter) S
LHL
(    if\(strstr\(icalGeometry->GetCurrentVolume\(\)->GetName\(\),"GASRlog"\)\) { dz = 0.001*signp;}) S
LHL
(  }) S
PHL
(  ) S
LHL
(  double x = ax_k[0];) S
3 W
(double y = ax_k[1];) S
5 W
(double tx = ax_k[2];) S
4 W
(double ty = ax_k[3];//) S
0 W
SL
2 W
(double qp = ax_k[4];) S
LHL
(  double projection[5]={0.0};) S
LHL
(  double qbyP = ax_k[4];// 0;) S
LHL
(  double kappa) S
2 W
(= 0.299792458;) S
LHL
(  double T) S
14 W
(= sqrt\(1+pow\(tx,2\)+pow\(ty,2\)\);) S
LHL
(  if \(ZIncreasesWithTime==false\) T=-T;) S
LHL
(  double h) S
14 W
(= kappa*qbyP*T;) S
LHL
(  double Rx) S
13 W
(= bx*dz*h;) S
LHL
(  double Ry) S
13 W
(= by*dz*h;) S
LHL
(  double Sx) S
13 W
(= 0.5*bx*pow\(dz,2\)*h;) S
LHL
(  double Sy) S
13 W
(= 0.5*by*pow\(dz,2\)*h;) S
LHL
(  double Rxx) S
12 W
(= 0.5 * bx * bx * pow\(dz,2\);) S
4 W
(double Sxx = \(1/6\)*bx*bx*pow\(dz,3\);) S
LHL
(  double Rxy) S
12 W
(= 0.5 * bx * by * pow\(dz,2\);) S
4 W
(double Sxy = \(1/6\)*bx*by*pow\(dz,3\);) S
EndPage
EndDSCPage
EndSheet

%%Page: 69 69
/Lines 4963 def
/PageCount 69 def
1 BeginSheet
BeginDSCPage
/LineNumber 4908 def
/PageNumber 69 def
/HeaderLinesLeft[
 [/h0 (InoTrackFitAlg.cc)]
 [/h1 (~/Desktop/INO_GTP/Phd/PhD_work/latest/all_micalwveto_sipm_v1/src/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (Thursday 26 August 2021)]
]def
2 SetHeaderLines
5304 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  double Ryx) S
12 W
(= 0.5 * by * bx * pow\(dz,2\);) S
4 W
(double Syx = \(1/6\)*by*bx*pow\(dz,3\);) S
LHL
(  double Ryy) S
12 W
(= 0.5 * by * by * pow\(dz,2\);) S
4 W
(double Syy = \(1/6\)*by*by*pow\(dz,3\);) S
PHL
(  ) S
LHL
(  projection[0]) S
1 W
(= x + tx * dz + tx * ty * Sx - \(pow\(tx,2\)+1\) * Sy + h*h * \(tx*\(3*ty*ty+1\)*Sxx ) S
SL
(- ty*\(3*tx*tx+1\)*Sxy -ty*\(3*tx*tx+1\)*Syx + tx*\(3*tx*tx+3\)*Syy\);) S
LHL
(  projection[1]) S
1 W
(= y + ty * dz + \(pow\(ty,2\)+1\) * Sx - tx * ty * Sy + h*h * \(ty*\(3*ty*ty+3\)*Sxx ) S
SL
(- tx*\(3*ty*ty+1\)*Sxy -tx*\(3*ty*ty+1\)*Syx + ty*\(3*tx*tx+1\)*Syy\);) S
LHL
(  projection[2]) S
1 W
(= tx + tx * ty * Rx - \(pow\(tx,2\)+1\) * Ry + h*h * \(tx*\(3*ty*ty+1\)*Rxx - ty*\(3*t) S
SL
(x*tx+1\)*Rxy -ty*\(3*tx*tx+1\)*Ryx + tx*\(3*tx*tx+3\)*Ryy\);) S
LHL
(  projection[3]) S
1 W
(= ty + \(pow\(ty,2\)+1\) * Rx - tx * ty * Ry + h*h * \(ty*\(3*ty*ty+3\)*Rxx - tx*\(3*t) S
SL
(y*ty+1\)*Rxy -tx*\(3*ty*ty+1\)*Ryx + ty*\(3*tx*tx+1\)*Ryy\);) S
PHL
(  ) S
LHL
(  return true;) S
LHL
(}) S
LHL
(//<< ) S
LHL
(//Abhijit's Work ADB 2015/05/06) S
PHL
PHL
LHL
(/* ) S
LHL
(   bool InoTrackFitAlg::CheckSign\(double x, double y, double tx, double ty\) {) S
LHL
(   bool sign;) S
LHL
(   double dz;) S
LHL
(   double TT = sqrt\(1 + tx*tx + ty*ty\);) S
PHL
(  ) S
LHL
(   if \(ZIncreasesWithTime==true\) {) S
LHL
(   signp = \(ZIncreasesWithTime != GoForward\) ? -1 :+1;vtxz=MinPlane;endz=MaxPlane;) S
LHL
(   } else {) S
LHL
(   signp = \(ZIncreasesWithTime != GoForward\) ? +1 :-1;vtxz=MaxPlane;endz=MinPlane;) S
LHL
(   }) S
PHL
(  ) S
LHL
(   double Vtx[3]={x, y, vtxz};) S
LHL
(   double Dir[3]=signp*{\(tx/TT\), \(ty/TT\), \(1.0/TT\)};) S
PHL
(  ) S
LHL
(   for \(int ij = 0; ij<nHit; ij++\) {) S
LHL
(   icalGeometry->InitTrack\(Vtx, Dir\);) S
LHL
(   Bx = By = 0.0;) S
LHL
(   pFieldMap->ElectroMagneticField\(MPos,Bx,By,1\);) S
LHL
(   Bx *= 1000;) S
LHL
(   By *= 1000;) S
PHL
(    ) S
LHL
(   localmat= icalGeometry->GetCurrentVolume\(\)->GetMaterial\(\);) S
LHL
(   icalGeometry->FindNextBoundary\(\);) S
LHL
(   snext) S
8 W
(= epsilon+gGeoManager->GetStep\(\);) S
LHL
(   Z) S
12 W
(= localmat->GetZ\(\);) S
LHL
(   if \(snext > 1.0\) snext=1.0;) S
PHL
(    ) S
LHL
(   if \(strstr\(icalGeometry->GetCurrentVolume\(\)->GetName\(\),"IRLAYElog"\)\) {) S
LHL
(   dz = signp*min\(0.001, 0.01*snext*abs\(dirTrack[2]\)\);) S
LHL
(   } else {) S
LHL
(   Bx = 0.0; By = 0.0;) S
LHL
(   dz = 0.01*signp*snext*abs\(dirTrack[2]\); // cm to meter) S
LHL
(   if\(strstr\(icalGeometry->GetCurrentVolume\(\)->GetName\(\),"GASRlog"\)\)) S
LHL
(   dz = 0.001*signp;) S
LHL
(   }) S
LHL
(   }) S
PHL
(  ) S
LHL
(   return sign;) S
LHL
(   }) S
LHL
(*/) S
PHL
EndPage
EndDSCPage
EndSheet

%%Trailer
%%Pages: 69

EndDoc

%%EOF
